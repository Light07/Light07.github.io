<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自研测试框架Ktest介绍]]></title>
    <url>%2F2018%2F12%2F29%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E8%87%AA%E7%A0%94%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Ktest%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[之前分享过很多优秀的测试框架，总觉得意犹未尽，干脆自己撸起袖子写一个。 添加微信公众号iTesting 查看原文。 在自动化测试的过程中，测试框架是我们绕不过去的一个工具，无论你是不需要写代码直接改动数据生成脚本，还是你需要检查测试结果甚至持续集成，测试框架都在发挥它的作用。不同编程语言的实现出来的框架也不尽相同，但是思想总是相通的，比如尽量使框架使用者只关注自己的业务，框架帮助处理错误截图，保存错误log，出错重试甚至跟jenkins持续集成等。 可以说，一个还算合格的测试框架，可以大大提升测试效率；一个优秀的测试框架，说它能把测试人员从繁缛复杂的跟业务无关但又不得不做的工作中解脱出来也不为过。既然框架的作用这么明显，那么有哪些优秀的测试框架可以给我们用呢？ 大家都知道， java里有TestNG， python里有unittest，pytest等优秀的“官方”框架， 我对python比较熟悉，之前也介绍过很多这方面的文章，相信大家也多少看过一两篇。可以说，能把这些经过百万人检验的“官方”测试框架工具用好用顺，拿下本职工作根本不在话下，更不用说你还能用好围绕着这些工具的生态库了，那简直是如入无人之地。 那么，为什么还要自己写一个框架呢？ 相信常做自动化的都有自己的感悟， 比如自己业务没那么复杂，官方框架显得太重了；比如官方框架依赖很多的第三方库，每个要单独安装，更新，而且每个都有自己的用法，学习成本高；再比如说，鞋子合脚不合脚，有的人要穿7年才能知道（对，那谁）。 痛点：对于常用python写自动化的来说，unittest本身很优秀，但是不支持并发，而且测试报告支持的也不好，也不支持数据驱动。pytest那里都好，就是吃了酒香不怕巷子深的亏，那个docouments真要心非常静才能读下去， 另外什么功能都需要额外安装一个库，你想并发？好，装一个pytest-parallel，你想报告html展示？好，装个pytest-html， 你想要错误的测试用例自动重跑一遍？好，装个pytest-rerunfailures。 强大是强大，感觉有点过于繁琐了。 解决方案：基于上述痛点，大部分同学选择在原有开源框架上二次开发，比如unittest集合多线程threading.Thread实现并发，加入HTMLTestRunner实现报告展示，引入ddt实现数据驱动，然后美其名曰，我写了个框架，我每次听到都是先很崇拜，然后晚上暗搓搓拉下代码一看，MD，这不是就是搭了个积木取名要你命3000吗？你还不能说人家说自己写了一个框架不对，何况这个框架通常也很好用。用pytest就不更用说了，连并发都有两个库，一个xdist，一个pytest-parallel，每次都患选择恐惧症。 再有，开源的框架，毕竟普适多于贴合，跟自己的业务有时候就不那么紧密，为了使用某个具体功能还得引入很大一个包，也不是非常方便，另外最关键的一点是，我总觉得自己还行，想站起来试试 ：） 框架是什么？我是怎么考虑框架的？之前分享过几篇文章，测试框架之我见web自动化框架实践指南Python接口测试框架实践pytest框架从入门到精通《测试框架之我见》， 《web自动化框架实践指南》， 《接口测试框架实践》， 《pytest框架从入门到精通》。 这些都是我工作的一些感悟，和对框架的一些思考，可以看到思想也是循序渐进的。你也可以看到不是“官方”框架，就是二次开发的“官方”框架。 当然也可以说我是常怀觊觎之心，不停研究的目的就是我个人非常想有一套完全自己实现的框架。 什么是ktest？一句话： ktest is a common test framework support for Both UI and API test with run in parallel ability。跟其它的框架有什么不同？除标准库之外，原则上不引入任何第3方库，所有的一切都自己实现。比如并发就老老实实自己设计规则多线程并发，不用xdist或者pytst-parallel了，比如错误重跑，HTML报告都是自己实现了。 参考了谁？我当然不是闭门造车，参考了unittest，pytest，ddt，还有自己公司的官方框架， 读了部分源码，研究了下部分功能实现原理。 实现的功能：1.多线程并发。（整套框架代码没出现任何哪怕一句threading，实现了并发，神奇不，嘿嘿）2.分布式并发。（借助selenium-grid）3.数据驱动。（一条用例两条数据会被当成两个用例，并展示在最终报告里）4.同个测试类数据共享，每个测试用例数据独立。setUpClass， tearDownClass， setUp， tearDown（一看就是unittest的概念，只不过我自己实现了）。4.动态生成，挑选，运行测试用例。（大量借助装饰器）5.Web UI自动化测试每条用例错误自动截屏，记录log信息，自动重跑机制。6.HTML报告。7.XML格式for Jenkins。（马上完成，姑且算完成吧）现在还是第一版，我个人想把它写成一个通用的测试框架，即可服务于web UI自动化测试，又可服务于API测试。当然还有很长的路要走。 详细介绍先不介绍技术细节， 先把自己放在一个业务测试，或者刚接触自动化脚本的测试角色上，我拿到了一个测试框架，我最先想到的是什么？ 如何用对吧？ 用这个框架，我原有的测试用例需要做哪些改变？这个框架有哪些方便？你对框架的期待有哪些？1.使用简单，介绍详细。2.能让我方便的查找， 生成， 运行， 清理测试用例及测试数据。3.对业务的侵袭小，我迁移成本低。4.功能强大，报告美观。5.稳定，bug少。 下面就详细介绍： 安装：123#目前部署在自己公司的pypi库上，后期会上传到pypi。pip install ktest --index-url http://jenkin.xxxx.com:8081/pypi --trusted-host jenkins.xxxx.com#安装好后，你可以在 Python安装目录下的如下文件找到安装的包\Lib\site-packages 你的项目应该包括哪些：在讲用法前，我们先来直观看下，你的项目目应该是什么样子的你的项目中应该包含：1.pages package， 这里面放你所有待测试页面，每个页面作为一个page object来保存。2.tests package， 这个文件夹下面放所有的测试用例，包括你的数据驱动，断言都在这里。3.settings package， 这个里面放了一些框架里会用到的参数，当然也可以放你自己的配置。 如果你不知道框架用到哪些变量，你可以暂时不建立它，运行时框架会帮你自动生成。 可以看到，你只需要把精力放在你本身的业务上就好了。 ktest框架组成package建立好了，我的测试用例，及我的待测页面要如何组织才能接入框架呢？ 别急，我们先来看看框架本身长什么样子。 功能列表看用红框标记起来的部分：Common – 框架精华1.欢迎关注公众号iTesting，跟万人测试团一起成长。2.abstract_base_page.py 这个文件有是为了你自己项目的pages准备的，你的每一个待测页面或者功能都应该继承自这个文件中的类，并重写一些特定的函数。3.api_base_case.py 创建了为api测试而用的基类。4.enumeration.py 一些枚举变量，比如测试类的setup 和tearDown等，主要为了防止代码里写错及方便修改。5.get_platform_info.py 判断运行的系统环境是windows，还是linux， 框架开始前会清理执行环境。6.get_project_info.py 用于拿到你的项目文件的根目录。7.html_reporter.py 用于生成HTML报告。8.klogger.py 用于全局logger或者每个case独立logger。9.selenium_helper.py 基于selenium封装的一些toolkit， 比如打开浏览器，使用chrome headless模式，关闭浏览器等。方便你快速开展工作。10.test_case_finder.py 用于测试用例的查找和组织。 根据你的用户输入来进行，默认从tests 这个package下找所有被标记为@TestClass， @Test并且enable的用例。11.test_decorator.py 用于标记测试类，测试用例，并且赋予每个测试类和测试用例独特的属性，方便test_case_finder查找。12.test_filter.py 所有测试用例查找到后，根据用户的输入进行filter，最终保留出当次运行需要的测试类，测试函数及测试数据的组合。13.ui_base_page.py UI的公用页，所有的UI Case 都继承自此。14.user_options.py 接受用户参数并分析，最终为框架所用，包括要哪些用例运行，这些用例比如属于哪个组，那个测试类， 多线程还是单线程。 都在这里设置。 utiilites – 拿来即用测试套件这里面放一些半成品，比如连接数据库脚本，比如用excel做数据驱动，对excel进行读写的脚本。 用户不需要操心连接的建立，销毁等。 main.py 用来运行框架，并发运行控制也是在这里。并发我“舍弃”了threading.Thread， 代码量下降一半以上，且不用操心锁。 setup.py 用来把框架打包。 集成你的项目框架也看了，我的项目也建了， 我们的测试类和测试方法应该怎么写？还拿我一直用的baidu来举例，你的项目pages package下1234567891011121314151617181920212223242526272829303132333435363738#bai_du.py#coding=utf-8__author__ = 'iTesting'import timefrom common.abstract_base_page import AbstractBasePagefrom page_objects import page_elementclass BAI_DU(AbstractBasePage): BAI_DU_HOME = "http://www.baidu.com" SEARCH_DIALOG_ID = "kw" SEARCH_ICON_ID = "su" MEMBER_COUNT_XPATH = "//option[@value='10']" SAVE_XPATH = ".//*[@id='save']" search_input_dialog = page_element(id_=SEARCH_DIALOG_ID) search_icon = page_element(id_=SEARCH_ICON_ID) member_count = page_element(xpath=MEMBER_COUNT_XPATH) save_button = page_element(xpath=SAVE_XPATH) def __init__(self, browser): self.browser = browser AbstractBasePage.__init__(self, browser) def is_target_page(self): self.browser.get(self.BAI_DU_HOME) print(self.is_element_displayed_on_page(self.search_icon)) return self.is_element_displayed_on_page(self.search_icon) def search(self, search_string): self.search_input_dialog.send_keys(search_string) self.search_icon.click() time.sleep(5) def preferences(self): browser = self.browser browser.get(self.BAI_DU_HOME + "/gaoji/preferences.html") self.member_count.click() time.sleep(1) self.save_button.click() time.sleep(1) browser.switch_to_alert().accept()每一个你的测试类（待测页面）你需要：1.测试类继承AbstractBasePage， 然后page_object模式就可以使用了。2.测试类要实现is_target_page函数，返回值是True或者False， 运行中如果返回值False，会Raise Error并停止本测试类后续运行。3.如果你不用page objectmm模式，你无需遵守上述规定。 你的tests package下测试用例定义1234567891011121314151617181920212223242526272829303132333435363738# test_baidu.py#coding=utf-8from common.selenium_helper import SeleniumHelperfrom common.test_case_finder import data_providerfrom common.test_decorator import TestClass, SetUpClass, Test, TearDownClassfrom pages.baidu import BAI_DU@TestClass(group='smoke', enabled=True)class TestBaidu: test_case_id = '3' @SetUpClass() def before(self): pass def setUp(self): self.browser = SeleniumHelper.open_browser('firefox') self.baidu = BAI_DU(self.browser) @data_provider([('baidu',), ('google',)]) @Test() def test_baidu_search(self, x): self.tag= 'tt' """Test search""" self.baidu.search(x) assert 1== 1 @Test() def test_baidu_set(self): """Test set preference""" print('NONONO') self.baidu.preferences() assert 1==0 def tearDown(self): self.browser.delete_all_cookies() self.browser.close() @TearDownClass() def after(self): pass 注意事项我来仔细解释下：1.test_case_id： 是测试报告里要显示的test_case_id, 一般跟你testcenter里的test_id相同，如果你一个测试类共用一个id， 你定义为类属性就可以。 如果你每个测试用例不同id，你在每个测试函数里，重写它就可以。 框架会为你替换。2.tags: 是每个用例的tag，定义在类属性里，test_finder查找时会解析这个tags，可以是str或者list或者tuple，或者是3者的嵌套。 框架最终会解析成一个list。比如你定义 tags=[‘smoke’,’bvt’] 和你定义 ‘smoke, bvt’是一样的效果。 当用户指定了要跑的tag属性时候，test_finder会根据它的值来做filter。3.@SetUpClass()， @TearDownClass() 测试类装饰器，无输入参数。 每个测试类，不管它有多少个测试用例，这两个装饰器装饰的函数只会被执行一次。 一般用作测试类公用的数据的初始化，比如说，连接db查找某些值。 请注意， 并发运行，不要在这个函数里初始化你的browser，会有共享问题。4.@TestClass（）， 测试类的装饰类， 函数接受两个个参数一个是group，就是测试类所属的group，一个是enabled，默认值True。 值为False时， test_finder会把这个测试类略过。5.@Test（）， 测试装饰类， 函数接受一个参数enabled，默认值True。 值为False时， test_finder会把这个测试函数略过。6.@data_provider（）， 数据驱动装饰器。 接受一个参数，且此参数必须要iterable. 因为是数据驱动，不太可能只有一个数据，所以这个iterable，我通常我会定义成一个tuple，如果 有多个就是多个tuple， 例如[(1,2,3),(4,5,6)]这种，（1，2，3）会被解析成一条测试数据， （4，5，6）会被解析成另外一条。 这个概念来自ddt，我之前也介绍过相关框架。7.@setUP（）， @tearDown().两个函数，每个测试类必须定义，否则运行时框架会报错。 用作每个测试类的测试函数即每一条测试用例的运行前初始化和运行后的清理。定义一次， 由它装饰的函数会在每个测试用例运行前后调用。 一般在里面初始化web browser和 API的 session。 测试函数，就是以@Test（）装饰的函数，一般是你的业务代码，你需要自己实现业务流程的操作和断言。如果用到setUpClass或者setUp里的方法属性，你只需要在这些属性前加self.它不像pytest或者unittest，此函数名不必以test开头或结尾。 以上基本参照了pytest和unittest的用法，主要初衷也是为了减少迁移成本。 好，我测试类，测试函数都写好了，如何跑呢？ 可用参数123456789#最简单在命令行里输入ktest 即可， 框架会自动查询所有你项目文件下tests文件夹的测试用例。#ktest还支持如下参数：usage: ktest [-h] [-t test targets, should be either folder or .py file, this should be the root folder of your test cases or .py file of your test classes.] [-i user provided tags, string only, separate by comma without an spacing among all tags. if any user provided tags are defined in test class, the test class will be considered to run. | -ai user provided tags, string only, separate by comma without an spacing among all tags. only all of user provided tags are defined in test class, the test class will be considered to run.] [-e user provided tags, string only, separate by comma without an spacing among all tags,if any user provided tags are defined in test class, the test class will be Excluded. | -ae user provided tags, string only, separate by comma without an spacing among all tags. all the provided tags must defined in test class as well.] [-I include groups, string only, separated by comma for each tag. if any user provided groups are defined in decorator on top of test class, the test class will be considered to run. | -AI exclude groups, string only, separated by comma for each tag. all user provided groups are defined in decorator on top of test class, the test class which match will be excluded to run.] [-E exclude groups, defined in decorator on top of test class, string only, separated by comma for each tag. If any user provided groups are defined in decorator on top of test class, the test class will be Excluded to run | -AE exclude groups, defined in decorator on top of test class, string only, separated by comma for each tag. All user provided groups must defined in decorator on top of test class. the test class which matched will be Excluded to run] [-n int number] [-r dir] 其中：-t 是你要运行的测试目标的根目录，默认是项目下的tests文件夹。-i 是测试类里定义的tags。 tags会被解析成list，用户指定的任何tag只要包含在这个lists里，并且这个测试函数所属的TestClass（）是enabled和这个测试函数的enabled是True，就表示这个测试类的这个测试函数会被test_filder找到。-I 是装饰测试类的@TestClass（）定义的group，包含两个参数， 符合用户指定的group并enabled， 那么它装饰的类会被当作一个测试类被test_finder找到。-e 是测试类里定义的tags。 tags会被解析成list。 用户指定的任何tags包含在list里，这个测试函数就会被test_finder忽略。-E 是测试类里定义的tags。 tags会被解析成list。 用户指定的任何tags包含在list里，这个测试函数就会被test_finder忽略。-n 并发执行的个数，默认是cpu_count。-r 错误重跑， 默认是True。重跑再错误，所有跟case相关的log和screenshot会被记录。 Note：1.这种默认下，测试用例（测试类）的tags解析出来的的任意子集，如果用户指定的group或者tag是包含它，那么他会被test_finder找到。 比如-test就跑包括了test这个tag的用例。 比如你有两个测试类，一个测试类的tag是test，另外一个测试类的tags是regression， 用户给了-i test,regression. 那么这两个测试类所属的测试用例都会被扫描到并且添加进待测list里。2.所有的用户输入只支持str。 tag本身不必要加引号，除非它在测试类里也加了引号。 且多个tag直接用逗号隔开即可，不必加空格。有的同学会问了，我希望跑同时包括test和regression在内这两个tags的用例呢？ 谁提出的这个需求？我真想指着你的鼻子说：没有问题，统统实现！1234567891011121314151617181920212223242526272829303132# 定义了tag和group的更加严格版。只有用户输入的参数全部包含在测试用例定义的tags里，这个测试用例才会被test_finder扫描到。 -ai user provided tags, string only, separate by comma without an spacing among all tags. only all of user provided tags are defined in test class, the test class will be considered to run. Select test cases to run by tags, separated by comma, no blank space among tag values. all user provided tags must defined in test class as well. tags are defined in test class with name &lt;tags&gt;. eg: tags = ['smoke', 'regression']. tags value in test class can be string, tuple or list. -ae user provided tags, string only, separate by comma without an spacing among all tags. all the provided tags must defined in test class as well. Exclude test cases by tags, separated by comma, no blank space among tag values. all of the tags user provided must in test class as well. tags are defined in test class with name &lt;tags&gt;. eg: tags = ['smoke', 'regression']. tags value in test class can be string, tuple or list. -AI exclude groups, string only, separated by comma for each tag. all user provided groups are defined in decorator on top of test class, the test class which match will be excluded to run. Select test cases belong to groups, separated by comma, no blank space among group values. All user provided group must defined in decorator on top of test class, the test class which match will be collected. groups are defined in decorator on top of test class. eg: group= 'UI'. -AE exclude groups, defined in decorator on top of test class, string only, separated by comma for each tag. All user provided groups must defined in decorator on top of test class. the test class which matched will be Excluded to run Exclude test cases belong to groups, separated by comma, no blank space among group values. All of groups user provided must defined in decorator on top of test class as well. groups are defined in decorator on top of test class. eg: group= 'UI'.#事实上， 为避免用法繁琐及方便用户， -i 和-ai， -e和-ae, -I和-AI, -E和-AE 是两两互斥的， 你只能指定其中的一个。 测试报告下面我们看下一个运行实例1ktest -I group -n 10 -r True执行中console的输出： 执行成功后报告的展示：report会自动生成在你项目根目录下，以运行时时间戳为文件夹，每个测试用例一个子文件夹 测试报告加入了run pass， run fail， run error的图表。 run fail代表真正的fail， run error代表代码有问题或者环境问题导致的错误。同样报告直接按照测试类filter。 后记：到此为止，ktest基本成型，也能根据需求完成web UI自动化和API自动化的工作了，不同无非是你在setUP初始化你的driver时候初始化的是你的browser还是request.session. 如果你想实现分布式并发，也可以在setUP initial selenium Grid， 前提是配置好selenium-server。 还是有一些感悟：1.框架真不是一蹴而就的，是逐渐演化的。 最后成型的这一版跟我初始的规划还是有很大差距，有些代码甚至是不得已的妥协，比如我要出html报告，就要很多测试函数无关的数据收集，那么这些数据势必会侵入我的代码，结果就是我返回的测试函数数据结构很不简洁。2.我最得意的是没有用大家都推崇的多线程threading.Thread，整个框架没有一行threading.Threadd 代码而实现了多线程并发，可阅读性增加了，而且我的代码量也因此少了三分之一， 虽然踩了不少坑，但也证明条条大路通罗马，只要理论通了，怎么实现，完全看个人喜欢。实际上threading.Thread实现太过繁琐，我几乎是一开始就否定了它。3.你完全不需要搭积木， 一砖一瓦也能创建出漂亮的房子。 彩蛋：放部分代码段：关于更多技术实现细节，我会重新写一篇文章介绍。]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>测试框架</tag>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[web开发] Flask+Python开发个人博客（六）]]></title>
    <url>%2F2018%2F12%2F24%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask%2BPython%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Flask开发中的一些技巧。 旧文五篇：[web开发] Flask+Python开发个人博客（一）[web开发] Flask+Python开发个人博客（二）[web开发] Flask+Python开发个人博客（三）[web开发] Flask+Python开发个人博客（四）[web开发] Flask+Python开发个人博客（五） 在Flask开发中，我们常常会用到很多配置变量，这些变量一开始是我们的本地环境变量，等你开发好后，会替换成线上产品变量，这样就导致你经常需要把一个变量的值改来改去。其实Flask提供了一个很好的方式来解决这个问题， 那就是instance。正常情况下，我们的变量都存在config.py的文件里，当使用的时候，在__init__.py里，加入：1234567from flask import Flaskapp = Flask(__name__)app.config.from_object('config')#后面的代码中，如果需要用到某个变量，只需要：app.config["variable"] 就可以访问了 那么当你需要隔离某些变量时怎么办， 只需要在项目根目录下建立一个instance文件夹，然后里面建config文件，目录大概如下： 使用方式是在__init__.py里，加入：12345from flask import Flaskapp = Flask(__name__, instance_relative_config=True)app.config.from_pyfile('config.py')#这样，如果你instance文件里定义了某个变量，系统就会从instance文件夹下面的config文件里寻找。 同时你可以把instance这个文件加入到git的ignore名单，这样就无需再频繁改动config文件了。]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
        <tag>python</tag>
        <tag>开发个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[web开发] Flask+Python开发个人博客（五）]]></title>
    <url>%2F2018%2F12%2F14%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask%2BPython%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开发任意一个博客或者网页，如果不是静态的，你就绕不过一个问题，数据怎么存储？ 今天是 [web开发] Flask+Python开发个人博客 第五篇，旧文四篇：[web开发] Flask+Python开发个人博客（四）[web开发] Flask+Python开发个人博客（三）[Web开发] Flask+Python 开发个人博客（二）[web开发] Flask+Python开发个人博客（一） 开发任意一个博客或者网页，如果不是静态的，你就绕不过一个问题，数据怎么存储？ 这个摊开来讲就是一个硕大的工程，今天仅就我的博客为例， 来讲下数据库设计。 我选择SQL Server2008 来存储我的数据， 我们看看都有什么内容要存？1.有登录和注册模块，那必然要存用户的相关信息 — Members2.要实现用户发帖和修改，那必须要有权限管理。 — Role， Privilege，RolePrivilege3.要发布文章，文章必须要管理起来 –Categories， Posts。 再来看下这些表之间的关系： 用户应该分组，所以Members表和Role表就有对应关系，具体表现为Members表每一个user有对应的RoleID。 分组不同，权限应该不同，RolePrivilege展示这个不同。 即使不是管理员用户，他自己发布的文章应该可以修改，删除，即每个用户对自己的文章有绝对权限，那么，文章Posts表应该有用户的Memerid。 每个文章应该都有一个类别，Posts表格和Categories应该有关联，同时Posts表应该表现这个不同。 根据上述要求，数据库表关应该如下： 最后，附上数据库设计的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556use kevin_forumgocreate table Role(RoleId int not null IDENTITY(1,1) primary key,RoleName varchar(50) not null, Description varchar(100) )create table Privilege(PrivilegeId int not null IDENTITY(1,1) primary key, PrivilegeName varchar(50) not null, Description varchar(100))create table RolePrivilege(RolePrivilegeId int not null primary key,RoleId int not null foreign key references Role(RoleId),PrivilegeId int foreign key references Privilege(PrivilegeId))create table Members(MemberId int not null IDENTITY(1,1) primary key, UserName varchar(50) unique NOT NULL, PassWord varchar(50) not null, RoleId int not null default(2) foreign key references Role(RoleId),PhoneNumber varchar(50) unique NOT NULL)CREATE TABLE [dbo].[Categories]( [CId] [int] IDENTITY(1,1) NOT NULL primary key, [CName] [varchar](100) NOT NULL,)CREATE TABLE [dbo].[Posts]( [PId] [int] IDENTITY(1,1) NOT NULL PRIMARY KEY, [Title] [varchar](100) NULL, [Contents] [varchar](max) NULL, [MemberId] [int] NOT NULL foreign key references Members(MemberId), [CId] [int] NOT NULL, [Comments] [varchar](max) NULL, [InsertTime] [datetime] DEFAULT(getdate()), [ModifyTime] [datetime] DEFAULT(getdate()), [ModifyByMemberId] [int] NOT NULL)alter table [dbo].[Posts]add constraint posts_members_conn foreign key(MemberId) references [dbo].[Members](MemberId) alter table [dbo].[Posts]add foreign key(CId) references [dbo].[Categories](CId) 如果要了解数据库设计的原则，请自行搜索。]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
        <tag>python</tag>
        <tag>开发个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[web开发] Flask+Python开发个人博客（四）]]></title>
    <url>%2F2018%2F12%2F13%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask%2BPython%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Ckeditor， 最好的富文本编辑器之一。 这是[web开发] Flask+Python开发个人博客 系列 第四篇， 在线编辑器的使用。旧文三篇：[web开发] Flask+Python开发个人博客（三）[Web开发] Flask+Python 开发个人博客（二）[web开发] Flask+Python开发个人博客（一） 既然是博客，就免不了发布文章，而一个便利的，所见即所得的在线编辑器就显得至关重要，flask + WTF Forms 提供的textarea 功能太少，而且样式难以定制， 这个时候优秀的第3方控件就变成了我们的第一选择。经过比较，我选用了Ckeditor，今天我们来讲下如何把它嵌入到我们的项目里去。先看下嵌入到页面中的样子： 应用： 从ckeditor.com下载文件，放到flask目录下的static文件夹内。 在要引用的HTML head里引入如下代码：···python&lt;script src=&quot;{{ url_for('static', filename='ckeditor/ckeditor.js') }}&quot;&gt;&lt;/script&gt; ··· HTML页面嵌入ckeditor代码：12345678&lt;textarea name=&quot;editor1&quot; id=&quot;editor1&quot; rows=&quot;10&quot; cols=&quot;80&quot;&gt; This is my textarea to be replaced with CKEditor. &lt;/textarea&gt; &lt;script&gt; // Replace the &lt;textarea id=&quot;editor1&quot;&gt; with a CKEditor // instance, using default configuration. CKEDITOR.replace( &apos;editor1&apos; ); &lt;/script&gt; 就这么简单，那么CKeditor如何跟flask结合起来呢？我写了一个sample project： 项目目录如下： static文件夹就是我们下载下来的ckeditor源文件。 templates下面是我们的HTML页面， 代码如下： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;A Simple Page with CKEditor&lt;/title&gt; &lt;!-- 请确保CKEditor文件路径正确 --&gt; &lt;script src="&#123;&#123; url_for('static', filename='ckeditor/ckeditor.js') &#125;&#125;"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form method = 'post' action=''&gt; &#123;&#123; form.csrf_token &#125;&#125; title: &#123;&#123; form.title &#125;&#125; category: &#123;&#123; form.category &#125;&#125; &lt;textarea name="editor1" id="editor1" rows="10" cols="80"&gt; &#123;&#123; content &#125;&#125; &lt;/textarea&gt; &lt;script&gt; // 用CKEditor替换&lt;textarea id="editor1"&gt; // 使用默认配置 CKEDITOR.replace('editor1'); &lt;/script&gt; &#123;&#123; content &#125;&#125; publish: &#123;&#123; form.publish &#125;&#125; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 4.run.py 是整个工程源码:1234567891011121314151617181920212223242526272829303132#coding=utf-8from flask import Flaskfrom flask import render_templatefrom flask import requestfrom flask_wtf import FlaskForm, validatorsfrom wtforms import StringField, SubmitFieldclass PostEditor(FlaskForm): title = StringField('标题', [validators.DataRequired("Please enter your title")]) category = StringField('类别', [validators.DataRequired("Please enter your category")]) content = StringField('内容', [validators.DataRequired("Please enter your content")]) publish = SubmitField('发布')app = Flask(__name__)app.secret_key = 'iTesting'@app.route('/', methods=['GET', 'POST'])def index(): form = PostEditor() if request.method == "POST" or form.validate_on_submit(): content = request.form.get('editor1') return render_template('ckeditor.html', content=content, form=form) return render_template('ckeditor.html', form=form)if __name__ == "__main__": app.run(debug=True) 演示效果如下：初始效果：提交以后效果： 可以看到， 当点击提交时候，我们在CKeditor里的内容被记下来发给flask后端了，所以我们才能再次看见我们输入的内容。 以上就是CKEditor结合flask的简单使用， 但是缺点是只能接受文本内容，我们写博客肯定希望图文并茂，那么就需要配置ckeditor下的config.js了： 在config.js文件合适位置添加： 1config.filebrowserUploadUrl = '/ckupload/'; 在run.py 合适位置添加后台处理上传请求代码： 12345678910111213141516171819202122232425262728293031323334353637383940def gen_rnd_filename(): filename_prefix = datetime.datetime.now().strftime('%Y%m%d%H%M%S') return '%s%s' % (filename_prefix, str(random.randrange(1000, 10000)))@app.route('/ckupload/', methods=['POST'])def ckupload(): """CKEditor file upload""" error = '' url = '' callback = request.args.get("CKEditorFuncNum") if request.method == 'POST' and 'upload' in request.files: fileobj = request.files['upload'] fname, fext = os.path.splitext(fileobj.filename) rnd_name = '%s%s' % (gen_rnd_filename(), fext) filepath = os.path.join(app.static_folder, 'upload', rnd_name) # 检查路径是否存在，不存在则创建 dirname = os.path.dirname(filepath) if not os.path.exists(dirname): try: os.makedirs(dirname) except: error = 'ERROR_CREATE_DIR' elif not os.access(dirname, os.W_OK): error = 'ERROR_DIR_NOT_WRITEABLE' if not error: fileobj.save(filepath) url = url_for('static', filename='%s/%s' % ('upload', rnd_name)) else: error = 'post error' res = """&lt;script type="text/javascript"&gt; window.parent.CKEDITOR.tools.callFunction(%s, '%s', '%s');&lt;/script&gt;""" % (callback, url, error) response = make_response(res) response.headers["Content-Type"] = "text/html" return response 这段代码获取上传的文件，并把它保存在项目static根目录下的ckupload文件夹内。我们看下一个上传成功的例子：通过运行python run.py,访问http://localhost:5000, 填写相应内容提交：至此，项目结构变为： 这样ckeditor和flask的集成就做好了，后续需要我们设计数据库表格来保存我们写的博客文章内容，这个放到下次讲。 如果你对ckeditor的配置有疑问，请留言给我或者直接访问官网]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
        <tag>python</tag>
        <tag>开发个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[web开发] Flask+Python开发个人博客（三）]]></title>
    <url>%2F2018%2F12%2F10%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask%2BPython%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Blue print 蓝图应用指南 今天我们来讲讲flask里的blue print – 蓝图。旧文两篇：[web开发] Flask+Python开发个人博客（一）[Web开发] Flask+Python 开发个人博客（二） 在前两篇的时候，大家还记得不同类型的账户，访问到的同一个页面元素有不同吗？这个是怎么做到呢？这就是蓝图的妙用了。什么是蓝图，我们为什么要用蓝图？我们来看下exploreflask上的解释： What is a blueprint?一个蓝图定义了可用于单个应用的视图，模板，静态文件等等的集合。举个例子，想象一下我们有一个用于管理面板的蓝图。这个蓝图将定义像/admin/login和/admin/dashboard这样的路由的视图。它可能还包括所需的模板和静态文件。你可以把这个蓝图当做你的应用的管理面板，管它是宇航员的交友网站，还是火箭推销员的CRM系统。 Why would you use blueprints?蓝图的杀手锏是将你的应用组织成不同的组件。假如我们有一个微博客，我们可能需要有一个蓝图用于网站页面，比如index.html和about.html。然后我们还需要一个用于在登录面板中展示最新消息的蓝图，以及另外一个用于管理员面板的蓝图。站点中每一个独立的区域也可以在代码上隔绝开来。最终你将能够把你的应用依据许多能完成单一任务的小应用组织起来。 Where do you put them? 以我的blog为例，对于同一篇文章，我希望不同权限的人看到的内容不同，但是我又想最大程度的重用一个模板，我的目录应该如下面的类似组织： How to use： 前提条件，forms需要定义好， forum_app/forms.py 12345678from flask_wtf import FlaskFormfrom wtforms import StringField, SubmitField, validators,from wtforms.validators import Regexpclass PostEditor(FlaskForm): title = StringField('标题', [validators.DataRequired("Please enter your title")]) category = StringField('类别') publish = SubmitField('发布') 在views里定义好路由 以admin_views为例： views.py12345678910111213141516171819202122232425262728293031#coding=utf-8import timefrom flask import render_template,request, Blueprint, redirect, url_forfrom forum_app.db_helper.db_helper import update_postfrom forum_app.forms import PostEditorblue_admin = Blueprint('blue_admin', __name__, template_folder='admin_forums')@blue_admin.route('/detail_posts', methods =['GET', 'POST'])def posts_detail(): form = PostEditor() pid = request.args.get("id") post_title = request.args.get("title") post_category = request.args.get("category") post_author = request.args.get("author") post_contents = request.args.get("contents") post_create_time = request.args.get("create_time") blue_print_name = "blue_admin" form.category.data = request.args.get("category") form.title.data = request.args.get("title") if request.method == "POST" and form.validate_on_submit(): if request.form.get('publish') == '发布': update_post(request.form.get('title'), request.form.get('category'), request.form.get('editor1'), id=pid) return redirect(url_for('forum')) return render_template('admin_forums/posts.html', post_title=post_title,\ post_category=post_category, \ post_author=post_author, post_contents=post_contents, \ blue_print_name=blue_print_name, post_create_time=post_create_time, pid=pid, form=form) 创建一个蓝图的语法如下：1blue_admin = Blueprint('blue_admin', __name__, template_folder='admin_forums') To create a blueprint object, we import the Blueprint() class and initialize it with the arguments name and import_name. Usually import_name will just be name, which is a special Python variable containing the name of the current module.The last parameter tell flask that the blueprint has its own template and static direcories. 定义好蓝图后，要把它注册到我们的程序上：run.py 1234567from flask import Flaskfrom forum_app.views.admin_views.views import blue_adminapp = Flask(__name__)app.register_blueprint(blue_admin, url_prefix='/admin')app.run(debug=True) 最后一步，构造URL，绑定路由和HTML template。你只需要在 URL 的末端加上蓝图的名称和一个点（ . ）作为前缀即可完成绑定:url_for(‘blue_admin.post_detail’)templates/forum.html 部分代码 本例中我为了方便，user的post_detail路由和admin的post_detail路由所指向的html template我分开了：两个posts.html，在应用中你也可以用一个template，中间用if语句引导不同的路由渲染不同的templates。 到此就完成了所有blue print的应用，blueprint 给我们提供了一种类插件功能，我们可以利用它完成很多功能，比如admin用户的control panel功能，这样方便了我们定制功能。 更多内容，查看官方文文档： http://docs.jinkan.org/docs/flask/blueprints.html]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
        <tag>python</tag>
        <tag>开发个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Web开发] Flask+Python 开发个人博客（二）]]></title>
    <url>%2F2018%2F12%2F05%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%5BWeb%E5%BC%80%E5%8F%91%5D%20Flask%2BPython%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Flask打造个人博客系列,今天是第一篇，我们详细讲解登录，注册模块。 旧文一篇：[web开发] Flask+Python开发个人博客（一） 既然是Flask来开发，你得: 安装 1pip install Flask 实现最简单的一个hello word：views.py 123@app.route("/")def hello(): return "Hello World!" run.py 123456from flask import Flaskapp = Flask(__name__)if __name__ == "__main__": app.run(debug=True) 在terminal里输入python run.py, 现在在浏览器打开http://127.0.0.1:5000, 看看发生了什么？：） 很简单吧？貌似第2部分点陌生：@app.route是什么鬼？它正是用于在Flask应用中给视图函数设定路由URL的装饰器。一头雾水？装饰器是什么？ WTF？Python装饰器让我们可以用其他函数包装特定函数。 当一个函数被一个装饰器”装饰”时，那个装饰器会被调用，接着会做额外的工作，修改变量，调用原来的那个函数. 视图， 路由又是啥玩意，简单解释下： 上面的@app.route就等价于图中的Routes部分。@app.route（’/‘）就是注册了一个路由（注册路由就是建立URL规则和处理函数之间的关联。Flask框架依赖于路由 完成HTTP请求的分发）。这样当你访问“/”这个path的时候，python就自动把要它联系到hello（）这个function上，controller处理完后就会返还给你。 现在我们知道了，视图函数hello既然可以返回hello word， 那么我们也可以定义其他视图函数来返回注册和登录页面。代码示意如下：views.py views.py这段代码作用就是你在url里输入 “127.0.0.1:5000/login后，flask会找到login对应的函数，处理后返回login.html中的内容。那么， login.html 里有哪些内容呢？templates/login.htmlHTML我们都会写一点, 但是{}是什么符号起什么作用呢？因为Python直接写html太麻烦，于是Flask 内置了 Jinja2 模板引擎，帮你更方便的写html。你可以在这个模板里使用变量或者表达式，当这个页面显示的时候，变量或者表达式的值就会填充到你HTML页面相应的部分，这个变量或者表达式的值是从哪里取来的呢？当然是从你flask程序里.一般Flask 会在 templates 文件夹里寻找模板。所以，你只需要用HTML写两个页面login.html 和signup.html，然后放到根目录下的templates文件夹下就可以了。flask会自己找到这两个页面并渲染。 下面简述下如何使用inja2模板来写html页面.1.安装： 1pip install Jinja2 2.使用：如上的HTML。 介绍两个常用的变量标志符： {% ... %} for Statements，例如上文的for循环语句。 {{ ... }} for Expressions to print to the template output， 例如上文的 {{ form.username }}，{{ form.password }}. 我们知道登录的时候，需要输入用户名和密码，点击登录按钮，这个通常放到表单里来做，那么点击登录会发生什么呢？ 表单里用户名和密码的内容会提交到程序后端处理，对于Flask来说，它使用Flask-WTF来自动化表单的操作， 我们来看看如何处理表单： 1. 安装 1pip install Flask-WTF forms.py表单定义好后，需要配合视图使用， 也就是我们在views.py的文件头里，加上：1from forum_app.forms import LoginForm 这样你在浏览器里输入 http://127.0.0.1:5000/login，就会转到login页面，输入用户名密码，提交，就会走login这个视图函数的逻辑了。现在再回去看下views.py，你会发现 1get_member_id_by_username（username） 这个是什么呢？就是后端的代码逻辑了，此处为了从数据库里根据用户名找到用户id。这个需要用到SQLAlchemy这个库，我之前写过相关的文章，点击这里查看SQLAlchemy用法。 通过这种方法Jinja2 用来写前端页面templates， Views用来处理url绑定和视图，wtf-forms用来简化表单操作，Flask就这样实现了一个简单的注册登录。]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
        <tag>python</tag>
        <tag>开发个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[web开发] Flask+Python开发个人博客（一）]]></title>
    <url>%2F2018%2F12%2F05%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%5BWeb%E5%BC%80%E5%8F%91%5D%20Flask%2BPython%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[纯flask实现的一个blog。 网站的整体效果：登录页面（也是首页）： 注册页面: 这两个页面都实现了基本的验证，比如：用户名密码为空 密码不正确： 正确登录后会跳转到系统主页面，长下面的样子： 页面模块： Header Footer 文章模块点击主页上的模块，或者在任何文章的类别上点击，会进入下面的两个页面：一个是列在Header上的类别，类别选中会高亮。： 一个是未列在Header上的类别，无高亮： 文章分类tag 分页模块 参考了Flask上的分页，加上用了Bootstrap的样式 新建/修改/删除 文章模块。 用了CK Editor，最好的编辑器之一。 新建： 修改： 删除： 文章详页模块 一个是对文章只有浏览权限，没有修改和删除按钮： 一个是文章的作者或者Admin用户组的用户，对文章有full control权限 权限控制模块（包括用户，权限，登录验证，管理员验证等） 项目配置（使用instance）]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
        <tag>python</tag>
        <tag>开发个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试框架实践--实现TestFixture]]></title>
    <url>%2F2018%2F11%2F24%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%AE%9E%E7%8E%B0TestFixture%2F</url>
    <content type="text"><![CDATA[前面几期分享我实现了一个可以并发运行的”框架“， 其实只能叫半成品， 但好歹可以并发运行， 测试用例动态挑选了。那么还少了什么呢？一个测试类，通常有多个测试方法，有时候一个或多个测试方法都需要某些共用的”数据“， 比如说都要访问某个数据库的某张表，比如说都需要起浏览器，都需要调用post方法等。 这个时候每个测试用例单独写就显得很多余，TestFixture就应运而生。我们先来看下Test Fixture的定义： A test fixture represents the preparation needed to perform one or more tests, and any associate cleanup actions. This may involve, for example, creating temporary or proxy databases, directories, or starting a server process. 由此可见，Test Fixture用在测试方法前，或者测试方法后，主要功能是提供一些测试需要用的装置，这些装置可以是数据，可以是环境配置也可以是一个运行前状态。Fixture有下面两种： setup(), teardown（）的方式，分别在每个测试方法执行前后执行。setUpClass（）， tearDownClass（）的方式，分别在每个测试类执行前后执行, setUpClass（）和tearDownClass（）只会执行一次，即使这个测试类有多个测试函数。我们在实现这个之前，先看下上次我们实现并发时，真正执行一个测试函数的代码块， 它的代码：12345678910111213def f(case): name, func, value = case try: if value: func.__call__(name, *value) else: func.__call__(name) except: # traceback.print_exc() cases_run_fail.append(name) else: cases_run_success.append(name) return cases_run_fail, cases_run_success这个代码块是针对每一个测试函数的，那么我们多线程运行时，每个测试函数都会执行这段代码，这样就好办了，直接把setup和teardown加进来就能实现每个测试函数都执行setup和teardown方法了。123456789101112131415161718192021def f(case): cls， name, func, value = case try: # Run setUP method for each test method. #看这里 getattr(cls, "setUp").__call__(cls) if value: func.__call__(name, *value) else: func.__call__(name) #看这里 # Run tearDown method for each test method. getattr(cls, "tearDown").__call__(cls) except: # traceback.print_exc() cases_run_fail.append(name) else: cases_run_success.append(name) return cases_run_fail, cases_run_success可以看到这个函数传入的参数也改变了，case的值里加入了cls这个类。要达成这个效果， 相当于如何根据测试方法找到所属的测试类，利用inspect模块很简单的就拿到了。当然你也可以用name拿到函数名。 setup和teardown这两个方法每个测试用例都会执行，看到这里想明白了吗？这就意味着如果你在这里做初始化浏览器的操作，那么这个框架就可以做UI自动化，如果你做的是HTTP的get或者post的操作，那么这个框架也就是API接口框架。 setup和teardown实现了。我们再来看下setUpClass, tearDownClass的实现。那么我是怎么共享线程间的变量呢？ 常规情况下，我们可以用数据持久化的方式实现，具体来说，就是每个测试函数执行时候先去找一个文件，这个文件在就不再执行setUpClass，当然你得做好线程安全。大家还记得我的多线程是怎么实现的呢？12345#多线程部分代码with ThreadPool(number_of_threads) as p: p.map(f, cases_to_run)p.close()p.join()对于每一个线程，都去调用f函数，这个函数就是上方实现了每个函数setup和teardown的f。现在好了，我们用map可以不关心这些，直接嵌套实现：我把所有的用例重新组织，形成一种特殊的数据结构，具体来说，就是每个测试类和属于这个测试类的所有函数， 以如下方式组织(cls, [cls.method1, cls.method2])最终所有的测试类，在放到一个列表对象里。这样第一层次的并发，是基于测试类的，然后针对每一个测试类，我再进行并发。具体代码如下：123456789101112131415161718192021#部分代码def run(case): #cls是测试类 cls = case[0] #func_pack是测试函数及所有参数 func_pack = case[1] #实现setUPClass #到这一层只是类并发，真正的测试函数还没有并发。 #setUPClass应该做到测试类有设置就执行，否则就不执行。 handle_before_class_fixture(cls) p = ThreadPool(number_of_threads) #真正的测试函数并发 #这个func_run就相当于我们之前的f。 p.map(func_run, func_pack) p.close() p.join() #实现tearDownClass handle__after_class_fixture(cls)为了验证正确性，我把我们的测试类和方法改进如下：1234567891011121314151617181920212223242526@TestClass()class TestSumData: @BeforeClass() def before_class(cls): print("haha") cls.status = 1 def setUp(self): print("Now starting") @data_provider([(1, 2, 3), (4, 5, 9)]) @Test() def test_sum_data(self, x, y, z): print('Case &#123;0&#125; are running with data &#123;1&#125; -- thread id &#123;2&#125;'.format( self, (x, y, z), current_process())) print(self.status) assert SumData().sum_data(x, y) == z @Test(enabled=True) def test_sum_data2(self): print('Case &#123;0&#125; are running with data &#123;1&#125; -- thread id &#123;2&#125;'.format( self, None , current_process())) print(self.status) assert SumData().sum_data(4, 5) == 7 def tearDown(self): print("Now finished") @AfterClass() def after_class(cls): cls.status =0跑一下看看： 可以看到，cls.status这个共享数据，成功被测试函数接收到了。 setUpClass（我这里对应before_class）也成功运行， 且只运行了一次。 毫无破绽：） 到此为止，我已经实现了一个测试框架的绝大数功能，下一步，就要改造我的log还有接收用户参数了，敬请期待。历史文章：测试框架–教你用Python实现数据驱动1测试框架–教你用Python实现数据驱动2测试框架–数据驱动动态增加测试用例测试框架实践–动态挑选待运行测试用例Python测试框架实现(五)–多线程]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>测试框架</tag>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试框架实践--多线程]]></title>
    <url>%2F2018%2F11%2F16%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前面几次的分享，我从一个数据驱动的实现展开去，先后讨论了什么是数据驱动，如何实现数据驱动，数据驱动在自动化框架里如何应用。测试框架–教你用Python实现数据驱动1测试框架–教你用Python实现数据驱动2测试框架–数据驱动动态增加测试用例测试框架实践–动态挑选待运行测试用例 为什么要讲这些呢？ 因为这些是一个测试框架必不可少的部分，看看前面4次的分享，虽然可以成功的运行，但我们采用了顺序运行的方式，跟实际使用相差很远，现实中我们一般实现“并发”运行我们的测试用例。 说起并发，Python 有多线程（Multiple Threading）和多进程（Multiple Process）之分， 由于GIL即Global Interpreter Lock(全局解释器锁)的存在，python多线程并不能实现真正的并发（无论你的CPU是否多核），相反，多进程因为有独占的内存空间可以真正的实现并发。但在我们的自动化测试框架里，我们还是希望利用线程的公用内存空间特性，特别是同一个测试类我们希望有统一的setup， teardown特性。而这个多进程就不太适用，加上我们测试用例也不是CPU计算密集型，多线程方案的“并发”看起来是最佳选择。 但是是不是就一定要用threading.Thread呢？ 我们先看看”传统“的多线程并发。 一个通用的多线程模板是这样的：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import threadingimport queueimport timeexitFlag = 0class MyThread(threading.Thread): def __init__(self, q): threading.Thread.__init__(self) self.q = q def run(self): do_something(self.q)def do_something(q): while not exitFlag: queue_lock.acquire() if not work_queue.empty(): data = q.get() queue_lock.release() print("Now thread %s is processing %s" % (threading.currentThread(), data)) time.sleep(1) else: queue_lock.release()if __name__ == "__main__": num_worker_threads = 3 target_case = ['case1', 'case2', 'case3', 'case4', 'case5'] queue_lock = threading.Lock() work_queue = queue.Queue() threads = [] start_time = time.time() # Create new thread for case in range(num_worker_threads): thread = MyThread(work_queue) thread.start() threads.append(thread) # Fill queue queue_lock.acquire() for case in target_case: work_queue.put(case) queue_lock.release() # Wait queue empty while not work_queue.empty(): pass # Notify thread quite exitFlag = 1 # Wait all threads done for t in threads: t.join() end_time = time.time() print("All cases finished with running time --%s" % (end_time - start_time))把我们前面实现的顺序运行改成并发， 只需要改成如下就可以实现多线程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import threadingimport queueimport timefrom common.test_case_finder import DiscoverTestCases, unpack_test_cases_from_functionsexitFlag = 0def f(case): name, func, value = case try: if value: func.__call__(name, *value) else: func.__call__(name) except: # traceback.print_exc() cases_run_fail.append(name) else: cases_run_success.append(name) return cases_run_fail, cases_run_successclass MyThread(threading.Thread): def __init__(self, q): threading.Thread.__init__(self) self.q = q def run(self): while not exitFlag: queue_lock.acquire() if not work_queue.empty(): data = self.q.get() f(data) time.sleep(5) queue_lock.release() print("Now thread %s is processing %s" % (threading.currentThread(), data)) else: queue_lock.release()if __name__ == "__main__": num_worker_threads = 5 mypath = r"D:\ktest\tests\test_page1" cases_to_run = [] cases_run_success = [] cases_run_fail = [] discover_cases = DiscoverTestCases(mypath) mds = discover_cases.get_modules_spec() raw_test_cases = discover_cases.find_classes_in_module(mds) cases_to_run = unpack_test_cases_from_functions(raw_test_cases) queue_lock = threading.Lock() work_queue = queue.Queue() threads = [] start_time = time.time() # Create new thread for case in range(num_worker_threads): thread = MyThread(work_queue) thread.start() threads.append(thread) # Fill queue queue_lock.acquire() for case in cases_to_run: work_queue.put(case) queue_lock.release() # Wait queue empty while not work_queue.empty(): pass # Notify thread quite exitFlag = 1 # Wait all threads done for t in threads: t.join() end_time = time.time() print("All cases finished with running time --&#123;:.2f&#125; seconds" .format(end_time - start_time)) print('Below cases are passed:\n %s' %cases_run_success) print('Below cases are failed:\n %s' % cases_run_fail)可以看到，你自己要做很多事情来保证多线程的正常运行，你要维护queue，要注意资源锁，你要使用join来等待子线程都完成。 多线程难道都这么麻烦吗？ “人生苦短，我用python”不知道你们听过没 ：） multiprocessing.dummy 来助你一臂之力！ dummy是multiprocessing的一个克隆体，唯一的区别在于，dummy使用线程而multiprocessing使用进程。1234567891011121314151617181920212223242526272829303132333435from multiprocessing.dummy import Pool as ThreadPoolimport timefrom common.test_case_finder import DiscoverTestCases, unpack_test_cases_from_functionsdef f(case): name, func, value = case try: if value: func.__call__(name, *value) else: func.__call__(name) except: # traceback.print_exc() cases_run_fail.append(name) else: cases_run_success.append(name) return cases_run_fail, cases_run_successif __name__ == "__main__": number_of_threads = 5 mypath = r"D:\ktest\tests\test_page1" cases_to_run = [] cases_run_success = [] cases_run_fail = [] discover_cases = DiscoverTestCases(mypath) mds = discover_cases.get_modules_spec() raw_test_cases = discover_cases.find_classes_in_module(mds) cases_to_run = unpack_test_cases_from_functions(raw_test_cases) start_time = time.time() with ThreadPool(number_of_threads) as p: p.map(f, cases_to_run) p.close() p.join() end_time = time.time() print('Below cases are passed:\n %s' %cases_run_success) print('Below cases are failed:\n %s' % cases_run_fail) print("All cases finished with running time --&#123;:.2f&#125; seconds" .format(end_time - start_time))看下图，左边是传统的threading.Thread的多线程用法， 右边是multipleprocess.dummy的用法。除开定义Thread类外，threading.Thread还用了这么多篇幅才能令多线程工作，但multiprocessing.dummy只用一个Pool就全搞定了。 好了，今天我们讲到这里，并发也实现了，动态挑选也实现了，一个测试框架就搭起来来， 后面就是增强了， 下一期来实现test fixture， 敬请期待！]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>测试框架</tag>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试框架实践--动态挑选待运行测试用例]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%8A%A8%E6%80%81%E6%8C%91%E9%80%89%E5%BE%85%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前面几天， 我从数据驱动的一个第3方库ddt出发，连续分享了3篇文章：测试框架–教你用Python实现数据驱动1测试框架–教你用Python实现数据驱动2测试框架–数据驱动动态增加测试用例后面两篇文章实际上是任何一个测试框架都必须要有的部分。 今天我再分享一篇如何动态挑选测试用例， 大家知道，自动化脚本越写越多，但不是每次都需要full regression， 这个时候需要把开发修改涉及到的测试用例跑一下，而那些无关的用例可以不跑。 那么，思路是什么？ 如果对每一个用例，我定义的时候给一个标签比如说Test，再给它一个值，True或False，这样我框架寻找测试用例的时候就找标签编辑为Test且值是True的就好了。老规矩，先上代码：12345678910111213141516# test_decorator.pydef TestClass(enabled=True): def wraps(cls): setattr(cls, "__test_type__", "TestClass") setattr(cls, "__enabled__", enabled) return cls return wrapsdef Test(enabled= True): def wraps(func): setattr(func, "__test_type__", "Test") setattr(func, "__enabled__", enabled) return func return wraps# 利用装饰器，对于每一个进来的类或func，#我们给它加上一个属性一个值，然后再你需要运行的类或者func上装饰就好了。结合我们上次讲过的动态添加测试用例， 和数据驱动，我们把这部分整合起来看看，一个简单完整的测试框架如下。1.从指定的文件夹/文件下查找待运行测试类/方法2.找到待运行测试类/方法，并根据数据不同重新生成测试用例3.运行测试用例集并保存运行结果 我的整个项目层次结构是这样的：其中：Common:放通用的功能，比如，查找待测试用例的test_case_finder, 和我们上文的定义是否测试类/测试函数的装饰器test_decoratorpages放我们所有的页面功能，如果是UI测试，这个就对应于一个个的UI Page，我们将以Page Object组织页面元素，并定义页面类和方法，每一个页面当作一个page看待并定义一个类tests这个下面放我们的测试用例，结构跟pages完全对应，每一个测试类对应于一个page 类。run这个文件定义了用例如何运行，是并行还是顺序。 还有其它的很多功能，我们暂且不讲，先来看看这几个如何协作的。1234567# pages/page_add.py#我们就定义个多数相加的方法。class SumData: def __init__(self): pass def sum_data(self, *ags): return sum(ags)再看它对应的测试类123456789101112131415161718# tests/test_page1/test_page_add.py#这里面我定义了两个测试方法，一个要参数，一个不要。#并且用了两个装饰类，一个用来提供测试数据，一个用来标记是否需要测试from common.test_case_finder import data_providerfrom common.test_decorator import Testfrom pages.page_add import SumDataclass TestSumData: def __init__(self): pass @data_provider([(1, 2, 3), (4, 5, 9)]) @Test() def test_sum_data(self, x, y, z): print("the value are &#123;0&#125;, &#123;1&#125;, &#123;2&#125;".format(x, y, z)) assert SumData().sum_data(x, y) == z @Test(enabled=False) def test_sum_data2(self): print(2) assert SumData().sum_data(4, 5) == 7这两个装饰类的定义Test（）我们前面已经介绍过了，test provider定义如下：1234567def data_provider(test_data): def wrapper(func): setattr(func, "__data_Provider__", test_data) global index_len index_len = len(str(len(test_data))) return func return wrapper好了，有了page类，有个test类，那么如何让我们的程序查找到我们需要运行的测试用例呢？1234567891011121314#test_case_finder.py# 简化下，只给出如何鉴别待运行的用例#mod_ref就是我们动态加载进来的所有测试module。def find_classes_in_module(self, mod_ref): test_classes = [] for module in mod_ref: #微信关注公众号iTesting，加入万人测试团 cls_members = inspect.getmembers(module, inspect.isclass) for cls in map(lambda x: x[1], cls_members): for name, func in list(cls.__dict__.items()): if hasattr(func, "__test_type__") and hasattr(func, "__enabled__"): if getattr(func, "__test_type__") == "Test" and getattr(func, "__enabled__") == True: test_classes.append(func) return test_classes那么，用例找出来了，如何数据驱动呢？12345678910111213141516#test_case_finder.pydef mk_test_name(name, value, index=0): index = "&#123;0:0&#123;1&#125;&#125;".format(index+1, index_len) test_name = "&#123;0&#125;_&#123;1&#125;_&#123;2&#125;".format(name, index, value) return re.sub(r'\W|^(?=\d)', '_', test_name)def unpack_test_cases_from_functions(func_list): return_cases = [] for func in func_list: if hasattr(func, '__data_Provider__'): for i, v in enumerate(getattr(func, "__data_Provider__")): test_name = mk_test_name(func.__name__, getattr(v, "__name__", v), i) return_cases.append((test_name, func, v)) else: return_cases.append((func.__name__, func, None)) return return_cases#我们通过反射的方式找到有Test（）装饰的测试方法，并且只把enabled=True的测试方法放入我们的测试用例里。测试用例也找到了，该运行了：123456789101112131415161718192021222324252627282930#run.py#简化版, 实现了一个简单的顺序执行，我们后面将一步步优化至并发，顺序都可以import tracebackfrom common.test_case_finder import DiscoverTestCases, unpack_test_cases_from_functionsif __name__ == "__main__": ＃下面一句给定了查找测试用例的根目录，如果不给定，我们默认从ｔｅｓｔｓ文件夹找 mypath = r"D:\ktest\tests\test_page1" cases_to_run = [] cases_run_success = [] cases_run_fail = [] discover_cases = DiscoverTestCases(mypath) mds = discover_cases.get_modules_spec() cases_to_run = unpack_test_cases_from_functions(discover_cases.find_classes_in_module(mds)) while cases_to_run: try: name, func, value = cases_to_run.pop(0) if value: func.__call__(name, *value) else: func.__call__(name) except: # traceback.print_exc() cases_run_fail.append(name) else: cases_run_success.append(name) print('Below cases are passed:\n %s' %cases_run_success) print('Below cases are failed:\n %s' % cases_run_fail) ＃以上给定了一个简单的方法，找到所有的呆测试用例，＃然后一个个执行，并且将测试成功和失败用例集分别存放，方便后续测试报告的生成。运行结果如下：1234Below cases are passed: ['test_sum_data_1__1__2__3_', 'test_sum_data_2__4__5__9_']Below cases are failed: []基本上实现了我们的需求，但是一个测试框架，要考虑的还很多，比如：1.测试fixture，包括运行前准备和运行后清理。2.并发执行3.测试报告4.邮件发送5.错误截图6.log记录 我后续将带你逐个击破，最终写出自己的测试框架，敬请期待。]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>测试框架</tag>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Selenium Grid 简明用法]]></title>
    <url>%2F2018%2F09%2F26%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FPython%20Selenium%20Grid%20%E7%AE%80%E6%98%8E%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前几天有同学问我selenium gird的问题， 简要告知后才知道，selenium gird仍然在很多公司的自动化里占很大比重，我一直觉得在Jenkins这种持续集成工具大行其道的今天，selenium gird用来做分布式运行的工具已经可以寿终正寝了，看来还是行业不同，关注点就不同，整理了elenium gird用法，分享给大家。 首先， Selenium Gird解决了一个什么问题？ Selenium-Grid allows you run your tests on different machines against different browsers in parallel. That is, running multiple tests at the same time against different machines running different browsers and operating systems. Essentially, Selenium-Grid support distributed test execution. It allows for running your tests in a distributed test execution environment.简单的说， seleniumgrid允许你在不同的机器上针对不同浏览器并行运行测试。也就是说，同时针对运行不同浏览器和操作系统的不同机器同时运行多个测试。基本上，Selenium-Grid支持分布式测试执行。它允许在分布式测试执行环境中运行测试。 其次，何时使用？ To run your tests against multiple browsers, multiple versions of browser, and browsers running on different operating systems.要针对多个浏览器运行测试，可以在不同操作系统上运行多个版本的浏览器和浏览器。To reduce the time it takes for the test suite to complete a test pass.减少测试套件完成测试通行所需的时间。 然后， 它的原理是什么？Grid由单个Hub和一个或多个Node组成。两者都是使用selenium-server.jar可执行文件启动的。hub接收要执行的测试以及应该运行测试的那个浏览器和platform（即WINDOWS，LINUX等）的信息。它知道已经register到hub的每个节点的配置。它会在满足浏览器 - 平台组合的可用节点中选择一个。一旦选择了一个节点，一个测试发起的Selenium命令就被发送到hub，并将传递到分配给该测试的节点。该节点运行浏览器，并在该浏览器内针对被测试应用程序执行Selenium命令。 最后， 如何安装使用？1.下载Selenium-Server jar file. 确保安装路径在系统的环境变量path里，这样你才能从command line访问。 2.启动hub节点在command line里输入：1java -jar selenium-server-standalone-&lt;version&gt;.jar -role hub成功后你会看到如下图：此命令会帮你自动注册一个hub，default 端口4444. 你可以通过网页http://localhost:4444/grid/console来查看。3.启动node节点在command line里输入：12java -jar selenium-server-standalone-&lt;version&gt;.jar -role node -hub http://localhost:4444/grid/register#注意，你的node节点如果和hub节点不一个地址，你需要把-hub后面的的地址中的 localhost：4444换成真实的hub地址。成功后，去Hhub节点的http://localhost:4444/grid/console来查看： 注意Node节点的register有多个参数可以选择12#register Node的时候加上如下参数， 相当于register了一个Linux上 3.6版本的firefox。 -browser browserName=firefox,version=3.6,platform=LINUX4.使用1#还记得之前讲过的automation framework吗，我们利用下原来的脚本，仅仅把setup（）函数修改一番运行命令如下： 这就是跑单个用例的情况，如果你希望不同的用例跑在不同的机器上怎么办？就多注册几个node节点，注册时加上12#register Node的时候加上如下参数， 相当于register了一个Linux上 3.6版本的firefox。 -browser browserName=firefox,version=3.6,platform=LINUX然后代码里只要在setup 浏览器哪里指定浏览器名称就好了，例如：12345self.browser = webdriver.Remote(command_executor="http://localhost:4444/wd/hub", desired_capabilities=&#123; 'platform': 'ANY', 'browserName': "chrome" &#125;)具体哪个node支持哪个browser可以在Hub上通过 http://localhost:4444/grid/console查看 有的同学就问了，selenium grid在多个机器上跑不同浏览器做到了，那么怎么做到并发呢？selenium grid本身不提供并发支持，需要自己写并发的代码，或者我们用pytest来看看如果并发。 1python -m pytest test --workers 2 --tests-per-worker 2 --html=222.html 结合前图就可以知道，selenium grid会根据你browser的设置去找register到grid上的对应的browser，找到就运行，这样就实现了并发，多机器同时运行。 5.总结有的人说，我用Jenkins也可以做到同样的事情啊？可以建立多个job，每个job对应一个浏览器不就好了？ 的确如此， 但是你想这样一个场景，我想让这个用例运行在chrome 68及以上版本，同时还想有一些用例运行在chrome50以下版本，这样jenkins就麻烦了，需要配置不同的节点来运行。但是selenium grid却都可把浏览器装在同一个机器上选择版本运行。 总之， selenium gird有自己的应用场景，特别对于大型系统来说，selenium grid应用还比较普遍。 大家可以根据自己情况自行选择。]]></content>
      <categories>
        <category>automation</category>
        <category>web自动化</category>
      </categories>
      <tags>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试框架--数据驱动动态增加测试用例]]></title>
    <url>%2F2018%2F09%2F25%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前面我们讲了什么是python数据驱动，如何使用及如何实现数据驱动。没看过文章的请移步：Python数据驱动实践(一)–ddt实现数据驱动Python数据驱动实践(二)–教你用Python实现数据驱动 今天我们来解决另外一个问题，实现数据驱动后，如何在测试报告里体现？老规矩，先上段代码：1234567891011121314151617181920212223242526272829# 这段代码实现了一个事情， 测试一个sum_data的方法。from functools import wrapsdef data_provider(test_data): def wrapper(func): @wraps(func) def repl(self, *args, **kwargs): for i in test_data: print('func starts') func(self, *i, **kwargs) print('func ends') return repl return wrapperclass SumData: def __init__(self): pass def sum_data(self, *ags): return sum(ags)class TestSumData: def __init__(self): pass @data_provider([(1, 2, 3), (4, 5, 9)]) def test_sum_data(self, x, y, z): print("the value are &#123;0&#125;, &#123;1&#125;, &#123;2&#125;".format(x, y, z)) assert SumData().sum_data(x, y) == zif __name__ == "__main__": print(TestSumData().test_sum_data())#唯一需要注意的是，@wraps的作用：#由于装饰器的加入导致Python解释器认为函数本身发生了改变，所以用@wraps，#它可以将原函数对象的指定属性复制给包装函数对象，保证装饰器不会对被装饰函数造成影响我们知道，运行测试用例时候，通常会给一个待运行函数的集合，针对集合的每一个函数，逐个运行一遍，然后收集每个测试函数（用例）的名字，运行结果，然后保存，待生成测试报告用。 我们当前的代码， 根据data provider提供的数据不同，test_sum_data 这个函数也会运行多次，但是测试报告里只有一个test_sum_data， 那么如何解决呢？1.先检查要运行的测试函数有没有data provider。2.对于每个有data provider的测试函数，针对每一条数据，生成一个新的名字。3.把新的名字加入到要运行的test case列表里。 根据这个我们知道，我们代码少两个函数实现， 一个是检查函数有没有data provider， 二是给有data provider装饰的函数生成新名字。怎么实现，当然是装饰器啦。那么如何检查函数有没有提供data呢？我们可以人为给提供了data的函数加些属性。1234567def data_provider(test_data): def wrapper(func): setattr(func, "__data_Provider__", test_data) global index_len index_len = len(str(len(test_data))) return func return wrapper如何给有__data__provider \ 属性的函数生成新名字呢？1234def mk_test_name(name, value, index=0): index = "&#123;0:0&#123;1&#125;&#125;".format(index+1, index_len) test_name = "&#123;0&#125;_&#123;1&#125;_&#123;2&#125;".format(name, index, value) return re.sub(r'\W|^(?=\d)', '_', test_name)那么，怎么组织把这些命名的新函数添加到待运行列表呢？12345678def get_test_cases(cls): return_cases = [] for name, func in list(cls.__dict__.items()): if hasattr(func, '__data_Provider__'): for i, v in enumerate(getattr(func, "__data_Provider__")): test_name = mk_test_name(name, getattr(v, "__name__", v), i) return_cases.append((test_name, func, v)) return return_cases最后我们整理下，看看实际上是如何使用的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import redef data_provider(test_data): def wrapper(func): setattr(func, "__data_Provider__", test_data) global index_len index_len = len(str(len(test_data))) return func return wrapperclass SumData: def __init__(self): pass def sum_data(self, *ags): return sum(ags)class TestSumData: def __init__(self): pass @data_provider([(1, 2, 3), (4, 5, 6)]) def test_sum_data(self, x, y, z): print("the value are &#123;0&#125;, &#123;1&#125;, &#123;2&#125;".format(x, y, z)) assert SumData().sum_data(x, y) == zdef mk_test_name(name, value, index=0): index = "&#123;0:0&#123;1&#125;&#125;".format(index+1, index_len) test_name = "&#123;0&#125;_&#123;1&#125;_&#123;2&#125;".format(name, index, value) return re.sub(r'\W|^(?=\d)', '_', test_name)def get_test_cases(cls): return_cases = [] for name, func in list(cls.__dict__.items()): if hasattr(func, '__data_Provider__'): for i, v in enumerate(getattr(func, "__data_Provider__")): test_name = mk_test_name(name, getattr(v, "__name__", v), i) return_cases.append((test_name, func, v)) return return_casesif __name__ == "__main__": cases_to_run = [] cases_run_success = [] cases_run_fail = [] #注1 cases_to_run = get_test_cases(TestSumData) while cases_to_run: try: case = cases_to_run.pop(0) name = case[0] func = case[1] v = case[2] func(name, *v) except: # traceback.print_exc() cases_run_fail.append(name) else: cases_run_success.append(name) print(cases_run_success) print(cases_run_fail)#outputthe value are 1, 2, 3the value are 4, 5, 6['test_sum_data_1__1__2__3_']['test_sum_data_2__4__5__6_']我们定义并维护了三个列表，一个是cases_to_run，放我们找到的所有的测试用例，一个是cases_run_success，放运行成功的用例，最后一个cases_run_fail， 放测试不成功的用例。从运行结果我们可以看出， 我们只有一个测试函数test_sum_data，测试报告里却有了两个用例test_sumdata112_3， test_sumdata245_6。 就这样我们就实现了测试报告里数据驱动可视化。 Hold on， 看我上面代码的注释（注1），我们传入的是固定的测试类，那么在真实的测试中，我希望框架去自动查找测试类和测试方法，这个怎么搞？请期待下次分享 ：）]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>测试框架</tag>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试框架--教你用Python实现数据驱动2]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A82%2F</url>
    <content type="text"><![CDATA[在做自动化测试时，我们通常有这样的需求，对某一个用例，希望可以根据我们提供的不同数据而运行多次，每次运行加载一条数据，但是运行的是同一个用例，仅仅是数据不同。这个模式Java里TestNG有个概念叫DataProvider， python里也有，叫ddt。 上次我们介绍了用法，连接在此Python数据驱动实践，今天来讲下如何自己实现一个ddt。我们先来看一个简单例子：12345def sum_data(x, y): return x + yif __name__ == "__main__": assert sum_data(1, 2) == 3 assert sum_data(4, 5) ==8正常来说， 要验证这个函数的实现正确与否，最基本的两个检查点一定是一个通过一个不通过。 上面代码可以看到我们写了两条用例，基本实现了我们的需求，但是感觉还有优化的空间，于是我们改成了这样1234567def sum_data(x, y): return x + ydef test_sum_data(x, y, z): assert sum_data(x, y) == zif __name__ == "__main__": test_sum_data(1, 2, 3) test_sum_data(4, 5, 6)看起来简单了一点，但是对于接口测试来说，一个函数可能验证的点有几十条，难道我们要copy-paste test_sum_data这个函数多次吗？大家都知道， python里有装饰器这个概念，装饰器最大的特点就是接收一个函数称为参数，然后做一些”夹带私货“的操作后再返回这个函数。如果你不是很了解装饰器的话，也没关系，你只要记住如下转换就可以了：1234#假设你有一个函数叫func， 你有一个装饰器函数叫decorator， 那么如下代码@decoratordef func(): passpython解释器会解释成下面这样的语句：1234567func = decorator(func)#如果你的装饰器decorator带参数怎么办？@decorator(arg1, arg2)def func(): pass#相当于：func = decorator(arg1,arg2)(func)了解了上面，那我们继续看，我们应该怎么用装饰器来精简我们的函数：1234567891011121314151617181920212223242526272829def sum_data(x, y): return x + ydef my_data(test_data): def wraps(func): def repl(x, y, z): for i in test_data: x, y, z = i print('func starts') func(x, y, z) print('func ends') return repl return wraps@my_data([(1, 2, 3), (4,5,6)])def test_sum_data(x, y , z): assert sum_data(x, y) == zif __name__ == "__main__": test_sum_data(1, 2, 4)#运行一遍看， 结果如下：Traceback (most recent call last): File "88.py", line 22, in &lt;module&gt; test_sum_data(1, 2, 4) File "88.py", line 11, in repl func(x, y, z) File "88.py", line 18, in test_sum_data assert sum_data(x, y) == zAssertionErrorfunc startsfunc endsfunc starts可以看到函数第2此运行的时候失败了，报的错也是assert error。你们发现没？ 函数test_sum_data的自身的实参不起作用了， 变成从my_data提供了，那么我的函数就要相应的优化下1234567891011121314151617181920def sum_data(x, y): return x + ydef my_data(test_data): def wraps(func): def repl(*args): for i in test_data: print('func starts') x, y , z = i func(x, y , z) print('func ends') return repl return wraps@my_data([(1, 2, 3), (4,5,9)])def test_sum_data(x, y , z): print("Your are verifing (&#123;&#125; + &#123;&#125;) == &#123;&#125;".format(x, y, z)) assert sum_data(x, y) == zif __name__ == "__main__": test_sum_data()#这样我们在方法test_sum_data后面不加参数就可以了。#注意：*args是可变参数的意思，它的实现实际上是个unpack，大家有兴趣可以自行了解下。可是还有个问题，我想把这个数据驱动给我不同的函数使用怎么办？12345678910111213141516171819202122232425def sum_data(x, y): return x + ydef is_equal(x, y): return x==ydef my_data(test_data): def wraps(func): def repl(*args， **kwargs): for i in test_data: print('func starts') func(*i, **kwargs) print('func ends') return repl return wraps@my_data([(1, 2, 3), (4,5,9)])def test_sum_data(x, y , z): print("Your are verifing (&#123;&#125; + &#123;&#125;) == &#123;&#125;".format(x, y, z)) assert sum_data(x, y) == z@my_data([(2,2), (1, 2)])def test_is_equal(x, y): print("Your are verifing &#123;&#125; == &#123;&#125;".format(x, y)) assert is_equal(x, y) ==1if __name__ == "__main__": test_sum_data() test_is_equal()#运行一下， O了。就这样，我们一步一步实现了数据驱动的功能，实际上，如果你看过Python DataProvidor–ddt的源码，就发现，它实际上也是这么实现的。本文的主要难点在装饰器上，而对于装饰器的理解，主要难点在闭包上，大家可以相应的搜索下，如有疑问，欢迎交流。 Hold On， 这就结束了吗？ NO！ 我们知道，自动化过程中我们通常会希望一个case在报告里有一个对应结果. 但对于我们实现的DataProvider，在测试报告里只会显示一条记录，太不利于我们调试了。那么，如何在测试报告里体现呢？ 且听下回分解：）]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>测试框架</tag>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试框架--教你用Python实现数据驱动1]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A81%2F</url>
    <content type="text"><![CDATA[在做自动化测试特别是接口测试的过程中，我们经常碰到这样的例子，几个用例步骤，操作完全一样，仅仅是数据和结果不一样。常规的做法是每套数据写一个测试用例。这样弊端也非常明显，一是假如这部分用例操作需要改变，那么用例要一个个修，二就是代码很不整洁。那么有什么好的办法没？今天我们来了解下自动化测试里的数据驱动顾名思义，数据驱动的存在就是为了解决上述问题。那么在自动化测试里，有哪些好的数据驱动库呢？ DDT (Data-Driven Tests) allows you to multiply one test case by running it with different test data, and make it appear as multiple test cases. 1.安装1pip install ddt2.APIddt作为unittest的补充，它的使用需要跟unittest结合起来。ddt提供了如下用法： ddt.add_test:给一个类添加一个测试用例。 dd.ddt：装饰类，也就是继承自TestCase的类。 ddt.data：装饰测试方法。参数是一系列的值。 ddt.file_data：装饰测试方法。参数是文件名。文件可以是json 或者 yaml类型。 注意，如果文件以”.yml”或者”.yaml”结尾，ddt会作为yaml类型处理，其他所有文件都会作为json文件处理。如果文件中是列表，每个列表的值会作为测试用例参数，同时作为测试用例方法名后缀显示。如果文件中是字典，字典的key会作为测试用例方法的后缀显示，字典的值会作为测试用例参数。 ddt.unpack：传递的是复杂的数据结构时使用。比如使用元组或者列表，添加unpack之后，ddt会自动把元组或者列表对应到多个参数上。字典也可以这样处理。 测试用例方法名生成规则“使用ddt后，会产生一个新的测试用例方法名：之前的测试用例方法名_ordinal_data之前的测试用例方法名：即定义的测试用例方法名。比如def test_large()，这里就是test_large ordinal：整数，从1开始递加。 data：如果传递过来的数据存在name属性，则这里就是该数据的name值。如果未定义name属性，ddt会尽量将传递过来的数据转化为python标识符，作为data显示。比如（3,2）就转化为3_2。需要注意的是，如果数据是字典，则这里就是字典的key。 ddt里用的最多的就是@data 和 @file_data: data: contains as many arguments as values you want to feed to the test. file_data: will load test data from a JSON or YAML file. 3.举例使用ddt很简单，你只需要在你的测试类上加装饰器@ddt， 然后在你需要用数据驱动测试用例上加装饰器@data @unpack， @file_data 即可。 我们先来看看@data的用法：1234567891011121314151617181920212223242526272829#ddt_related/test_ddt.py#先看数据直接提供部分import unittestfrom ddt import ddt, data, unpackdef larger_than_2(x): return x&gt;2def add_values(x, y): return x + y@ddtclass SampleTest(unittest.TestCase): def setUp(self): pass def test_larger_than_2_no_para(self): self.assertTrue(larger_than_2(2)) @data(3, 4, 5) def test_larger_than_2(self, value): self.assertTrue(larger_than_2(value)) @data((1,2, 3)) def test_add_values(self, value): a, b, c = value self.assertEqual(add_values(a, b), c) @data([2, 3, 6], [4,5,9]) @unpack def test_add_values_unpack(self, a, b, c): self.assertEqual(add_values(a, b), c) def tearDown(self): passif __name__ == "__main__": unittest.main()deblock %&#125;我们来运行下， 结合我们前面介绍过的pytest框架， commandline里运行： 1python -m pytest ddt_related/test_ddt.py --html=report.html 结果如下：我们从结果中可以看到，ddt自动帮我们把数据驱动的用例分解成多个用例运行，用例名称也按照一定的规则重新生成了。 再来看看@file_data的用法：12345678910111213141516# 我们先在ddt_related文件夹下建立文件json_data.json， 内容如下：&#123; "add_test": &#123;"a":1, "b":2, "c":3&#125;&#125;#然后我们运行用例：@ddtclass SampleTest(unittest.TestCase): def setUp(self): pass @file_data(os.path.join(os.path.dirname(__file__), "json_data.json")) def test_add_values_unpack(self, a, b, c): self.assertEqual(add_values(a, b), c) def tearDown(self): pass# command line运行 python -m pytest ddt_related/test_ddt.py --html=report.html#我们发现用例执行成功， 说明json文件被正确的读取和应用了。注意， ddt的一个坏处是什么？ 不同的数据文件不能混淆在一个文件.举例来说，我们实现了两个方法， 一个需要1个参数，另外一个需要2个参数。1234def larger_than_2(x): return x&gt;2def add_values(x, y): return x + y如果你想以一个文件放2个函数的数据，例如： 12345# 我们先在ddt_related文件夹下建立文件json_data.json， 内容如下：&#123; "add_test": &#123;"a":1, "b":2, "c":3&#125;， "larger_than_2" :[1, 2, 3]&#125; 然后你运行用例，会失败如下：12TypeError: test_add_values_unpack() missing 2 required positional arguments: 'b' and 'c'TypeError: test_larger_than_2() got an unexpected keyword argument 'b'ddt给出的解释是： In case of a list, each value in the list will correspond to one test case, and the value will be concatenated to the test method name.In case of a dict, keys will be used as suffixes to the name of the test case, and values will be fed as test data. 如果我们测试用例接受的参数个数不同，那么就需要建立不同的数据文件， 所以从这个程度上来说，ddt也有它的局限性， 那么如何规避这个问题呢？，我们可以在文件里存储数据，然后读出来后，按需放入@data来使用。 有了ddt，我们实现了用数据驱动测试， 并且代码量显著减少了，确实不错，我们如果再认真一点， 就会思考ddt是如何实现数据驱动的？为什么多一条数据就多一条用例？为什么用了ddt， 我测试用例的名称，在测试报告的体现，不再是原来的了，而是加了suffix？ 下面我将带领大家深入了解ddt的实现，并由此自己用代码实现数据驱动， 敬请期待 ：）]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>测试框架</tag>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化框架Pytest从入门到熟练使用]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6Pytest%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[如需阅读全文，请关注公众号TesterTalk索要密码。unittest是python自带的单元测试框架，它封装好了一些校验返回的结果方法和一些用例执行前的初始化操作，使得单元测试易于开展，因为它的易用性，很多同学也拿它来做功能测试和接口测试，只需简单开发一些功能（报告，初始化webdriver，或者http请求方法）便可实现。 但自动化测试中我们常常需要根据不同需求挑选部分测试用例运行，并且我们希望用例克服环境不稳定的局限，即运行失败后自动重新运行一次，如果成功就认为是环境问题导致第一次失败，还有我们经常希望测试用例可以并发执行等等，这些unittest都做不到或者需要大量二次开发才能做到，那么有没有更加强大的框架可以替代unittests呢？ pytest是python里的一个强大框架，它可以用来做单元测试，你也可以用来做功能，接口自动化测试。而且它比unittest支持的功能更多更全面。但是pytest在Getstarted里给出的实例却很简单，很多同学错以为它只是跟unittest一样是个单元测试框架罢了，如果你查询中文互联网，你也只能找到寥寥数篇大致一样的用法，可以说pytest的精髓使用，没有被大家挖掘出来，如此强大的框架不应该被埋没，今天我就带领大家深入pytest使用，共同领略pytest的强大。 1.pytst安装pytest不属于python的标准库，所以需要安装才能使用， 安装方式如下：1pip install -U pytest 如果你已经安装有pytest，想查看它的版本号：1pytest --version 2.你的第一个pytest测试12345678#直接使用官网用例# content of TesterTalk.pydef func(x): return x + 1def test_answer(): assert func(3) == 5#在你的terminial里输入 python -m pytest TesterTalk.py,你将会看到如下信息： 非常简单吧， 如果想运行多个用例该如何做呢？1234567891011# content of TesterTalk.pyclass TestClass(object): def test_one(self): x = "this" assert 'h' in x def test_two(self): x = "hello" assert hasattr(x, 'check')#把要测试的case以test_开头就好了。#terminal里输入 pytest TesterTalk.py, 执行结果一个成功一个失败。 注意: （1）.如果你想用pytest寻找整个文件夹下的测试用例，那么文件须以test_开头或者以test结尾。（2）.测试类以Test开头，并且不能带有 init 方法。（3）.测试函数以test开头。（4）.另外，pytest不支持也不打算支持中文路径，如果项目路径中有中文会报错。好了，pytest的getStarted就结束了， 看了上面的应用方式的确没觉得它哪里强大。 别着急，我们再来想一想，如果你有个测试框架，你希望如何用这个框架做测试？ 3.灵活的指定测试用例运行集。在unittest框架里，你只能通过suite.addTest（），或者defaultTestLoader.Discover()两种方法在查找测试用例，对于你不需要的测试用例，只能用@unittest.skip()来忽略，但做不到不改动代码变更测试用例集，pytest很好的实现了这一点，它支持如下查找：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 1. 运行某个package下的所有用例。pytest test_4. #会运行test_4下面所有的test_*.py 或者*_test.py文件里所有的Test开头的类（这个类不允许有__init__方法）下面的以test_开头的方法。#2. 运行某个文件（module）下的所有用例。pytest testtalk.py #会查找这个文件下所有的Test开头的类（这个类不允许有__init__方法）下面的以test_开头的方法。#3. 运行包含（或不包含）某个关键词的测试类/方法。class TestClass(object): def test_one(self): x = "this" assert 'h' in x def test_two(self): x = "hello" assert hasattr(x, 'check')#在terminal里输入 pytst -k "TestClass and not two" #会运行 test_one这个function但不会与性test_two.#4.根据node ids运行测试用例。 pytest给每个test assign里一个id。 可以用::隔开。 举例来说：# TesterTalk.pyclass TestClass(object): def test_one(self): x = "this" assert 'h' in x def test_two(self): x = "hello" assert hasattr(x, 'check')#在terminal里输入 pytest TesterTalk.py：：TestClass 会执行TestClass下的所有用例#在terminal里输入 pytest TesterTalk.py：：TestClass：：test_two, 仅会执行test_two.#5.根据标签（mark）运行，比如有个测试类，你想在regression时候才运行，另外一个测试类你想在releasae的时候才运行。#TesterTalk.py@pytest.mark.releaseclass TestClass1(object): def test_one(self): x = "this" assert 'h' in x def test_two(self): x = "hello" assert hasattr(x, 'check') @pytest.mark.regressionclass TestClass2(object): def test_one(self): x = "this" assert 'h' in x def test_two(self): x = "hello" assert hasattr(x, 'check')#你只需在terminal里指定标签就可以了。 pytest TesterTalk.py -m releasepytest TesterTalk.py -m regression是不是比unittest方便太多了，所有的测试类，测试方法，你只需要用@pytest.mark.XXX装饰就好了。然后一次更改，多次挑选运行！这样就完了吗？ NO, No,No, 你如果想几个标签一起运行怎么办？或者你不想某个标签运行怎么办？ Very simple：pytest TesterTalk.py -m “release or regression" #有release或者regression标签的都会运行。pytest TesterTalk.py -m “not regression” # regression标签的不会运行。当然了，unittest里支持的skip方法，pytest也支持，具体用法如下：#TesterTalk.py@pytest.mark.skip('skip')class TestClass1(object): def test_one(self): x = "this" assert 'h' in x def test_two(self): x = "hello" assert hasattr(x, 'check')#skip装饰器可以放在类前面skip掉整个测试类，也可以防止function前面只skip掉这个function。#对应的还有skipif， 请自己看文档了解。 难道就仅限于此吗？ 其实pytest帮我们实现了更多的高级功能，比如： 4.并发运行测试用例集关注公众号TesterTalk，跟我一起关注测试技术首先，你得安装个插件：1pip install pytest-parallel #pytest-parallel比pytst-xdist要更好。其次，要注意区这个插件仅仅支持python3.6版本及以上，而且如果你想多进程并发，必须跑在Unix或者Mac机器上，windows环境仅仅支持多线程运行。运行上需要指定参数： –workers (optional) X。 多进程运行， X是进程数。 默认值1。–tests-per-worker (optional) X. 多线程运行， X是每个worker运行的最大并发线程数。 默认值1。 举例来说：1234567891011121314151617181920212223242526# TesterTalk.pyimport pytest@pytest.mark.releaseclass TestClass1(object): def test_one(self): x = "this" assert 'h' in x def test_two(self): x = "hello" assert hasattr(x, 'check')@pytest.mark.regressionclass TestClass2(object): def test_one(self): x = "this" assert 'h' in x def test_two(self): x = "hello" assert hasattr(x, 'check')#terminal里输入 pytest TesterTalk.py --workers 2 #指定一个进程并发#terminal里输入 pytest TesterTalk.py --workers 2 --test-per-worker 3 #指定2个进程并发，每个进程最多运行3个线程。 5.测试报告优化12345678#允许HTML格式报告#首先还是要安装：pip install pytest-htmlUsage：使用很简单带参数 --html=report.html就好。仍然拿我们刚才举例：pytest TesterTalk.py --html=./report.html 生成的结果如下： 有时候，我们需要克服环境问题，让失败的用例rerun，有没有办法呢？123456789#rerun失败的case#首先还是要安装：pip install pytest-rerunfailuresUsage:--reruns 5 ＃ｒｅｒｕｎ ５次----reruns 5 --reruns-delay 1 # rerun5次， 但是每次rerun前等待1秒。仍以我们刚才的为例：#terminal里输入 pytest TesterTalk.py --reruns 1 --html=./report.html 生成的结果如下：可以看到，rerun聚合在了报告里。 我们自动化一般用到持续集成，Jenkins里需要junit XML格式的报告，pytest有没有办法直接生成？123456无需安装，直接使用：pytest --junitxml=path 例如：pytest TesterTalk.py --reruns 1 --html=./report.html --junitxml=./xml_format_report.xml会在本地目录生成xml_format_report.xml 这就结束了吗？还远呢？数据参数化你了解下？ 6.数据参数化pytest有几种数据参数化方式： pytest.fixture(). 不带参数 123456789101112131415#1.fixture()不带参数：import pytest@pytest.fixture()def initial_browser(): from selenium import webdriver return webdriver.Chrome()class TestBaidu(): def test_open_baidu(self, initial_browser): initial_browser.get("http://www.baidu.com") #在terminal里输入pytest testing/testertalk.py --html=./report.html， 你会看到百度浏览器打开了。说明函数间可以传递值，我们也可以利用这个来做unittest里setup（）的事情。 pytest.fixture()， 带parms参数: params with @pytest.fixture, a list of values for each of which the fixture function will execute and can access a value via request.param.1234567891011121314#利用fixtures的paramsimport pytest@pytest.fixture(params=[&#123;'username':'TesterTalk',"password":1&#125;, &#123;'username':'Test',"password":1&#125;])def account_provider(request): #request是固定的。 return request.param #request.parm也是固定的。def test_login(account_provider): #some operations print(account_provider)假设你需要用多个用户名密码测试登录，只需要用fixture（）加params就好。#在terminal里输入pytest testing/testertalk.py --html=./report.htmlreport显示下图,可以看到test_login被执行了2遍，每次执行带入的数据不同： 除了直接用pytest.fixture, 还可以这么用： pytest.mark.usefixtures() 12345678910111213import pytest@pytest.fixture(params=[&#123;'username':'TesterTalk',"password":1&#125;, &#123;'username':'Test',"password":1&#125;])def account_provider(request): return request.param@pytest.mark.usefixtures("account_provider")def test_login(account_provider): #some operations print(account_provider)#在terminal里输入pytest testing/testertalk.py --html=./report.html，report跟上面的演示一样。注意：使用fixture标记函数后，函数将默认接入一个request参数，它将包含使用该fixture函数的信息，这使我们可以更加灵活的根据不同的函数来决定创建不同的对象以及释放函数。 举例来说userfixtures可以用作setup（）和teardown（） pytest固然强大，这就结束了吗？还有什么高阶的功能吗？必须的。 7.pytest.mark.parametrize实现数据驱动1234567891011#直接在测试方法前直到数据源import pytest@pytest.mark.parametrize("account_provider", [&#123;'username':'TesterTalk',"password":1&#125;, &#123;'username':'Test',"password":1&#125;])def test_login(account_provider): #some operations print(account_provider)#在terminal里输入pytest testing/testertalk.py --html=./report.html，就能看到login跑了2次。 如果我的数据来自外部文件呢？12345678910import pytest#直接写函数读取外部文件生成数据值，注意values返回值是个listvalues = read_from_excel()@pytest.mark.parametrize('v', values)def test_login(v): #some operations print(v)#在terminal里输入pytest testing/testertalk.py --html=./report.html，就能看到login跑了2次，结果跟上面一样。 到这里为止，你已经学习了pytst的基础功能，高阶功能，还有什么吗？ 如果你之前的框架是unittest， pytest支持无缝切换， 你不需要改任何代码。记得上次直播我分享的unittest实现的自动化框架吗，我们看看这个page：这个是unittest实现的测试类，我们之间在terminal里运行1pytet test_baidu.py --html=./report.html ,就是这么简单，我们看看报告是什么样子 怎么样，就问你惊喜不惊喜？刺激不刺激！ 当然，pytest的特色还远不只与此，我们最后介绍一个高级特性，它允许你在用例运行的整个session里，或者一个module里共享测试数据。 8.作用域（scope）实现数据共享（autouse）我们知道，fixture，允许你不带参数运行和带参数运行， 调用fixture的第三种方式就是使用autousefixture decorator一个optional的参数是autouse, 默认设置为False。 当默认为False，就可以选择用上面两种方式来试用fixture。 当设置为True时，在一个session内的所有的test都会自动调用这个fixture。 权限大，责任也大，所以用该功能时也要谨慎小心。 举例来说，我想初始化我的浏览器，但是我不想每次测试运行都初始化，怎么办呢？我可以用scope限制住。首先要建立一个conftest.py文件：123456789101112131415161718192021import pytestfrom selenium import webdriver@pytest.fixture(scope="session", autouse=True)def my_session_enginie_chrome(): print("I will use session engine -- chrome") browser= webdriver.Chrome() return browser@pytest.fixture(scope="module")def my_module_enginie_firefox(): print("I will use module engine -- firefox") browser = webdriver.Firefox() return browser@pytest.fixture(scope="module")def my_function_enginie_chrome(): print("I will use funciton engine --chrome") browser = webdriver.Firefox() return browser 其次，写我们的测试类123456789101112131415161718192021222324252627282930313233#test_666.pyimport pytest##如果autouse fixture被session装饰，那么它只会初始化一次，不管它在哪里定义的。通常用于全局系统初始化.@pytest.fixture(scope='session', autouse=True)def before(request): print ("session start")def test_browser(my_session_enginie_chrome, before): browser = my_session_enginie_chrome browser.get("https://wwww.baidu.com") assert 1==1#整个module用，在这个module范围内可以用。@pytest.fixture(scope='module', autouse=True)def before(request): print ("before start--%s" % request.module.__name__)def test_browser(my_module_enginie_firefox, before): browser = my_module_enginie_firefox browser.get("https://wwww.baidu.com") assert 1==1# 每个test都会运行。@pytest.fixture(scope='function', autouse=True)def before(request): print ("before start--%s" % request.function.__name__)def test_browser(my_function_enginie_chrome, before): browser = my_function_enginie_chrome browser.get("https://wwww.baidu.com") assert 1==1 fixture的存在使得我们在编写测试函数的准备函数、销毁函数或者多个条件的测试提供了更加灵活的选择。autouse的scope含义如下： autouse fixtures obey the scope= keyword-argument: if an autouse fixture has scope=’session’ it will only be run once, no matter where it is defined. scope=’class’ means it will be run once per class, etc.if an autouse fixture is defined in a test module, all its test functions automatically use it.if an autouse fixture is defined in a conftest.py file then all tests in all test modules below its directory will invoke the fixture. 好了讲到这里，谁还认为pytest不够强大的？！ pytest绝对是你开展功能自动化测试，接口自动化测试的利器，希望大家都可以用起来！]]></content>
      <categories>
        <category>automation</category>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>自动化测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python接口测试框架实践]]></title>
    <url>%2F2018%2F07%2F30%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2FPython%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[两，三年以前给大家分享过如何用jmeter做接口测试，但工具毕竟有限制，所以在真实的项目中，大家还是用自研的框架多。我之前写过一个简单的基于unittest+request的接口测试框架，也分享给大家过，最近在免费直播中我也有讲到，但直播毕竟讲不透彻，还是有很多同学不是特别清楚，到底如何做一个接口测试框架，今天我们再次详细解释下，如何生成自己的接口测试框架。 关于接口测试，基本概念请点击这里,接口测试我们一般先手工做，然后再自动化，无论手工还是自动化，接口测试的步骤都大致如下： 根据接口文档/规范及接口功能来设计测试用例，设计法则参考黑盒测试和白盒测试方法。 准备测试数据，用工具（Postman， fiddler， soapui等）或代码（python+requests或其它语言），根据测试用例构造请求，发请求。 检查服务器返回的结果。 包括状态码和返回值的检查。 各种合法非法的请求接口能否正确处理，要特别注意安全性（仅前端校验，后端忘记校验），authentication，性能（特别是并发），数据一致性，完整性方面（幂等）的问题。 接口测试的检查点，一般如下： 手工如何测试，很清楚了，那么我们讲接口测试自动化框架，从哪里开始呢？ 既然是自动化，那么就必须不需要人工干预，框架如何做到不需要人工干预呢？窃以为有如下方面： 用例的自动收集 就是要自动接受用户输入，自动分析并查找待跑用例。什么意思呢？你跑自动化时候，一般需要指定跑那些case，这些case属于哪个类别（regression， smoke， unit test？）框架需要能根据用户输入快速找到要跑到用例集，并把它加到待跑用例的列表里。如果你不指定，框架会跑默认文件夹下的用例集。 用例的运行方式 就是组织查找到的用例集合，你想怎么运行？ 顺序执行还是并发执行，执行过程中要不要记log，有错误是要继续还是要停止运行？运行失败要不要重新跑一遍？执行完毕后要不要收集执行结果？ 测试报告 所有用例执行完毕后需要有整个运行情况的报告，包括整体运行结果，执行的用例列表，用例中成功百分比，失败百分比，失败的用例，框架有没有在它发生错误的时候截图？有没有记log，在失败的用例上点击用例名称，能不能通过链接的方式快速定位截图，log？ 你想要txt格式的报告还是更user friendly的HTML格式？ 前面3部分有了，一个测试框架的壳子就出来了，但还不够好，还需要加上： 自动触发运行 何时运行这个框架？每次有代码改动？发版前？还是每日定时？ 环境配置 基本上公司的测试环境不可能只有一个，那么如何配置同样的脚本跑在不同的环境上？ Data provider (数据生成) 环境不一样，测试数据不能一样吧？如何提供不同环境的数据且不更改自动化代码？ 邮件发送 自动化测试结束后自动发送测试报告到相应人的邮箱。 日志，错误处理 运行中记录运行情况，错误情况及出错后的处理。 下面，我们就以我实现的EasyAPIFramework（Python＋Unittest＋HTMLTestRunner）为例，详细说明下框架是如何一步步搭建起来的。 Unittest。unittest是python语言里使用最广泛的一个框架，看名字就知道它本来做unit test用的，但因为太强大了，所以也被拿来做功能自动化，接口自动化。 unittest有四个重要的概念： 1.test fixture represents the preparation needed to perform one or more tests(setup, teardown)。 setUp(): 每次执行测试用例之前调用。无参数，无返回值。该方法抛出的异常都视为error，而不是测试不通过。没有默认的实现。tearDown(): 每次执行测试用例之后调用。无参数，无返回值。测试方法抛出异常，该方法也正常调用，该方法抛出的异常都视为error，而不是测试不通过。只用setUp()调用成功，该方法才会被调用。没有默认的实现。通过setup 和 tesrDown组装一个module成为一个固定的测试装置。注意：如果setup运行抛出错误，则测试用例代码则不会执行。但是，如果setpu执行成功，不管测试用例是否执行成功都会执行teardown。 2.test case 独立测试的单位，一般一个testcase完成一个功能。注意两点： (1).testcase通常继承自测试类，测试类一般继承自unittest.TestCase。测试类里通常实现了setup(), teardown(), 及测试用例。 (2).test case要以test开头。 3.test suite A test suite is a collection of test cases, test suite。通常用来聚合测试用例， 并且test suites可以嵌套。 4.test runner A test runner is a component which orchestrates the execution of tests and provides the outcome to the user.运行测试用例的驱动类，可以执行TestCase，也可执行TestSuite。执行后TestCase和Testsuite会自动管理TestResult。简单来说就是run（），里面就是手工测试的步骤代码化。 除了上述概念，unittest里还有几个概念需要你知道： 5.TestLoder：是用来加载 TestCase到TestSuite中，其中有几个loadTestsFrom_()方法，就是从各个地方寻找TestCase，创建他们的实例，然后add到TestSuite中，再返回一个TestSuite实例 6.TextTestRunner：是来执行测试用例的，其中的run（test）会执行TestSuite/TestCase中的run(result)方法。 7.TextTestResult：测试结果会保存到TextTestResult实例中，包括运行了多少用例，成功与失败多少等信息 一般来说，unittest执行测试的流程如下： 创建好TestCase，然后由TestLoader加载（也可以用TestDiscover指定文件夹的方式Load）TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，整个过程集成在unittest.main模块中。 下面我们举个例子来看下，一个简单的unittest的测试用例长什么样子：好，看上图，这里我实现了一个测试类，它继承了unittest.TestCase.然后再测试类里实现了setup(), test_XXX(), teardown()方法，有的测试方法上我加个了@unittest.skip(). 说这个什么意思呢？我开始说测试框架要实现查找测试用例集，unittest帮我们把测试用例标记好了，所有的测试用例要以test开头，当你调用TestLoder（defaultTestLoader()类，通过该类下面的discover()方法可自动根据测试目录start_dir匹配查找测试用例文件（test*.py），并将查找到的测试用例组装到测试套件）查找测试用例集的时候，所以test开头的会被自动加入测试用例集。哪些被标记为unittest.skip（）的则不会。 第2，我想实现跑某些用例，怎么办呢？unitest 不支持按照标签运行，但是它提供了testsuite概念，你可以把一个测试类的几个测试用例添加到testsuite里。这样unitest就实现了框架的第一要素，测试用例集的查找。 那么用例集查找好了，你定义的test_XXX()的方法最终都会在TextTestRunner的run（）方法中被执行到。也就是说，通过TextTestRunner我们实现了用例的顺序执行。（并发执行unittest貌似不支持，并发执行可以用pytest）看，利用unittest我们可以轻易开发出一个测试用例并实现了用例收集和用例执行。 那么测试报告如何生成呢？我们可以借助HTMLTestRunner来实现。 HTMLTestRunner is an extension to the Python standard library’s unittest module. It generates easy to use HTML test reports下载地址:(http://tungwaiyip.info/software/HTMLTestRunner.html), 下载好后放到放在C:\Python37\Lib目录下。具体用法参考我代码，稍后放出。 好， 有了unittest +HTMLRunner，测试框架所需要的１２３就有了，后面的６到８（自动触发运行，环境配置，Data provider (数据生成)，邮件发送，日志，错误处理），其中（自动触发运行，环境配置，邮件发送）可以通过集成Jenkins的方式实现， Data provider (数据生成)，日志，错误处理，需要我们代码实现。 我们再回过来看这个简单的框架这个框架分了几个部分（以前写的英文版我就不翻译了哈）： “Common”: –Common methods to facilitates the whole project. html_report: To generate HTML report after test cases run.shared_api: Import method like post/get to serve all the API requests.txt_report: Independent way to run all the cases under test and generate simple txt format report. 主要来说就是一些公用的library，包括如对selenium的二次封装（web自动化），对API调用的二次封装（API自动化），datadriven读文件方法及项目所用到的公用库文件。shared_api里包含了我对requests的封装，其实，针对webservices（一般为？wsdl文件）的API，也可以写个公用方法包括在内，可以看看它长什么样子： 如果你要做web自动化框架，那么就写个Selenium_helper，包括你所有对selenium的wrap方法，然后你在测试类的setup（）， teardown（）两个类下调用（看出来了吧，框架本身应该和什么类型的测试无关，框架就是用来帮你组织你的测试用例的）。 “Page”: –The page under test. in this file, only store the page related function/method/datetest case related to this page should not be included here.different page should have separated pages. 真正你要测试的项目（如果是功能自动化，你需要利用page object模式实现页面元素，和定位元素的loactor分离（其实测试数据，逻辑，业务都应该分离并可重用））。一个完整的页面或功能我们组织在一起叫一个page，这个page应该包括这个页面的元素，及针对元素的操作，但测试业务逻辑不般不包括。 一个page通常是什么样子呢？ “Settings”: –Global settings &amp; configuration &amp; global data. init:data_source: all the account, common test data.test config: environment, domain or other common config. 这里就是整个项目的配置文件，包括数据配置也可以放置在内，一般会有变量来接受来自jenkins的环境变量。如果没有就设置default值。 Test_config里应该包含你测试的数据，不同环境区分开，也可以写到外部excel或者xml了，然后利用common方法里的datadriven方法读出。 我们就是通过这个来实现环境及数据的切换。 “test” – Test cases inherited from pages, this is the cases under test. each test file should have a page file accordingly.framework will only search the cases under this folder 就是你测试类和测试方法所在，通常你测试类的名称要和你测试对象的名称一样，只是在前面加test（注意unittest只有以test开头的测试用例才会被执行）。 注意，setup（）应该包括测试用例的数据准备（比如你需要打他driven，这次的数据就应该包括进来），还有selenium调用及browser的initial（针对web功能自动化），requests接口的初始化（API自动化）等。teardown（）里，要做好相应的销毁动作。 “main” – Load &amp; run all of the test cases defined in test folder. System will automated search all the test method defined in test folder and run them. 当然你也可以通过TestDiscover及testsuite的addTest来筛选你需要执行的用例，我简化为搜索所有test文件夹下的用例了（直接利用discover方法）。 好了，到这里为止，我们就实现了一个基本的接口测试框架，是不是感觉非常简单啊？如果你对代码感兴趣，接口框架代码可以参考：Github 其实，在真正的项目实践中，要考虑到比这个要复杂的多，起码并发执行我们没实现啊，数据驱动我们也没实现。失败rerun也没有。后续我会重新实现一个开源的接口测试框架给大家，把我提及的全部功能都实现，当然，大家也可以直接选用pytest，我后续也会写下pytest教程，敬请期待。]]></content>
      <categories>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>自动化测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的字符串相关面试题--再探]]></title>
    <url>%2F2018%2F07%2F17%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%2F%E7%AE%97%E6%B3%95%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98--%E5%86%8D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[上次分享了一道有趣的字符串面试题，今天我们再重新审视下这道题，并借此机会了解下python库的强大。 上次的原题是这样的: 给定一个字符串，求字符串中连续相同的字符的个数， 例如给定字符串“abbcccdxt”，输出[‘a1’,’b2’,’c3’,’d1’,’x1’,’t1’]。我原来的解决方法如下：123456789101112131415161718def count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return base = s[0] result = [] count = 1 for i in s[1:]: if i == base: count +=1 else: result.append(base+str(count)) count =1 base = i result.append(base + str(count)) return resultprint(count_s('abbcccdxt')) 后来有同学在评论中指出，有更好的解决方案，我们使用下看看。1234567891011121314from collections import OrderedDictdef count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return d = OrderedDict() for _ in s: if _ in d.keys(): d.update(&#123;_:d[_]+1&#125;) else: d.update(&#123;_: d.setdefault(_, 1)&#125;) return list(map(lambda x: x +str(d[x]), d)) print(count_s('abbcccdxt')) OrderedDict The OrderedDict API is substantially the same as regular dictionaries but will iterate over keys and values in a guaranteed order depending on when a key was first inserted. If a new entry overwrites an existing entry, the original insertion position is left unchanged. Deleting an entry and reinserting it will move it to the end. Usage 1234567d = OrderedDict()d['parrot'] = 'dead'd['penguin'] = 'exploded'd.update(&#123;'foo': 'bar'&#125;)print(d.items())#output:odict_items([('parrot', 'dead'), ('penguin', 'exploded')]) dict.setdefault(key, default=None) 如果字典中包含有给定键，则返回该键对应的值，否则返回为该键设置的值 map(function, iterable, …) map() 会根据提供的函数对指定序列做映射。第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。 2。 上题我们来变形下，我要求得出如下结果 [‘aa’, ‘bb’, ‘ccc’, ‘d’, ‘x’, ‘t’]123456789101112from collections import OrderedDictdef count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return d = OrderedDict() for _ in s: if _ in d.keys(): d.update(&#123;_:d[_]+1&#125;) else: d.update(&#123;_: d.setdefault(_, 1)&#125;) return list(map(lambda x: d[x]*x, d))print(count_s('abbcccdxt')) 3。 我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’。‘bb’由于字符数2个相同不打印出123456789101112from collections import OrderedDict def count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return d = OrderedDict() for _ in s: if _ in d.keys(): d.update(&#123;_:d[_]+1&#125;) else: d.update(&#123;_: d.setdefault(_, 1)&#125;) return list(map(lambda x: x*d[x],filter(lambda x: True if d[x]==3 else False , d))) print(count_s('abbcccdxt')) filter(function, iterable) filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 4。 最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”,我们会得到’abc’, ‘bcc’, ‘ccb’, ‘cbb’, ‘bbc’, ‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。12345678from collections import Counterdef count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return return [s[number:number+3] for number in range(len(s)-2)]print(Counter(count_s('abccbbcc'))) 这个题目，有各种变形，比如我现在要求出字符串的所有子集， 例如 给你‘123’我要得到[[‘1’], [‘2’], [‘3’], [‘1’, ‘2’], [‘2’, ‘3’], [‘1’, ‘2’, ‘3’]]12345678910def count_s(s): if len(s) &lt;= 0 or not isinstance(s, str): return r = [] for i in range(len(s)): for item in [s[number:number + i+1] for number in range(len(s) - i)]: r.append(list(item)) return rprint((count_s('123'))) 怎么样，这一圈下来明白python的标准库有多强大了吧， 作为一个pythoner，一定要足够pythonic.]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口测试入门及进阶]]></title>
    <url>%2F2018%2F07%2F16%2F%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[本文是功能测试进阶系列直播课程第3讲，接口测试入门及进阶。 请至公众号 TesterTalk 查看详细内容。 RPC:远程过程调用。RPC的核心并不在于使用什么协议。RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。RPC的原理主要用到了动态代理模式，至于http协议，只是传输协议而已。 RPC是一个软件结构概念，是构建分布式应用的理论基础。就好比为啥你家可以用到发电厂发出来的电？是因为电是可以传输的。至于用铜线还是用铁丝还是其他 种类的导线，也就是用http还是用其他协议的问题了。 RESTful ： 简称 REST,是描述了一个架构样式的网络系统，其核心是面向资源，REST专门针对网络应用设计和开发方式，以降低开发的复杂性，提高系统的可伸缩性。REST提出设计概念和准则为： 1.网络上的所有事物都可以被抽象为资源(resource) 2.每一个资源都有唯一的资源标识(resource identifier)，对资源的操作不会改变这些标识 3.所有的操作都是无状态的 REST – REpresentational State Transfer 直接翻译：表现层状态转移。一句话概括很精辟：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。 REST不是”rest”这个单词，而是几个单词缩写。 但即使那几个单词说出来，也无法理解在说什么 -_-!! （不是要贬低人，是我自己也理解困难）；1.REST描述的是在网络中client和server的一种交互形式；REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）； Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。比如：http://api.qc.com/v1/newsfeed: 获取某人的新鲜;http://api.qc.com/v1/friends: 获取某人的好友列表;http://api.qc.com/v1/profile: 获取某人的详细信息; 用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。比如：DELETE http://api.qc.com/v1/friends: 删除某人的好友 （在http parameter指定好友id）POST http://api.qc.com/v1/friends: 添加好友UPDATE http://api.qc.com/v1/profile: 更新个人资料禁止使用： GET http://api.qc.com/v1/deleteFriend 看Url就知道要什么看http method就知道干什么看http status code就知道结果如何]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>测试感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试入门与进阶]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[本文是功能测试进阶系列直播课程第2讲，自动化测试入门与进阶。 请至公众号 TesterTalk 查看详细内容。 大家晚上好，能在周日晚上8点还来听直播的人，都是比较自律的人，感谢你们的到来。今天是我们手工测试进阶的第2讲–自动化测试入门与进阶。 对于大多数手工测试人员或者说不会自动化的人来说，自动化测试显得很神秘，很高大上，很难。很多人想学又没有信心，学几天遇到问题就放弃的大有人在。其实自动化测试也是每一个初入职场的年轻人要跨越的一个坎儿，就像你年轻时想玩而又没玩过的游戏，想追但又追上的姑娘。 在你没得到的时候，你愿意倾其所有沉溺其中，这个是好事儿，特别对年轻人来说，有的追比没的追要好。但切忌不要把自动化当作你的日思夜想的女神，你把它抬的越高，你就越渺小。等你过了这个阶段，你就会发现，女神也会上厕所，自动化也发现不了新bug。 好，讲这个主要是为了说明，自动化测试不是什么金枝玉叶，所谓和尚摸得，我阿Q也摸得。没了这层畏难的情绪，自动化学起来就容易多了。 大家都知道，追姑娘要潘驴邓小闲，做自动化我认为也得要5个要素，我总结下，就是势力大过天：势 – 就是势力的势。 大家普遍认为该上自动化了/手工测试确实已经满足不了项目需要了。力 – 就是势力的力。 团队成员有技术实力，能搞起来，起码有个带头的。大 – 就是大。 老板知情，并支持。这样才能有钱有资源。过 – 就是功过的过。自动化肯定不是一番风顺，做成做不成，功未必有，过一定少不了，有提早有意识并能承受。天 – 就是每天的天。自动化不是做好了就放那里了， 要天天看，有错误要及时debug，要随时更新，保持有效。 大家都看过 《google软件测试》这本书吧，google里unit test占比大约在70%，API test占比在20%作用，剩下的10%在UI自动化。这个也符合自动化分层理论，（放图）， 大家可以看到这个模型，UI自动化仅仅占据了很小的一部分， 下次分享我会讲下API如何做自动化。 其实UI自动化测试的最大挑战就是元素识别，元素识别到了，后续操作就简单了，而掌握元素识别，需要你对 XPATH，CSS等一些HTML基础知识有所了解，要想使用好，就要对javascript， jquery有所了解，这些都需要平常的积累和有针对性的练习。 再说两个常见问题： 元素要达到某个条件才显示display:none 改变页面元素显示状态， block2.弹出框问题：看我公众号文章，一劳永逸。 以上就是我今天的分享，毕竟，语音和图片类型的直播由于条件限制不能直接给大家演示代码，自动化方面的常见问题及解答，大家可以去我公众号看看， 直接回复 “自动化测试” 就可以。我的公众号是 TesterTalk。]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论测试人员的核心竞争力]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F%2F%E8%AE%BA%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[本文是功能测试进阶系列直播课程第1讲–论测试人员的核心竞争力，直播脱水版。 更详细内容， 请至公众号 TesterTalk 查看。 今天我分享的主题是“论测试人员的核心竞争力”？ 那么我先问下大家，你们觉得测试人员的核心竞争力是什么？ 有的说，发现bug的数量，有的说开发能力，有的说业务能力。那么，我，蔡老师，是怎么想的呢？ 我在抛出我的观点前，先跟大家分享一个故事。 三国演义，大家都知道吧？ 刘关张桃园三结义，创下了一段历史经典，也开创了一个帝国。 那么，我问一个问题，为什么卖草鞋的刘备能当大哥？腰缠万贯的地主张飞只能做小弟啊？我们再来看， 桃园三结义的地点是哪里？张飞的一处庄园。祭祀用的牛羊哪里来的？张飞买的。结义完，打黄巾军要招募人才，怎么招募的？ 张飞散尽家财。你说，同样是屠夫，为什么人家隔壁水浒传里的郑屠还能欺行霸市，强抢民女，我张飞只能把自己卖了，还给人数钱啊？ 说到这里，有朋友可能有不同意见，说刘备乃中山靖王之后，出场自带BGM，那好，我们先放过这个大耳贼，就说卖枣子的那位吧？论长相，面若重枣，这个职业生涯都写在脸上了。咱们张大官人， 糙是糙了点，起码面部没有明显缺陷。论职业，关二哥属于小本经营，连个铺面都没有。 咱们张大官人，做屠夫可是庄园好几处了。论能力，关二哥可以温酒斩华雄，咱张大官人可是能百万军中取上将之头， 况且，这句话还是关二哥对曹操说的，你琢磨琢磨，CEO夸你，小样，技术不错嘛，你说，不行不行，张大官人可比我厉害多了。那个更牛逼啊？可以说，要不是爱舞蹈弄枪，咱张大官人也能像隔壁西门大官人那样，天天当新郎，夜夜入洞房了。 对吧？ 那凭什么我这么牛逼确给别人当小弟呢？大耳贼卖个草鞋就能取东吴公主？凭的就是双手过膝的刘备掌握了乱世成功的核心竞争力， 而咱们小资产阶级的张大官人，也只能牵马坠蹬，任其驱使。 那么，我们测试，要想开创一番事业，应该掌握的核心竞争力是那个呢？ 在我看来，只有一条 ： “持续提升团队效率”。 为什么测试核心竞争力是持续提升团队效率啊? 你想啊，老板是开公司的，开公司是为了干嘛？赚钱,对吧，那么怎么赚钱？卖产品，卖服务？产品和服务如何能卖出去？产品和服务必须要质量好，质量达标了才谈得上其它，对吧？那么如何把产品和质量搞好？ 开发敬畏每一行代码， 产品研究透用户需求和痛点， 那么测试呢？ 能做什么？测试作为开发流程的一部分，是不是要从规范流程，提出问题，验证方案，观察效果，来倒逼着团队改善啊？ 那么，这个活动本身，总结一下，是不是就是持续提升团队效率？！！ 好了，现在大家都没有异议了， 我们来看，如何持续提升团队效率？ 既然要提升团队效率， 那么我们就得搞明白团队是怎么运作的。（放图片， 讲解）那么， 我们看，对于处于不同阶段的团队，对于团队成语来自不同地方，外部和内部的团队，我们测试还能不能用同一套方法来提升效率啊？ 不能吧？2.什么是效率。（放图片， 讲解）。 AB两个人，同样的工作，完成的时间不同， 谁效率高？ 是不是时间短的效率就高？ 那么A的工作业务一变化就要重构，B的永远不要改呢？这个时候谁的效率高？效率总要结合自己公司情况的。3.确定好了团队，效率，就相当于，你知道了你要去哪里，你也知道了到那里后要干什么。 现在就是怎么到那里的问题了。毛主席说过，要战略上藐视敌人，战术上重视敌人。 那么这个战术是什么呢？就我的理解来看，可以分成以下几个部分：1.思想篇。（放图片， 讲解）。 古人云，发上等愿，做中等事，结下等果。 如果测试的思想仅仅局限于测试，你就只能在测试的小圈圈里打转，就不可能获得全局的视野。2.技能篇。（放图片， 讲解）。 关羽的赤兔马，吕布的方天画戟，我们的业务， 代码， 和自动化。 每一个都不能少。讲沟通时候，放“俺也一样”图片。3.影响篇。俗话说，三人成虎。 一件事情，说的人多了就成了真的， 那么我们测试就要不停的影响周边的人，让更多的人参与到改善质量的行列中来，那么我们能发挥影响的范围就会越来越大。 （放图片， 讲解） 最后，人的能力千差万别，有的人一出场就是带头大哥， 有的人拼死拼活也只能给人当小弟。 我们无需羡慕，只需做好自己就行。 就像我看动漫，我永远不喜欢粉主角， 灌篮高手里我喜欢看三井寿对梦想的坚持， 火影忍者里我欣赏甚至羡慕Rock li对超越自己的极致追求。 至于你想当月亮还是愿做萤火虫，都是个人的选择而已。最后一首小诗结束今天的分享：天下风云出我辈一入江湖岁月催王图霸业笑谈中不胜人生一场醉。 谢谢大家。，谢谢大家的支持！ 最后的最后，最关键的没说。 大家可以关注我的公众号 Testertalk ， 我会持续分享软件测试的技术.]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>测试感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的字符串相关面试题]]></title>
    <url>%2F2018%2F07%2F02%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%2F%E7%AE%97%E6%B3%95%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[面试过程中， 算法几乎变成了一个逃不过去的坎儿， 而在算法的面试中， 关于字符串的问题很常见，也很基础，今天我们就来讲几个非常有代表意义的面试题。 1。 给定一个字符串，求字符串中连续相同的字符的个数， 例如给定字符串“abbcccdxt”，输出[‘a1’,’b2’,’c3’,’d1’,’x1’,’t1’]123456789101112131415161718def count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return base = s[0] result = [] count = 1 for i in s[1:]: if i == base: count +=1 else: result.append(base+str(count)) count =1 base = i result.append(base + str(count)) return resultprint(count_s('abbcccdxt')) 2。 上题我们来变形下，我要求得出如下结果 [‘aa’, ‘bb’, ‘ccc’, ‘d’, ‘x’, ‘t’]123456789101112131415161718def count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return base = s[0] result = [] count = 1 for i in s[1:]: if i == base: count +=1 else: result.append(base*count) count =1 base = i result.append(base *count) return resultprint(count_s('abbcccdxt')) 3。 我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’，‘bb’由于字符数2个相同不打印出1234567891011121314151617181920def count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return base = s[0] result = [] count = 1 for i in s[1:]: if i == base: count +=1 else: if count ==3: result.append(base*count) count =1 base = i if count == 3: result.append(base * count) return resultprint(count_s('abbcccdxt')) 4。 最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”,我们会得到’abc’, ‘bcc’, ‘ccb’, ‘cbb’, ‘bbc’, ‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。1234567from collections import Counterdef count_s(s): if len(s)&lt;=0 or not isinstance(s, str): return return [s[number:number+3] for number in range(len(s)-2)]print(Counter(count_s('abccbbcc')))]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Headless实现无UI自动化]]></title>
    <url>%2F2018%2F06%2F28%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2F%E5%88%A9%E7%94%A8Headless%E5%AE%9E%E7%8E%B0%E6%97%A0UI%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在做自动化的时， 偶尔你需要打开一个页面获取某些字段，但由于某些原因（通常是安全）， 你又不想这个页面展示出来， 这个时候，不打开浏览器而使用浏览器就是刚需了。我本来以为这个是很基础的知识，这两天一直有人问，那么就干脆写下来吧。 Headless的浏览器我们以前经常用PhantomJS， 但随着google宣布支持headless后， PhantomJS也停止更新了，那么是时候使用headless了。 什么是Headless chrome呢？ Headless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序。相比于现代浏览器，Headless Chrome 更加方便测试 web 应用，获得网站的截图，做爬虫抓取信息等。相比于出道较早的 PhantomJS，SlimerJS 等，Headless Chrome 则更加贴近浏览器环境. Headless有什么好处呢？ 最直观的就是由于不需界面，所以速度上比普通浏览器稍快，也不会因为误操作界面导致人为错误。 另外，headless在爬虫程序，和网页截图时也经常用。 如何使用？ chrome 的headless模式实现起来很简单，无需下载， 只要你运行的机器上有最新版的chrome即可（事实上59版本以后都支持）， 当然了你需要crhome driver在你python安装路径的根目录下。。下面我们以百度首页为例，打印出搜索框的文本“百度一下”。 123456789options = webdriver.ChromeOptions()options.add_argument('--headless')options.add_argument('--disable-gpu')driver = webdriver.Chrome(chrome_options=options)driver.get("http://baidu.com")time.sleep(1)print(driver.find_element_by_xpath(".//*[@id='su']").get_attribute("value")) 是不是很简单？全程没有看到网页被打开，但是我们还是获得了我们需要的元素。 事实上， headless 不仅仅chrome支持， firefox也支持。用法如下：1234567891011import timefrom selenium import webdriveroptions = webdriver.FirefoxOptions()options.add_argument('--headless')options.add_argument('--disable-gpu')driver = webdriver.Firefox(firefox_options=options)driver.get("http://baidu.com")time.sleep(1)print driver.find_element_by_xpath(".//*[@id='su']").get_attribute("value")]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门 --打造网站自生成系统（二）]]></title>
    <url>%2F2018%2F06%2F24%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上篇我们讲了下爬虫的基础知识，通过上篇的学习，我们已经知道了如何打造自己的爬虫，那么这篇讲下如何把下载好的内容生成到网页中并发布。 hexo 安装https://hexo.io/zh-cn/docs/index.html proxy：https://pypi.org/project/scrapy-rotating-proxies/]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门 --打造网站自生成系统（一）]]></title>
    <url>%2F2018%2F06%2F24%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[以前IT界流传着一句笑话：”当你一个朋友忽然消失了的时候，他不是去了华为就是去了阿里”。 对于没有在这两个宇宙大厂的我来说，这么长时间没消息，要么我弃坑不更了，要么折腾新玩意儿去了。弃坑是不可能弃坑的，所以当你感叹这么好的公众号怎么也弃坑的时候，我都会拿一个新玩意儿来取悦你 ：） 爬虫其实不算是新的东西了， 网上也有很多的教程，都很详尽，那么我为什么还要拿出来说呢？因为我发现大多数教材都是教你如何从网络上爬取内容，然后就结束了。 但是我们爬下来的内容是要使用的啊？这方面的就很少。还记得我之前分享过的博客开发系列吗？正好，我们把这两个结合起来，一起来看看，如何用爬虫打造专属自己的自动化博客生成系统。 本系列分为如下模块：1.介绍爬虫框架scrapy的原理，及简单使用。2.自动分析爬取的文章，分类并转化格式为适合博客的markdown格式。3.自动发布博客，并介绍如何绑定域名。4.每天躺在床上看自己的博客“更新”。 今天我们先看第一个， 爬虫框架Scrapy。 首先，爬虫是什么呢？ 爬虫的原理是什么？爬虫是一个程序，用来获取网站的信息。 爬虫的原理一般是根据一定的分析算法找出用户想要的URL，放到一个队列里，然后按照一定的策略选择进一步要抓取的URL，直到满足停止条件。 然后对所有抓取的网页进行分析，过滤，存储并建立索引，方便后续查询，检索。 什么是scrapyScrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。 scrapy原理 （此部分为官网文档，及网络摘抄）Scrapy 使用了 Twisted异步网络库来处理网络通讯。整体架构大致如下（绿线是数据流向）： 各部分详细说明如下： 一此完整的运行流程如下： 如何安装1pip install scrapy 入门教程（官网摘取架构各部分作用，个人提供练习）创建项目在开始爬取之前，您必须创建一个新的Scrapy项目。 进入您打算存储代码的目录中，运行下列命令:1scrapy startproject _myspider12345scrapy.cfg 项目的配置信息，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中）items.py 设置数据存储模板，用于结构化数据，如：Django的Modelpipelines 数据处理行为，如：一般结构化的数据持久化settings.py 配置文件，如：递归的层数、并发数，延迟下载等spiders 爬虫目录，如：创建文件，编写爬虫规则 定义ItemItem 是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。 类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field 的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单) 首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 _myspider 目录中的 items.py 文件:123456import scrapyclass MyspiderItem(scrapy.Item): title = scrapy.Field() link = scrapy.Field() desc = scrapy.Field()一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义。 编写第一个爬虫(Spider)Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。 其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。 为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。 以下为我们的第一个Spider代码，保存在 _myspider/spiders 目录下的 mine.py 文件中:我们要从10tiao.com这个网站爬取首页上的所有公号文章，并按照如下方式保存1&#123;"author": "作者：谢宝友", "create_date": "2018-05-24 13:21", "name": "GitChat精选"， content：...&#125; start_requests 这个请求接收需要爬取的第一个页面，然后交给parse（）处理，123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-import jsonimport scrapyfrom scrapy import Selectorfrom _myspider.items import MyspiderItemclass QuotesSpider(scrapy.Spider): name = "quotes" def start_requests(self): # start_requests这个函数也可以不要，只要有start_urls = [。。]即可。 url = "http://10tiao.com" yield scrapy.Request(url, self.parse) def parse(self, response): info = MyspiderItem() for i in response.xpath(".//*[@id='id-content-wrap']//article"): info["name"] = Selector(text=i.extract()).xpath("//*[@id='id-author-name']//text()").extract()[0] info["title"] = Selector(text=i.extract()).xpath("//a//text()").extract()[0] #此url为了抽取标题下面的正文内容，url获取后，交给callback函数进一步处理。 url = Selector(text=i.extract()).xpath("//h1[@class='post-title text-left']/a/@href").extract()[0] #注意meta，用来传递值到下一个处理函数。 yield scrapy.Request(url, meta=&#123;'info1':info&#125;, callback=self.parse_url_contents) def parse_url_contents(self, response): info = MyspiderItem() info1 = response.meta['info1'] for i in response.xpath(".//*[@id='img-content']"): #Scrapy提供了Selector选择器供我们筛选出目标选项。具体请参考Selector文档 info['create_date'] = Selector(text=i.extract()).xpath("//*[@id='post-date']/text()").extract()[0] info['author'] = Selector(text=i.extract()).xpath("//*[@id='author']/text()").extract()[0] info['content'] = Selector(text=i.extract()).xpath("//*[@id='js_content']").extract()[0] info["name"] = info1["name"] yield info 注意：Request中meta参数的作用是传递信息给下一个函数，使用过程可以理解成：把需要传递的信息赋值给这个叫meta的变量，但meta只接受字典类型的赋值，因此要把待传递的信息改成“字典”的形式，即：meta={‘key1’:value1,’key2’:value2} 如果想在下一个函数中取出value1,只需得到上一个函数的meta[‘key1’]即可，因为meta是随着Request产生时传递的，下一个函数得到的Response对象中就会有meta，即response.meta，取value1则是value1=response.meta[‘key1’] 存储结果（Pipeline）Item pipeline 的主要责任是负责处理 spider 抽取的 Item，主要任务是清理、验证和持久化数据。当页面被 spider 解析后，将被发送到 pipeline，每个 pipeline 的组件都是由一个简单的方法组成的Python类。pipeline 获取Item，执行相应的方法，并确定是否需要在 pipeline中继续执行下一步或是直接丢弃掉不处理。123456789101112import jsonimport codecsclass MyspiderPipeline(object): def __init__(self): #这里简单的保存到result.json文件里。 self.file = codecs.open('result.json', 'wb', encoding='utf-8') def process_item(self, item, spider): line = json.dumps(dict(item), ensure_ascii=False) + "\n" self.file.write(line) return item 激活Item Pipeline组件在settings.py文件中，往ITEM_PIPELINES中添加项目管道的类名，激活项目管道组件123ITEM_PIPELINES = &#123; '_myspider.pipelines.MyspiderPipeline': 300,&#125; 运行爬虫123scrapy crawl quotes #quotes是你在spider里定义的爬虫名字。你也可以把运行的结果dump到文件里：scrapy crawl quotes -o result.json 写在最后 看下我们的运行结果， result.json节选：12345#为了排版方便，我把content里的内容注释掉了。&#123;"author": "Google Play", "create_date": "2018-05-24 13:00", "name": "GitChat精选"&#125;&#123;"author": "张 璁", "create_date": "2018-05-24 13:34", "name": "GitChat精选"&#125;&#123;"author": "机器之心", "create_date": "2018-05-24 12:23", "name": "GitChat精选"&#125;&#123;"author": "机器之心", "create_date": "2018-05-24 12:23", "name": "GitChat精选"&#125; 是不是很简单？确实简单， 爬虫的爬取，收集信息比较直观，但是爬虫最重要的的问题就是经常被ban，至于如何解决，目前没有一劳永逸的方法，读者朋友们可以网络上搜索解决。 本文未涉及登录问题有些网站需要登录获取authentication token后才能继续爬取（我比较喜欢这个，方便控制）， 有两个办法，一个是用requests直接发请求获取后保存使用。第二scrapy貌似提供了登录的方法，这个我还没有研究， 大家可以自行研究。]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫入门 --打造网站自生成系统（零）]]></title>
    <url>%2F2018%2F06%2F06%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97%2F%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E9%9B%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[以前IT界流传着一句笑话：”当你一个朋友忽然消失了的时候，他不是去了华为就是去了阿里”。 对于没有在这两个宇宙大厂的我来说，这么长时间没消息，要么我弃坑不更了，要么折腾新玩意儿去了。弃坑是不可能弃坑的，所以当你感叹这么好的公众号怎么也弃坑的时候，我都会拿一个新玩意儿来取悦你 ：）首先，请大家web浏览器或者手机浏览器输入 qahome.cn 看看这个网站。很普通嘛，甚至还有些许bug，但是如果我告诉你，这个网站，包括网站布局，内容，都是自动生成的呢？如果我再告诉你，这个网站还有”生命“， 会自动发布新文章并分门别类呢？ 是不是有点技术含量了啊？ 这个就是最近阶段我的所学成果 – 网络爬虫。 简单来说，我做了如下事情: 代码自动抓取用户感兴趣的内容。 内容抓下来后，自动清洗，排版，转换格式，加私货，然后保存。 结合网站模板自动发布。 你只需天天躺在家里看你的网站更新即可。 后面我会抽出时间详细普及下爬虫及爬虫框架，敬请期待！]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求1000以内的素数]]></title>
    <url>%2F2018%2F04%2F24%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%2F%E7%AE%97%E6%B3%95%2F%E6%B1%821000%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[算法问题逐渐成为面试题里的必考题目，但大多测试人员都对其不太重视，笔者也是如此，故决定开一个系列，不定期分享一些算法题目。今天来看一道经典的面试题，求1000内的素数。 素数定义：除了1和它本身之外再不能被其他数整除的自然数。 ##算法思想： 第一种解法 – 直接根据素数定义来，对于给定的数n，拿1～n-1的数去除n，只有n不能被任一个数整除，n才是素数。1234567891011121314def prime(n): for i in range(2, n): #1不是素数，所以循环从2开始 if n%i ==0: return False return Truedef get_prime(x): r_list = [] for n in range(2, x+1): #1不是素数，所以循环从2开始， 求到x为止的素食，所以循环需要到x+1. if prime(n): r_list.append(n) return r_listprint((get_prime(1000)) 看起来很简单对不对，但随着x的增大，时间复杂度开销太大了，有没有更好的方法呢？ 对于一个自然数N，只要能被一个非1非自身的数整除，它就肯定不是素数。 我们一定要一个个的除过去吗？非也 对于一个自然数N，如果它不是素数，是合数，那么肯定存在1到N的两个数，n1×n2=N。 那么n1 和n2不可能两个都大于根号n（√N），不难理解吧？我们可以把n1和n2看成一对，假设n1 &lt; √N，那么，只要n1能被N整除，N就不是素数。 也就是说， 只要2到√N之间的数能被N整除，那么N就不是素数，否则，N就是素数。1234567891011121314def prime(n): for i in range(2, int(math.sqrt(n)+1)): if n%i ==0: return False return Truedef get_prime(x): r_list = [] for n in range(2, x+1): if prime(n): r_list.append(n) return r_listprint(len(get_prime(1000))) 对于每一个n, 查找范围是不是少了一半？ 我们再来想下。 除2之外的偶数，会不会是素数？不可能把，也就是说，偶数只有2是素数，那么素数之剩下奇数了，优化如下：123456789101112131415161718def prime(n): for i in range(2, int(math.sqrt(n)+1)): if n%i ==0: return False return Truedef get_prime(x): if x&lt;2: return None if x ==2: return 2 r_list = [2] for n in range(3, x+1, 2): if prime(n): r_list.append(n) return r_listprint(len(get_prime(1000))) 第二种解法 – 埃氏筛法. 列出从2开始的所有自然数，构造一个序列：2, 3, 4, 5, 6, 7, 8, 9, 10 … 取序列的第一个数2，它一定是素数，然后把序列的2的倍数筛掉, 剩下：3,5,7，9…. 取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：5,7,…. 取新序列的第一个数5，然后用5把序列的5的倍数筛掉：7… 不断筛下去，就可以得到所有的素数。1234567891011121314151617181920212223242526#以下代码摘抄自网络def _odd_iter(): n = 1 while True: n = n + 2 yield ndef _not_divisible(n): #先别着急理解这个函数，看后面。 return lambda x: x % n &gt; 0 #此处&gt;0可以更改为！=0.不影响结果，原因是要把所有可以被素数整除的数筛选掉。def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 #难点在于理解这个_not_divisible函数里的x。filter函数用法是：filter(fuction,list)：将list中每一个元素带入到function中，计算返回值，将返回值为True的list中的元素形成一个新的list。for n in primes(): if n &lt; 10: print(n) else: break]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想进BAT？这些面试题助你一臂之力（附答案）]]></title>
    <url>%2F2018%2F04%2F10%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%2F%E7%AE%97%E6%B3%95%2F%E6%83%B3%E8%BF%9BBAT%EF%BC%9F%E8%BF%99%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[请微信添加公众号TesterTalk获取此文章密码。昨天TesterHome发表了如下文章《被同龄人抛弃？68道中高级测试工程师面试题助你一臂之力》引爆了我的朋友圈。 我大致看了下，里面的问题很有代表性，即使是我这样的老司机，没有经过充分准备也不能回答的令自己满意，故花点时间，写下这些面试题的答案，给大家参考，也欢迎大家讨论指正。 正文全部引用上述文章的问题，答案写在每一个问题下面。 1 软性热身题这种题目，考的就是你的软性能力，比如表达能力，理解能力，协调能力，一个词概括就是套路。这类题目会在面试开始热身的时候，问一道两题，不会多，但是如果你能回答的有条不紊，清晰达意，那么就会给面试官留下非常好的印象，大致的题目如下： 自我介绍 我叫XXX，毕业于XXX，从事测试行业已经XX年，我擅长接口测试自动化，测试框架，巴拉巴拉，我共服务过X个公司分别有Y个成就，江湖人称666.总之，尽量用简介的语言突出自己的优点，要保持humble，就像我介绍的这样，嗯：） 介绍下你负责的公司项目 我主导了XXX，协助了YYY，参与了ZZZ。 这个回答你要记清楚，后续的面试肯定还有项目细节，甚至技术实现细节。同类的项目说一个足以，重点突出不同技术栈或者有管理，对外沟通的项目 你有什么优点和缺点？ 实际情况作答，比如优点是长的好看，缺点是太好看之类的，总之，要谦虚，不要傲。在同一个项目组内，你认为你怎么做会比另外一名测试更加优秀？我个人认为这个题目很有迷惑性，如果你只追求比别人优秀，肯定很难跟别人合作，如果你没有别人优秀，那么我为什么要用你？要我答的话，我重点会放在如何一点一滴积累技术实力，及用这些实力解决项目组存在的问题上，这实际上也是很多优秀测试人员的必备素质你为什么离开上家公司？离职原因（这个会在最后问）看老板不爽啊，PM太SB啦喜欢的同事跟开发跑啦等等， 一个都不要说！！！ 我要面试别人，关注的是离职背后的动机，这人是不是被开除的，这人是不是不好相处，这人是不是有明显性格缺陷，只要不沾这些必死项，其它实际作答吧。 个人觉得软性题，不必要过多关注，除自我介绍外，通常是通过面试后HR关的闲聊题，主要还是要关注下面的技术问题。 # 2 测试理论基础题这类题目就是考测试工程师的基本能力了，比如测试计划，测试流程，如何bug，你做过哪些测试，一般我们认为这些能力做的再好都是应该的，不会有加分，但是只要做的不好，那就是个不合格的测试工程师了。这种题目也不会问的太多，大概题目如下：请描述下你上个公司的测试流程？实际情况作答， Scrum模式举例如下：1.我们公司采用Scrum模式开发，测试也跟这个走，在每个sprint开始前会前后召开grooming meeting， planning meeting， Grooming meeting上把这个sprint可能做的tasks从product backlog里捞出来， 然后按照优先级排序， planning meeting上估时，做commitments，并确认每个story的后端，前端，测试。2.planning后sprint正式开始时，需求，design，UI应该都ready了，测试就可以设计用例， 通过review后发给所有组成员review。 story ready for test时，开发把代码放到测试环境，测试开始测试，发现问题jira报bug，linked到story，测试全部完成后标记 UAT GL， 等公司release process开始。3.Release process开始，不同小组把各自代码放到统一测试环境，继续测试一次，这轮关注别组不会影响自己。4.然后还有一轮甚至两轮 pre release，主要验证代码，环境，变量等问题。5.最后release， 观察下，有问题回退版本，没问题继续走下个sprint请描述下bug的几个要素？ID， Summary， reproduce steps， Priority， Assign to， Sprint info， fix version（due data）等等。这道题我好想回答一句，jira里都有，你自己不会看呀：）白盒和黑盒的区别，你是怎么运用的？简单来说一个关注内部实现逻辑，一个只从用户角度出发，不关注具体实现。具体定义及区别请参考我以往文章。一般中高级测试都会偏灰盒一些，既关注内部实现逻辑又关注用户jounery，设计case的时候两边参考。内部实现逻辑可以看代码，也可以请开发讲给你听，知道了怎么实现，能在设计用例时构造不同数据cover逻辑覆盖。同时也清楚了regression 的scope你是如何做测试分析？这题是考察测试思维，一个应用/功能如何测试的问题，我的原则是确定需求，先定性后定量。具体来说，定性， 哪些是显性需求？那些是隐性需求？功能在scope吗？性能？可靠性？安全性？兼容mobile平台吗？定量就是， 功能要测， 那么有哪些功能，每个功能点是什么， 入口是什么，出口是什么，precondition是什么，数据哪里构造等等。重复上述操作直到分析完成如何设计测试用例？什么样子的测试用例是好用例？个人觉得上题回答好了，这题不会问了。 设计用例原则上好的用例各有千秋（不外乎边界值，等价类，流程图，正交法，判定表等）， 但坏的实践要避免，具体如下：1.一个测试用例验证多个功能点（A,B,C三个功能一个用例，那么用例失败了，到底是A引起的？还是B引起的?增加后续开发定位问题的难度，浪费时间）2.期望结果不明确（例如： make sure every thing works fine. what the f×××？！）3.不可执行（比如一个配置项组合， 手工要执行的case写了2000个， 怎么执行完？）4.precondition，steps描述不清楚，上手困难（你负责的story可能要由其它测试人员交叉执行）。5.不必要的外部依赖（用例应直指功能核心，无关的入口/步骤/依赖 不必要一股脑放进来）功能测试在 beta 版本对外的上线标准是什么？貌似业界对beta的定义不太统一，有人说这个是A/B测试的一种， 但一般认为专业测试人员完成后，有部分用户参与的一轮测试即beta测试。一般测试环境为用户实际应用环境，目标在于要求用户使用发现不合理，不符合实际情况的问题，然后改进。功能上线标准每个公司不一样，大致如下：1.所有功能点(需求)都被用例覆盖到了2.所有用例执行过至少一遍3.所有发现的bug被修复并验证，做过regression了。4.不能修复的记录了/关闭了/known issue了。5.bug曲线区域平稳了本人认为此类问题属于淘汰题，一个问题回答不上来或者深度不够，直接闲聊然后结束面试。# 3 测试管理题这类题目就是考验你作为测试leader或者测试负责人的管理能力了。如果项目周期很短，测试人力匮乏，你是怎么协调的？范围不变，赶工/增加人手，快速跟进/并行开始任务。 范围能变，砍低优先级用例，缩小测试范围。描述下你团队的测试分工实话实说， 比如：干活是不可能干活的，这辈子都不可能干活的， 做管理又不会做，就是颜值这种东西，才能维持得了团队这样子。对于团队成员，你是如何打kpi的？没钱没颜你速去，童颜巨 你快来这样子。我一般看三点：1.出活2.持续出活3.持续精彩的出活# 4 移动测试相关如今是移动互联网的天下，谁家没有个应用，所以这一块基本都会问到，同时也会看你的简历，如果你没有做过，基本也不会问的太深，如果你是专门做这一块的，那么要好好准备了。 概念题 描述下web测试和移动应用测试的相同点和区别？公众号以前分享过，不赘述，把握以下几点：0.任何类型测试先定性，再定量， 范围， 分类一定，大差不差。1.web通常不要安装，移动应用通常要安装。2.移动设备存在特殊性，不同设备的屏幕/分辨率，系统，定制UI都不相同。3.移动应用不应该影响移动设备现有功能，如电话/短信等。4.移动端要重点关注，发热（电量消耗）， crash， 流量(4G/WIFI/2G)等你是如何做应用的兼容性测试的？一般兼容性主要关注：1.硬件的适配：不同手机厂商、硬件性能，不同屏幕大小的适配2.OS版本的兼容。 iOS，Android， 手机，pad， 版本号啊，MUI定制啊等3.不同分辨率屏幕的适配解决办法（云测，此处欠我广告费），除公司自备主流设备外，需参考：1.各大厂商发布的季度/年度手机出货量，尽量覆盖出货量大的，热门的机型2.应用做tracking，记录自己用户常用机型3.购买各种云测服务，解决机型适配问题请讲出客户端下 3 个常用的性能指标的名称与具体含义？基本的：1.CPU利用率2.内存使用率3.平均用户响应时间独有的：1.电量2.流量3.首次打开速度4.竞品相应项目质量比较iOS应用和Android应用测试有什么侧重点？主要是iOS系统和Android系统的本质造成的：1.Android运行基于虚拟机，iOS则是沙盒机制2.iOS是伪后台，任何第三方程序都不能在后台运行；而Android是真后台，安卓中任何程序都能在后台运行，直到内存不够才关闭3.IOS中用于UI指令权限最高，安卓中数据处理指令权限最高。测试实际应用上来，个人觉得没有本质区别，要注意以下问题：1.安全性。 因为Android2的本质，任何程序都就可以轻松访问其他程序文件，要关注下有没有偷偷访问不需要功能/偷流量/常时间运行占用内存消耗电量等问题。2.Android开源，定制版本过多（比如小米系列MIUI）， 要关注定制引起的问题。请讲诉移动应用的灰度是怎么做的？灰度发布作为A/B Test的一种，一般指发布新功能到部分用户，收集反馈/改进，进而发布到全步用户的一种策略。个人经历过以下方面：1.新服务发布到全部服务器，但通过配置项把不同特征用户的请求打到不同的后端服务上去。比如ip是中国的用户访点击某个按钮，调用的是后端。。。/vi这个API， 而国外ip调用。。/V22.新功能的后端服务只发布到部分服务器，只有访问到这个服务器的用户才能用新功能。3.同一个用户访问的平台不同，请求的服务就不同，比如app的访问V1， web的访问V2，可以通过发布app版本来实现。另外这个实现还有很多专业的AB测试平台可以实现， 例如（云测，此处欠我广告费）。如果涉及到写DB操作， 一般都双写。即访问新服务时，写到新服务的DB数据也要写到老服务的DB。甚至全部切换至新服务后再并行运行一段时间，才彻底切换到新服务，停写老服务。 实践题 应用的闪退通常是什么原因造成的？如果应用闪退，Android 和 iOS 上是分别怎么抓取日志的？一般闪退原因如下：1.内存超载2.后端服务或动态链接库未找到3.应用初始化时无法正确读取到用户数据。4.系统兼容问题。日志抓取的话，iOS：1.通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志2.通过Xcode从你的设备上获得崩溃日志3.自己在程序中添加崩溃捕捉代码，如果应用集成第三方SDK，如百度统计Android：1.通过集成第三方SDK，如百度统计、友盟统计等2、发版时使用加固工具，他们也会收集错误日志，如360加固3、在程序中添加程序异常崩溃的捕捉代码，保存到本地文件中请简述移动应用在升级安装时候应该考虑的场景？实际上跟CS架构的升级没什么两样：1.APP有新版本时，打开APP是否有更新提示。2.当版本为非强制升级版时，用户可以取消更新，老版本能正常使用。用户在下次启动app时，仍能出现更新提示。3.当版本为强制升级版时，当给出强制更新后用户没有做更新时，退出APP。下次启动app时，仍出现强制升级提示。4.不删除APP直接更新，检查是否能正常更新，更新后能否正常工作。5.删除老的APP，重新下载APP，能不能正常工作。6.不删除APP直接更新，检查更新后的APP和新安装的APP提供的功能一样。7.检查在线跨版本升级能否成功，版本过老是否提示用户重装。8.更新成功后，用户数据有没有丢失，各个配置项是否还原。给你一个应用，请简述你会从哪些方面去测试？一般答分类， 分类如下： 安装/卸载测试， UI， 功能， 性能， 安全， 兼容， 易用， 可移植性。切忌东答一下，西答一下。请描述下微信朋友圈发小视频的用例设计？先假设一个需求，征得面试官同意，在这个既定需求下说你的用例，还是那个思想，定性，定量分类， 不展开了，测试用例设计算基本功吧，考察的无非是功能的全面性，边界/异常条件下的处理， 性能/安全。 主要是有测试思维/结构化思维，设计的用例要系统，不能想起那个说那个。如果让你来测试扫码支付，你会考虑哪些场景？同上，不赘述如何测试一个应用的登录场景？同上，不赘述， 吐槽下，这题改成如何测试百度的登录会更好，BAT齐活了 ：） 实际上这3道题有一道就好了。对中高级测试而言，实践题也是淘汰题，一项卡壳没有后续， 但如果在细节上有疏忽，可以网开一面，进入下个环节# 5 服务端测试相关什么都离不开服务端，所以这是你逃不开的，一般来说服务端会问接口测试，性能测试，更深一点，埋点监控止血也会有。请问你们公司是如何做接口测试的？累死我了， 题要做吐了。 接口测试实际跟一般测试不同就是测试用例的设计部分。1.接口规范拿到。2.设计接口测试功能用例（主要从用户角度出发看接口能否实现业务需求，用例设计就是黑盒用例那一套）。3.各种入参验证（正常情况，异常情况包括输入参数个数不对，类型不对，可选/必选， 还有考虑参数有互斥或关联的情况）。4.接口返回值各种验证（符合接口文档需求）5.了解接口实现逻辑，实现逻辑覆盖（语句/条件/分支/判定/。。。。。）6.接口能并发执行吗?6.采用工具或者自写代码来验证，HTTP接口一般SoapUI， Jmeter， Fiddler， Postman等都能验证，自己写更好。web service接口一般要写代码来调用。根据测试用例自动化。7.发现问题跟功能测试一样，该报bug报bug，该跟踪状态跟踪状态 接口测试质量评估标准是什么？接口测试说的接口可以是模块接口，也可以是集成接口，那么质量评估标准也就转换为单元测试里的接口测试标准，和集成测试里的集成测试标准。实际上这题如果我来回答的话会关注：1.接口功能是否正确，接口功能是否实现了业务需求。2.接口参数正确性包括实参形参的个数/属性，是否匹配。3.接口并发/串行执行时接口返回值的正确性。4.有没有性能问题（并发执行），有没有安全问题（用户能否直接访问该接口，需不需要验证）面试答上面的应该够了， 其实这里面涉及到单元测试和集成测试评估点，我公众号以前分享后，在测试基础知识里， 总结的更全面，大家可移步查看。 请问你们公司是如何做性能测试的？请讲诉性能测试的相关指标？ 老规矩，先确定需求，再定性，定量。例如：1.这次测试目的是什么，是压力测试/负载测试/疲劳强度测试/BenchMark测试？2.测试的硬件环境是什么？软件是什么？3.测试工具用什么？4.有哪些测试指标？5.测试分析调优/测试报告要吗？具体来说：1.拿到测试需求，确定测试软硬件环境/测试指标， 使用测试工具(Loadrunner, jmeter)录制或者编写测试代码，逐步加压，直到测试目的达成。2.分析测试结果，编写测试报告，突出性能指标包括成功，失败情况，并加以分析。3.调优（一般都是开发的事）相关性能指标：服务器系统资源方面 CPU占用率，内存占用率 磁盘的读写指标网络的占用情况 基础吞吐率事务处理速度 如平均登录时间，操作平均响应时间等。压力测试和负载测试的区别一个（压力测试）把最后一根稻草仍你身上，一个（负载测试）就剩最后一根稻草没仍，或者仍给你指定数目稻草。服务器中一般要监控哪些数据，如何监控的，怎么从监控数据中发现问题？CPU， 内存， 网络， I/O， 数据库。等等。 一般用工具监控，另外Windows上有性能监视器。发现问题，一般要关注阈值，比如CPU利用率超过85%，说明server压力太大了，数据量一大DB某条SQL写入速度变慢了等等等等假设系统A调用系统B，我把B的接口都mock了，进行性能测试，这样有什么好处和坏处？好处是去掉的依赖，可以在B没有好之前测试A，并且B的任何改动/错误/失效不会影响我测试A坏处是真实性能要比测出来的性能差， 性能指标不准确。 因为Mock的服务再真也不能代替真实服务有一天早上打车高峰，滴滴服务端挂了大概30分钟，工程师抢修之后，马上上线，之后又挂了，请问有哪些原因会造成这个情况？还是考测试思维， 一定记得先确认需求，再定性，定量。 一般都要反问， 服务器是哪个服务器？后端应用服务器？数据服务器？缓存系统服务器？中间件服务器？文件系统服务器？然后面试官说个，不说就自己假定一个， 然后第一次挂第二次挂分开说，先问有没有错误码，日志有吗，有就看日志，没有就猜 是应用服务器挂了啊，是不是高峰期顶不住这么大并发访问啊？是数据库服务器啊，是不是频繁读写受不了啊，读写有分开吗？同步还是异步啊， 把喇叭里。第二次挂，可能更多了，是不是代码弄错了，改坏了，或者把喇叭里。总之套路就是性能测试中可能预见的问题及原因，这个你们google下吧，自己分类总结下。性能这部分题，个人认为除非你面试性能测试工程师，不然都是可选题，答对80%过关肯定没问题，60%也行。关键有个概念，知道性能测试怎么回事，有问题该往哪个方向想就行了。 # 6 自动化相关自动化永远是避不开的，反正你入职的岗位要不要用自动化，你必须得会一点，加分项。这一块包括，自动化一些理念和自动化的工具使用。理念和概念：如何看待自动化和手动测试？怎样的一个比例才是健康的？见仁见智，一切能提高软件质量的方法都应该尝试。兵无常形，符合自己项目实际情况是最好的。当然你要面试自动化测试，肯定是一切稳定了的功能最好全部自动化掉。 :)你们公司的自动化投入产出比怎样？效益怎样？实话实说，UI自动化测试发现新bug的效益很低，主要用在回归测试上，减少测试工作量。接口测试可就不一样了，可以小步快跑，也可以集团作战。自动化测试用例的覆盖率多少？有个50%了不得了吧， 一般核心业务里的最高优先级用例100%覆盖，这些用例也是用来跑冒烟的。 另外的看项目资源了。完整运行一次自动化用例需要多久时间？Google说它们分钟级或者秒级别， 为毛我们都是小时级别 ：（什么是分层自动化？金字塔结构， 最底层UnitTest，往上接口API/集成起来的service， 最上面UI自动化你的测试数据是怎么准备的？当然是提前准备的了：）写在脚本里/外部文件（excel， XML）/数据库， 逼格逐级提升测试脚本的维护成本是怎么样的？两个原则：1.不坏就不要修2.终身追责，谁污染谁治理 工具使用 WebDriver 相关请问你的定位策略是什么？啊啊啊，已经两个小时了，要抓狂了。ID， Clas， CSS， XPath， jquery脚本， 总之能不麻烦开发就不麻烦开发。请问如何实现用例失败或者异常时候需要截图？框架自带， python+webdriver里是get_screenshot_as_file， 一般写一个装饰器，放在要执行的类上，try， catch下。请问如何分布式执行webdriver用例？两种策略：1.利用Jenkins等，部署部分代码到多个机器上执行2.RemoteWebDriver如何在脚本中执行 JavaScript 代码？driver.execute_scripts(‘脚本’) 移动应用相关 Appium 的定位策略有哪些？使用Appium-Python-Client情况下， 除了以下常规八种定位方式外：driver.find_element_by_id() –元素的 resrouce-id 属性driver.find_element_by_AccessibilityId() – content-desc属性，替代以前的name。driver.find_element_by_xpath() –比css定位慢driver.find_element_by_class_name() –元素的 class 属性driver.find_element_by_css_selector()driver.find_element_by_link_text() –链接元素的全部显示文字driver.find_element_by_tag_name() –元素的标签名driver.find_element_by_partial_link_text() –链接元素的部分显示文字iOS和Android上还有独特的定位方法：iOS：IosUIAutomation –iOS9.3或以下的定位方法driver.find_element_by_ios_uiautomation(‘.elements()[0]’)Android：AndroidUIAutomator， 仅支持 Android 4.2或以上，可支持元素的单个属性和多个属性定位。driver.find_element_by_android_uiautomator(‘new UiSelector().text(“Animation”)’)关于移动端元素的定位的定位，我公众号testertalk也发过系列文章，详细内容请移步。请简述Appium的原理真想跟面试官说，您能帮忙打开官网吗？Appium对iOS和Anroid的实现原理不尽相同，并且对同一个平台不同操作系统版本的实现原理也不相同。我倾向大家往简单了说：1.Appium是C/S架构的，更像是一个proxy，连接其被测移动平台和测试脚本。2.appium是基于 webdriver 协议添加对移动设备自化api扩展而成的。网上有个很清晰的图，截图如下：实际上我个人理解，这个题就是想了解，当你使用一个工具时，你是否关心过它的内部实现，也可以过渡到当你测试一个应用时，你是否关注它的实现。iOS 和 Android 的 UI 自动化的原理是什么？上面已经答了，如下：iOS 9.3 and above: Apple’s XCUITestiOS 9.3 and lower: Apple’s UIAutomationAndroid 4.2+: Google’s UiAutomator/UiAutomator2Android 2.3+: Google’s Instrumentation. (Instrumentation support is provided by bundling a separate project, Selendroid)当定位策略都失败的时候，你该怎么做？80%是你元素定位的不对，那么多定位方法，一个不行换另外一个，直接不能定位，先定位父元素，再循环找子元素。一般来说XPATH都能定位到，无非是可阅读性不强。真的全部失效，请求开发帮你改个元素属性好了。这题其实还是”测试sense”问题，扩大点变成了怎么解决工作中困难。反正别认怂， 最好甭废话，直接开干。请问Monkey测试的优缺点？没接触过，此题不会如果使用monkey发现了一个毕现闪退，请问怎么使用monkey重现它？同上Jmeter你用jmeter做什么测试？接口，性能。如果有一个登录接口需要服务端返回参数，再带着这个参数去请求才能完成登录，用jmeter 怎么做？可以利用Regular Expression Extractor传参。 具体请参考我公众号testertalk Jmeter 系列文章。———- 最后，来点硬题，嚯嚯嚯！ ———-# 7 硬 题所谓硬题就是答案一般都是固定或者标准的，答案也不会模棱两可，包括：算法，编程，sql，linux算法：请写出冒泡排序123456789def maopao（l）： def maopao(l): if not isinstance(l, list): raise TypeError("Need a list as parameter") for i in range(len(l)): for j in range(len(l)-1-i): if l[j]&gt;l[j+1]: l[j], l[j+1] = l[j+1], l[j] return l1~9999数列中数字3出现的次数。用递推方法解出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#本来以为很简单，写了一下，2位数能算出来结果，3位数会报递归次数太多， 觉得蹊跷， 仔细一查，尼玛这题大有来历，我跪的心服口服。经过查找资料，解答如下：1位数： 0～9个位数为3： 3， 共1次。故0~9之间，3的个数为12位数： 10～99个位数是3: 13, 23, 33 ...93, 共9个。十位数是3： 30， 31， ....39. 共10个。故0~99之间，3的个数为1+9+10=20个3位数： 100～999个位数是3： 103， 113， ....193 共10个。 203， 213， ....293 共10个。 。 。 。 903， 913， ....993 共10个。 一共9×10=90次。 十位数是3： 130， 132 ....139 共10个。 230， 232 ....239 共10个。 。 。 。 930， 931， ....939 共10个。 一共9×10=90次。百位数是3： 300， 301， ....399 共100个。故0~999之间，3的个数为20+90+90+100=300次也可以这样考虑：0~999之间：十位个 位共有10个0~99（解释0～99，100～199，。。。900～999），故有10*20=200次，而百位为1的有100次，共200+100=300次300=10*20+1004位数： 0～9999个位数是3： 1003，1013，1023， 。。。1093 共10个 1103，1113，1123， 。。。1193 共10个 1203..... 共10个 1903.... 共10个 共9个10，我们记为A 还有2003～2903， 3003～3903.。。9003～9903 还有9个一样的A。 所有一共有10个（A）， 是10×9×10=900十位数是3： 1030，1031，。。。。。。1039， 共10个。 1131～1139， 1231～1239. 。。。 1931～1939， 共有10×10个=100个。我们记为B 还有千位数是2开头的，到9开头的，加起来共有9个（B） 9×10*10=900个。百位数是3： 1300， 1301，。。。。1399 共100个。 2300 .。 9300 共10×100=1000个。千位数是3： 3000，3001，3999 共 1000次。故0~9999之间，3的个数为300+900*900*900+1000=4000也可以这样考虑：0~9999之间：百位十位 个位共有10个0~999（0～999， 1000～1999， 。。9000～9999），故有10*300=3000次，而千位为1的有1000次，共3000+1000=4000次4000=10*300+1000 规律：0~9：10~99：20=10*1+100~999：300=10*20+1000~9999：4000=10*300+10000~99999：50000=10*4000+100000~999999：600000=10*50000+100000f（1）=1f(2)=10*f(1)+10 **1f(3)=10*f(2)+10 **2f(4)=10*f(3)+10 **3...f(n)=10*f(n-1) + 10*(n-1)代码如下：def count_n_times(digit_number): #传入的是位数 if digit_number==1: return 1 if digit_number&lt;=0: return 0 return 10*count_n_times(digit_number-1) + 10**(digit_number-1)def count_digit_number(number): #给定是一个数 return len(str(number))print(count_n_times(count_digit_number(999)))我们再来假设下，如果给你的不是9999而是2345呢？即对于任意给定的数n，怎样能快速得到0~n之间3的个数呢?(这就是google的原题了（原题是算1），这题太硬了，我啃了几个小时了，不啃了..)从一个数组中找出前4个最大的数，用最优解。123456789101112131415161718192021222324252627282930#这个就是排序问题了吧，我想法先排好序，在取前4个，那么多排序，冒泡啊，选择啊，快排啊。。这里面快排最快，用大O算法O (n * log n )。思想：少于2个元素的数组不需要排序找一个元素作为基数小于基数的放一个数组大于基数的放一个数组针对小于基数的数组做快速排序，暂且叫low针对大于基数的数组做快速排序, 暂且叫high最终排序后的 low + 【基数】+ high，就是排好序的数组def quicksort(l): low = [] high = [] if len(l)&lt;2: return l else: base = l[0] for i in range(1,len(l)): if base &lt;l[i]: high.append(l[i]) else: low.append(l[i]) return quicksort(low) + [base] + quicksort(high)print(quicksort([2,2,1,8,5,7,6])[:4])其实python里内置了很多优秀的方法来解决其他语言很繁琐的问题，比如本题目可以直接：print(sorted([2,2,1,8,5,7,6])[:4]) （据说python里sorted实现也是快排，没有经过求证。）哈哈，这样，面试官会不会鄙视我 ：）我之前也分享过基本的算法，大家可以去我的公众号testertalk查看。写一段程序，删除字符串a中包含的字符串b，举例 输入a = “asdw”,b = “sd” 返回 字符串 “aw”，并且测试这个程序。1234567def del_ele(a, b): r = '' for i in [x for x in a if x not in b]: r +=i return rprint(del_ele("asdw", "sd"))这个就比较简单了，测试用例就不写了。写一个方法，把字符串转为数字，比如 str=”1234”，变成 int 1234。并且测试这个程序。12345678def convert_format(a): if not isinstance(a, str): raise TypeError("You need a str") return int(a)print(convert_format("1234"))啃完了google的题，我觉得我肯定没有领会这两道题目的意图， 紧张中。。。。 测试用例就不写了。**个人总结下，硬题是比较好的一个筛选人的方式，但是也比较容易作弊，这个最多能看出来候选人有没有看算法的意识。 对于中高级测试来说，平时一定要刷点算法题，不然百分百被刷下** 编程： 什么是面向对象编程？把一切看成对象，三大特性 继承，封装，多态 讲下Java多线程的使用 java多线程跟别的语言的多线程有区别吗？多线程一般用来更好的利用CPU资源，解决诸如程序“在一部分上会阻塞”，“在另一部分上需要持续运行”的场合。多线程一般用来更好的利用CPU资源，解决诸如程序“在一部分上会阻塞”，“在另一部分上需要持续运行”的场合。例如有个程序需要接受多个用户输入并向服务器发送数据，那么如果不用多线程，一旦程序在等待某个用户输入时，程序就会阻塞。这段时间其它用户也不能使用了 有三个线程T1，T2，T3，怎么确保它们按顺序执行？ 在主线程中，每一个线程start（）后立即join（） Thread 类中的start() 和 run() 方法有什么区别？ 个人理解start（）会启动线程，然后调用run（），run（）方法一般要重写。网上资料：调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。1.start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。2.run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。记住：多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发 请写一个线程安全的单例模型 网上搜下吧，java不熟悉 SQL： 说下左连接和右连接123比如有两张表A和B。 A表B表都有ID列， select* from A left join B where A.ID=B.ID. 会把A表所有记录显示，B表里没有和A表ID对应的，会显示NULL。左连接是把符合条件的所有的A表的内容列出来，B表里如果没有内容匹配就用NULL代替。 右连接是符合条件的 B表的内容全显示出来，A表里没有匹配就用NULL代替。 介绍下什么是索引12345678910111213141516171819202122232425262728索引是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。索引包含由表或视图中的一列或多列生成的键。这些键存储在一个结构（B树）中，使 SQL Server 可以快速有效地查找与键值关联的行。 SQL里索引的语法：SQL CREATE INDEX 语法在表上创建一个简单的索引。允许使用重复的值：CREATE INDEX index_nameON table_name (column_name)注释："column_name" 规定需要索引的列。SQL CREATE UNIQUE INDEX 语法在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。CREATE UNIQUE INDEX index_nameON table_name (column_name)CREATE INDEX 实例本例会创建一个简单的索引，名为 "PersonIndex"，在 Person 表的 LastName 列：CREATE INDEX PersonIndexON Person (LastName) 如果您希望以降序索引某个列中的值，您可以在列名称之后添加保留字 DESC：CREATE INDEX PersonIndexON Person (LastName DESC) 假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：CREATE INDEX PersonIndexON Person (LastName, FirstName)更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。索引不适用于需要频繁写入的表，适合只读多插入少的表。 使用sql生产10万条数据 平常没接触过这么大数据量，分批次吧，每次插入1w条，应该没什么压力给你一张表，根据要求写sql，这个题目比较多，自己百度吧。 Linux： 你常用的命令是什么？ls, mkdir, cat, vi, ps touch 用什么查看log？ watch, tail、cat、tac、head、echo 如何查找一个文件大小超过5M的文件12345find . -type f -size +800M常用的参数有: - type:类型。POSIX支持——b:块设备文档、d:目录、c:字符设备文档、P:管道文档、l:符号链接文档、f:普通文档 - name:按文件名查找。支持*模糊匹配 - size:文件大小。+表示大于，-表示小于。支持k,M,G单位 如何查看进程？123ps命令。它能显示当前运行中进程的相关信息，包括进程的PID。Linux和UNIX都支持ps命令，显示所有运行中进程的相关信息。ps命令能提供一份当前进程的快照。如果想状态可以自动刷新，可以使用top命令。ps aux | less #显示所有运行中的进程 写在最后 这68道题目，我花费了2个晚上总结整理，用的时间我都不好意思说。 从个人角度看，这些面试题很接地气，很多考题也跟实际工作密切相关，大大增加了筛掉水货的几率，我也曾用部分相似题来筛选别人。 对于初级测试来说，测试理论，测试基础都应该掌握，移动端测试，服务器端测试，自动化测试，性能测试，也应该逐渐接触起来，不会答没关系，但要大致了解，面试官喜欢有追求的人。 对于中高级测试来说，除了硬题，其它题目经过充分准备都不应该丢分，回答正确率要在85%以上，另外，回答的深度非常重要，决定了你是年龄资深还是技术资深。 对于硬题，虽然大部分的测试，甚至测试开发，工作中用到算法的几率也不高，但你如果都答对了，还是能让人眼前一亮的。对于这部分试题，稍有难度的例如google面试题那个，你有个大致思路也行，对于非常基础的，二分啊，排序啊，还是建议多练练，起码应该做到手写正确。现在有能力做好普通测试工作的人太多了，算法也跟学历，长相一样，用人单位不得不拿这些筛选掉很多合适的人，有时候你比别人更优秀的能力，也许就来自于你昨天刷了一道面试题。怎么说呢，面试造火箭，进来拧螺丝，接受现实吧。 我本人其实是反对面试突击的，所以我公众号从没有发过面试题。 本文目的也不希望大家背答案就面试（面试从来也没有标准答案，背了估计也面不上 ：0），而是希望大家通过做这些面试题，发现自己的不足，从而有针对性的提升自己。 感谢大家的阅读，能读到这里的都是真粉丝， 欢迎大家提出更好的意见，谢谢。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python+webdriver一劳永逸解决弹出框识别问题]]></title>
    <url>%2F2018%2F04%2F04%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FPython%2Bwebdriver%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E8%A7%A3%E5%86%B3%E5%BC%B9%E5%87%BA%E6%A1%86%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[自动化测试过程中的弹出框识别，应该是老生常谈的问题了，近来不断有新的读者碰见此问题并为此烦恼，干脆写一篇文章终结此类问题。弹出框有几种类型，一般为alart， iframe， windows（包括可直接识别的div，还有不能能直接识别的），下面我们以百度首页为例，看看这几种弹出框如何识别。 假设现在要在百度首页点击登录按钮，等如下窗口弹出来后， 点击qq图标转向qq登录然后，页面会跳转到第3方窗口，在里面选择账户密码登录然后在如下弹出框里输入用户名和密码 我们直接代码看下如何实现，注意，以下下代码仅仅证明可行性，未作任何优化，工程代码应该利用设计模式（PageObject）/分离元素和操作/封装重用类/定义错误处理。1234567891011121314151617181920212223242526272829import timefrom selenium import webdriver#打开首页，点击登录按钮d = webdriver.Chrome()d.get("http://www.baidu.com")d.find_element_by_xpath(".//*[@id='u1']/a[@name='tj_login']").click()#jquery操作页面元素，点击qq账户登录。#1. 这是弹出框问题的终极解决办法，一律用jquey直接操作页面元素，然后通过脚本执行js_script ='''$("#pass_phoenix_btn .phoenix-btn-item")[0].click()'''time.sleep(2)d.execute_script(js_script)time.sleep(2)#切换到qq登录页面，并打印出当前页面以验证正确性。#2. switch_to.window允许你跟弹出页面window交互。for handle in d.window_handles: d.switch_to.window(handle)time.sleep(3)print(d.current_url)#分析页面元素，看出最终的账户登录是个iframe，找到这个iframe的id，切入到这个iframe，继续执行操作。#3. iframe也可以用switch_to.frame直接操作。element = d.find_element_by_xpath(".//*[@id='combine_page']/div[1]")d.switch_to.frame(element.find_element_by_id('ptlogin_iframe'))d.find_element_by_xpath(".//*[@id='switcher_plogin']").click() 最后要注意， 等操作完弹出框后，应该用d.switch_to.default_content()这个方法切换回主页面继续。 欢迎关注TesterTalk，跟我共同进步。]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git用法总结]]></title>
    <url>%2F2018%2F04%2F02%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2FGit%2FGit%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Git常用的命令很多，不常用的话会忘记，特别是在windows上开发的同学，习惯了GUI格式（话说SourceTree真不错）， 偶尔被人问到如果解决conflict，答用工具时会被鄙视，今天就来复习下Git的常用指令。 Git的学习，有两个很好的资源，一个是廖雪峰的官网，这个真是浅显易懂，另一个是codecademy， 想深入学习的同学请移步过去，此处仅用来快速复习。 1.安装直接官网下载，安装好后开始菜单里找到”Git”-&gt;”Git Bash”, 有命令行窗口弹出，则成功。这里通常还会设置下git通用的用户名和邮箱，方法如下：12$ git config --global user.name "此处填写你的用户名"$ git config --global user.email "你的email" 2.创建仓库123451. clone 一个存在的仓库git clone ssh://user@domain.com/repo.git2.创建一个本地仓库， switch到目标文件夹下，输入git init 3. 本地更改123456789101112131415161718191. 添加所有当前的changesgit add .2.添加某一个文件git add &lt;file name&gt;3. 添加某些文件到下次commitgit add -p &lt;file name&gt;4. 提交改动到本地分支git commit -m "comments"5. 提交所有的本地changes到本地分支， 省去了git add .git commit -a6.在changeID不变得情况下，覆盖上次修改的文件代码git commit --amend 4.提交历史查询1234567891011121314151617181.显示所有的提交记录git log2.显示某一个文件的历史记录git log -p &lt;file&gt;3. 让log好看点git log --pretty=oneline4.谁在何时改变了什么内容git blame &lt;file&gt;5.可以查看所有分支的所有操作记录(包括提交、回退、已删除的提交操作记录等)Git reflog 如果在回退以后又想再次回到之前的版本，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录 5.分支和Tag12345678910111213141516171819201.列出所有存在的分支git branch2.切换到某一个分支git checkout &lt;branch&gt;3.创建+切换分支git checkout -b &lt;name&gt;3.基于当前分支创建一个新的分支git branch &lt;new-branch&gt;4.基于远程分支创建一个分支git branch --track &lt;new-branch&gt; &lt;remote&gt;5.删除一个本地分支git branch -d &lt;branch&gt;6.给当前的提交打上taggit tag &lt;tag-name&gt; 6.更新和提交123456789101112131415161718192021221.查看远程仓库的信息（执行该命令后，会列出当前程序对应的所有远程版本仓库的信息，含仓库名和仓库地址）git remote -vgit remote （只是会单纯的列出所有远程仓库的名字，不会展示远程仓库的地址）2.显示某个远程库的信息git remote show &lt;remote&gt;3.创建新的远程库， name, remotegit remote add &lt;remote&gt; &lt;url&gt;4.下载所有远程库的改动, 但是不merge到本地git fetch &lt;remote&gt;4.下载所有远程库的改动, merge到本地git pull &lt;remote&gt; &lt;branch&gt;5.push本地改动到remotegit push &lt;remote&gt; &lt;branch&gt;6.发布你的tagsgit push --tags 7.Merge和Rebase12345678910111213141516171819202122231.merge 合并branch分支到当前分支git merge &lt;branch&gt;举例（把master分支合并到当前分支）：git checkout featuregit merge master2.rebase 把branch合并到当前分支git rebase &lt;branch&gt;举例：git checkout featuregit rebase master（它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。）3.解决冲突后继续合并git rebase --continue4.中止rebase，回到rebase前状态git rebase --abort 8. 回退1234567891011121314151.丢弃所有本地更改 ,commit和index 都回回退到某个版本.(注意,这种方式是改变本地代码仓库源码)git reset --hard HEAD2. 对某一个文件丢弃本地的更改git checkout HEAD &lt;file&gt;3.revert一个commit （会留一个新的commit记录）git revert &lt;commit&gt;4.reset 到commit， commit后的所有提交都被丢弃git reset --hard &lt;commit&gt;5.reset到某个commit，同时保留所有本地的改动git reset --keep &lt;commit&gt; 9 常见问题及解决方案：123456789101112131415161718192021222324252627282930313233341. 你有一个远程主branch，它名字是master， A和B都从master上checkout了本地分支，并创建了远程分支。 A的本地分支和远程分支都叫A， B的都叫B。A先改动了代码并成功Push到远程A， 然后通过pull request成功merge到master， 这时候B也成功push代码到B，然后建立pull request想push到master会出错，怎么解决？（1）. 先push本地分支的改动到远程B分支上。（2）. checkout -b c master 从最新的远程主分支check out一个本地分支， 我们叫C（3）. git pull 通过git pull 把远程master最新改动拉下来到C（4）。 git checkout B, 切换到本地分支B， git merge C，把C的最新代码拉倒B，肯定有冲突，手工解决掉。（4）。 B git push到远程B， 并通过建立pull request的方式push到远程master2. 提交注释错误如何回退git commit --amend3. 提交错误版本到本地仓库如何回退（1）. git reflog 找回要回退的commit id。（2）. 找到上次提交的记录id例如123， 执行 git reset --hard 123 或者 git reset --hard HEAD^4.自己的远程分支版本回退的方法git refloggit reset --hard 123git push -f (注意：本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支)5.公共远程分支版本回退的问题举例：改完代码测试也没有问题,但是上线后发现你的修改导致之前运行正常的代码报错,必须回滚.git revert HEADgit push origin master注意：git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。git revert 命令的好处就是不会丢掉别人的提交。总结下：自己的分支回滚直接用reset公共分支回滚用revert错的太远了直接将代码全部删掉，用正确代码替代。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python算法分享系列 -- 广度优先]]></title>
    <url>%2F2018%2F02%2F22%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%2F%E7%AE%97%E6%B3%95%2FPython%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%2F</url>
    <content type="text"><![CDATA[继续来学习，今天了解下搜索算法。 广度优先搜索（breadth-first search）是一种解决最短路径问题的算法，通常需要： 使用图来建立问题模型。 使用广度优先搜索解决问题。那么，什么是图呢？图模拟一组连接，比如说，假设你与朋友玩牌，并要模拟谁欠谁钱，可以下面这样指出图由节点（node）和边（edge）组成。 广度优先搜索可以帮助我们解决以下两类问题： 1.从节点A出发，能到达节点B吗？ 2.从节点A出发，前往节点B的哪条路最短。 我们先来解决第一个问题， 假设有这样一个欠钱的关系图，过年了，债主纷纷要帐，都知道欠钱的是大爷，现在kevin这个大爷想， 钱我可以还，但还钱前，我想找美女陪我吃顿饭，这下，债主们（alex， bob）纷纷傻了，我俩都是大老爷们啊，怎么办？ 去请一个美女过来，还得花钱呐，干脆，我也找我的债主提要求去，于是alex和bob又对他们的债主提出来相同的问题。Alex没有债主，于是他只好希望Bob能找到，Bob找到了Hult和steven， steven也没有债主，他就等Hult，Hult正好欠Buauty这个美女的钱，于是这样一层一层，终于找到了Beauity，Kevin大爷和Beauty吃端饭，把钱还了，皆大欢喜。 我们来代码实现它,首先把问题转化成图： 图由多个节点组成。每个节点都与邻近节点相连，如果表示类似于“kevin→Bob”这样的关系呢？好在你知道的一种结构让你能够表示这种关系，它就是散列表！散列表让你能将键映射到值， 这种映射关系， python里的实现是字典。 12345678#注意，每一个节点都必须有它对应的节点，如果没有，它对应的节点为空debt = &#123;&#125;debt['kevin'] = ['alex', 'bob']debt['bob'] = ['hult', 'steven']debt['hult'] = ['beauty']debt['alex'] = []debt['steven'] = []debt['beauty'] = [] 查找的方式是：0.创建一个队列，队列里是待查找的元素，再创一个列表，列表里是已经检查过的元素。1.把队列元素依次弹出，看它在不在列表，在表示已经查过了，不需要做任何操作，不在，把它加入列表，然后看看弹出的元素有没有符合条件的。。2.如果有直接退出3.如果没有，看弹出的元素，还有没有债主，有就把它的债主加入到这个队列里。、4.重复第1到3步，直到找到美女或者队列为空。代码如下： 12345678910111213141516171819202122232425262728293031323334from collections import dequedef BFS(): debt = &#123;&#125; debt['kevin'] = ['alex', 'bob'] debt['bob'] = ['hult', 'steven'] debt['hult'] = ['beauty'] debt['alex'] = [] debt['steven'] = [] debt['beauty'] = [] search_route = [] q = deque() q.append('kevin') while q: search = q.popleft() if search not in search_route: search_route.append(search) if is_beauty(search): print(search_route) return True else: q += debt[search] return Falsedef is_beauty(name): if name == "beauty": print("Beauty found!") return Trueif __name__ == "__main__": BFS() 第一个问题从A点到B点有没有解的问题，我们已经解决了，但我们的程序没有把最短路径拿出来，下面来看，如何找最短路径。 根据图的关系，假设我们已经找到了最终的元素Beauty，那么，就意味着我们找到了最短路径，为什么这么说呢，因为我们是从一层一层找下来的，从图来看，有3层，第一层是kevin，第二层是alex， bob， 第3层是steven， hult，第4层是beauty。 那么初始节点出发（第一层），我们首先遍历了第2层所有的子节点，alex和bob，都没有我们要找的元素，然后我们走向第3层，hult，steven，也没有我们找的元素，但是第3层的hult指向了第4层的一个元素，也就是我们的目标。既然找到了目标，我们反过来查目标的上一个元素是谁，就可以一层一层回溯到起始节点。下面来实现下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546from collections import dequefather_child = &#123;&#125; #记录每个元素和它对应的上一层元素。def BFS(): debt = &#123;&#125; debt['kevin'] = ['alex', 'bob'] debt['bob'] = ['hult', 'steven'] debt['hult'] = ['beauty'] debt['alex'] = [] debt['steven'] = [] debt['beauty'] = [] search_route = [] q = deque() q.append('kevin') while q: search = q.popleft() if search not in search_route: search_route.append(search) if is_beauty(search): return search_path(search)[::-1] else: q += debt[search] for item in debt[search]: #生成元素和它上一层元素的对应关系 father_child[item] = search return Falsedef is_beauty(name): if name == "beauty": print("Beauty found!, search order are:") return Truedef search_path(search): #回溯查找路径 return_order = [search] while search in father_child.keys(): return_order.append(father_child[search]) search = father_child[search] return return_orderif __name__ == "__main__": print(BFS()) 代码不是很好看，优化一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from collections import dequeclass BFS: def __init__(self, diagram): self.diagram = diagram self.searched = [] self.node_relation = &#123;&#125; #记录每个元素和它对应的上一层元素。 def bfs(self, start_node): if not isinstance(self.diagram, dict): raise SyntaxError("diagrom must be dict") q = deque() #双向链表，可以用作栈也可以当作队列 q.append(start_node) while q: node = q.popleft() if node not in self.searched: self.searched.append(node) if self.is_beauty(node): return self.search_path(node)[::-1] else: q += self.diagram[node] for item in self.diagram[node]: #生成元素和它上一层元素的对应关系 self.node_relation[item] = node return False def is_beauty(self, name): if name == "beauty": print("Beauty found!, search order are:") return True def search_path(self, node): return_order = [node] while node in self.node_relation.keys(): return_order.append(self.node_relation[node]) node = self.node_relation[node] return return_orderif __name__ == "__main__": debt = &#123;&#125; debt['kevin'] = ['alex', 'bob'] debt['bob'] = ['hult', 'steven'] debt['hult'] = ['beauty'] debt['alex'] = [] debt['steven'] = [] debt['beauty'] = [] print(BFS(debt).bfs('kevin')) 好了，现在广度优先搜索大家也会了，广度优先搜索还有个非常经典的练习题目就是迷宫问题，大家可以尝试解解看，原理是一样的。有问题可以给我留言。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python算法分享系列 -- 二叉树]]></title>
    <url>%2F2018%2F02%2F07%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%2F%E7%AE%97%E6%B3%95%2FPython%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近比较懒，一直没有更新，耐不住迷妹们在后台频繁的鼓励，今天我们来蹭个热点，了解下二叉树。 最近最火的一个新闻莫过于某著名程序员面试Google被拒，原因是不会反转二叉树。今天我们就来学习二叉树。 什么是二叉树 二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 如何定义一个二叉树根据定义，我们知道二叉树最重要的是根节点，左节点和右节点，我们来实现一个类来代表二叉树：12345class BinaryTree(object): def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right 实现二叉查找树（Binary Search Tree）首先， 二叉查找树，又称二叉排序树（Binary Sort Tree）， 二叉搜索树，它有如下特点：（0）它是一颗空树，如果不是，它一定符合下列性质： （1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值； （2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； （3）左、右子树也分别为二叉排序树； 先看一个二叉查找树的例子：下面来实现它：12345678910111213class BST: def insert_tree(self, root, value): if root.val &gt; value: if not root.left: root.left = Node(value) else: self.insert_tree(root.left, value) if root.val &lt; value: if not root.right: root.right = Node(value) else: self.insert_tree(root.right, value) 那么，二叉树如何实现查找呢？根据二叉树的特点，我们知道：1.如果要查找的值等于根节点的值，成功退出。2.如果要查找的值小于根节点的值， 递归查找左分支树， 否则，递归查找右分支树，3.如果发现等同于要查找的值，成功退出。4.如果子树为空，返回空。 在查找之前，我们先看看如何遍历二叉树： 1234567891011121314151617181920212223242526272829 #先访问根节点，再遍历左子树，最后遍历右子树；#并且在遍历左右子树时，仍需先访问根节点，然后遍历左子树，最后遍历右子树。 def preorder(self, root): if not root: return [] result = [root.val] left_result = self.preorder(root.left) right_result = self.preorder(root.right) return result + left_result + right_result #中序遍历：先遍历左子树、然后访问根节点，最后遍历右子树；#并且在遍历左右子树的时候。仍然是先遍历左子树，然后访问根节点，最后遍历右子树。 def midorder(self, root): if not root: return [] left_result = self.midorder(root.left) result = [root.val] right_result = self.midorder(root.right) return left_result + result + right_result #后续遍历：先遍历左子树，然后遍历右子树，最后访问根节点；#同样，在遍历左右子树的时候同样要先遍历左子树，然后遍历右子树，最后访问根节点。 def postorder(self, root): if not root: return [] left_result = self.postorder(root.left) right_result = self.postorder(root.right) result = [root.val] return left_result + right_result + result 查找：123def search_node(self, root, value): if value in self.postorder(root): return True 最后，我们来看下大神回答不出来的那个问题， 交换二叉树的左右节点。1234567def switch_node(self, root): if not root: return None root.left, root.right = root.right, root.left self.switch_node(root.left) self.switch_node(root.right) return self.preorder(root)由此可以看出， 二叉树的操作，最多的用到的是递归,递归的本质是自己调用自己，下面给一个函数来理解：12345678910111213141516171819202122#求阶乘 def factorial(n): if n&lt;=1: return 1 else: return n*factorial(n-1) 如何理解呢？n = 5; x = factorial (n); x = factorial (5); # first call to function x = (5 * factorial (4)); # recursion starts, until logic requirement satisfied x = (5 * (4 * factorial (3))); x = (5 * (4 * (3 * factorial (2)))); x = (5 * (4 * (3 * (2 * factorial (1))))); x = (5 * (4 * (3 * (2 * (1))))); # all calls made, logic ceases the recursion x = (5 * (4 * (3 * (2 * 1)))); # returns start as resolutions/calculations begin x = (5 * (4 * (3 * 2))); x = (5 * (4 * 6)); x = (5 * 24); x = (120); # final resolution/calculation before return x = 120;递归的理解不尽相同， 不过读者大可不必去关心函数如何一层层调用的，因为 Recursion is the process of solving a problem in terms of smaller versions of the same problem. Since the problem gets smaller each time, the process eventually terminates in a problem (the “base case”) that can be solved directly. Be sure of three things: The problem gets smaller each time. You include a solution for the base case. Each case is handled correctly. That’s really all there is to it.参考资料：！递归理解1！递归理解2]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python算法分享系列 -- 二叉树]]></title>
    <url>%2F2018%2F02%2F07%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E7%AE%97%E6%B3%95%2FPython%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近比较懒，一直没有更新，耐不住迷妹们在后台频繁的鼓励，今天我们来蹭个热点，了解下二叉树。 最近最火的一个新闻莫过于某著名程序员面试Google被拒，原因是不会反转二叉树。今天我们就来学习二叉树。 什么是二叉树 二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 如何定义一个二叉树根据定义，我们知道二叉树最重要的是根节点，左节点和右节点，我们来实现一个类来代表二叉树：12345class BinaryTree(object): def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right 实现二叉查找树（Binary Search Tree）首先， 二叉查找树，又称二叉排序树（Binary Sort Tree）， 二叉搜索树，它有如下特点：（0）它是一颗空树，如果不是，它一定符合下列性质： （1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值； （2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； （3）左、右子树也分别为二叉排序树； 先看一个二叉查找树的例子：下面来实现它：12345678910111213class BST: def insert_tree(self, root, value): if root.val &gt; value: if not root.left: root.left = Node(value) else: self.insert_tree(root.left, value) if root.val &lt; value: if not root.right: root.right = Node(value) else: self.insert_tree(root.right, value) 那么，二叉树如何实现查找呢？根据二叉树的特点，我们知道：1.如果要查找的值等于根节点的值，成功退出。2.如果要查找的值小于根节点的值， 递归查找左分支树， 否则，递归查找右分支树，3.如果发现等同于要查找的值，成功退出。4.如果子树为空，返回空。 在查找之前，我们先看看如何遍历二叉树： 1234567891011121314151617181920212223242526272829 #先访问根节点，再遍历左子树，最后遍历右子树；#并且在遍历左右子树时，仍需先访问根节点，然后遍历左子树，最后遍历右子树。 def preorder(self, root): if not root: return [] result = [root.val] left_result = self.preorder(root.left) right_result = self.preorder(root.right) return result + left_result + right_result #中序遍历：先遍历左子树、然后访问根节点，最后遍历右子树；#并且在遍历左右子树的时候。仍然是先遍历左子树，然后访问根节点，最后遍历右子树。 def midorder(self, root): if not root: return [] left_result = self.midorder(root.left) result = [root.val] right_result = self.midorder(root.right) return left_result + result + right_result #后续遍历：先遍历左子树，然后遍历右子树，最后访问根节点；#同样，在遍历左右子树的时候同样要先遍历左子树，然后遍历右子树，最后访问根节点。 def postorder(self, root): if not root: return [] left_result = self.postorder(root.left) right_result = self.postorder(root.right) result = [root.val] return left_result + right_result + result 查找：123def search_node(self, root, value): if value in self.postorder(root): return True 最后，我们来看下大神回答不出来的那个问题， 交换二叉树的左右节点。1234567def switch_node(self, root): if not root: return None root.left, root.right = root.right, root.left self.switch_node(root.left) self.switch_node(root.right) return self.preorder(root)由此可以看出， 二叉树的操作，最多的用到的是递归,递归的本质是自己调用自己，下面给一个函数来理解：12345678910111213141516171819202122#求阶乘 def factorial(n): if n&lt;=1: return 1 else: return n*factorial(n-1) 如何理解呢？n = 5; x = factorial (n); x = factorial (5); # first call to function x = (5 * factorial (4)); # recursion starts, until logic requirement satisfied x = (5 * (4 * factorial (3))); x = (5 * (4 * (3 * factorial (2)))); x = (5 * (4 * (3 * (2 * factorial (1))))); x = (5 * (4 * (3 * (2 * (1))))); # all calls made, logic ceases the recursion x = (5 * (4 * (3 * (2 * 1)))); # returns start as resolutions/calculations begin x = (5 * (4 * (3 * 2))); x = (5 * (4 * 6)); x = (5 * 24); x = (120); # final resolution/calculation before return x = 120;递归的理解不尽相同， 不过读者大可不必去关心函数如何一层层调用的，因为 Recursion is the process of solving a problem in terms of smaller versions of the same problem. Since the problem gets smaller each time, the process eventually terminates in a problem (the “base case”) that can be solved directly. Be sure of three things: The problem gets smaller each time. You include a solution for the base case. Each case is handled correctly. That’s really all there is to it.参考资料：！递归理解1！递归理解2]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python算法分享系列 -- 查找，排序，递归]]></title>
    <url>%2F2017%2F12%2F19%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E7%AE%97%E6%B3%95%2FPython%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[沉寂了一段时间，继续学习。算法这个系列我想分享很久了，奈何本身对算法不是特别了解，又找不到合适的载体来分享。最近看了本有趣的算法书， 文中通过图文并茂的讲解给我很大启发，尝试着分享下 需要注意的是， 文中各个算法的写法不是简单的拷贝，算理解思想后拿Python3重新写了遍，分享的代码和书中的例子也稍有不同，加了些日常工作中会做的处理，如有不适，请联系我。 二分查找 –仅当列表是有序的时候才能用思想： 1.目标是找数组中的某一个元素，暂叫item2.找出整个数组中间的那个元素，它下标mid，数组被它一分为二3.比较下标mid对应的元素和item，如果mid对应的元素大，查找范围缩小到mid前面的那一半数组，反之，缩小到mid后的那一半数组4.重复3，直到item==mid 对于包含N个元素的列表，用二分查找最多需要log2 N 步。（对数是幂运算的逆运算） 大O表示法指出了算法有多快。例如，假设列表包含n 个元素。简单查找需要检查每个元素，因此需要执行n 次操作。使用大O表示法，这个运行时间为O (n )。单位秒呢？没有——大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速 。 再来看一个例子。为检查长度为n 的列表，二分查找需要执行log n 次操作。使用大O表示法，这个运行时间怎么表示呢？O (log n )。一般而言，大O表示法按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。 O (log n )，也叫对数时间 ，这样的算法包括二分查找。O (n )，也叫线性时间 ，这样的算法包括简单查找。O (n * log n )，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。O (n 2 )，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。O (n !)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。 大O表示法指出了最糟情况下的运行时间. 选择排序思想： 找出数组中最小的元素把数组中最小的元素pop出来到新的数组里。重复以上操作直到原数组为空 需要存储多个元素时，可使用数组或链表。数组的元素都在一起。链表的元素是分开的，其中每个元素都存储了下一个元素的地址。数组的读取速度很快。链表的插入和删除速度很快。在同一个数组中，所有元素的类型都必须相同（都为int、double等） 数字和链表区别：数组： 连续空间， 预留空间， 查找方便， 插入麻烦，必须移动后面的所有元素，如果没有空间，必须将数组复制到其他地方。链表： 分散空间，查找麻烦，插入方便，只需移动前面元素指向的地址。 数组 链表 读取 O（1） O（n） 插入 O（n） O（1） 删除 O（n） O(1) 访问 顺序访问 随机访问 O(n)=线性时间O(1)=常量时间 递归每个递归函数都有两部分：基线条件 （base case）和递归条件 （recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。12345678 def fact(x): if x&lt;=1: #----基线条件 return 1 else: fact(x-1) #---递归条件print(fact(6)) 我们拿 最大公约数 来举例： 思想： 假定x &gt; y（如果x &lt; y，则互换）求x对y的余数，假定余数为z求y与z的最大公约数即为x，与y的最大公约数0没有公约数 最小公倍数 ：思想： 两个数(x, y)的最小公倍数数的算法为：两个数相乘再除以他们的最大公约数0没有公倍数 公约数，公倍数，适用于自然数。 快速排序思想： 少于2个元素的数组不需要排序找一个元素作为基数小于基数的放一个数组大于基数的放一个数组针对小于基数的数组做快速排序，暂且叫low针对大于基数的数组做快速排序, 暂且叫high最终排序后的 low + 【基数】+ high，就是排好序的数组 总结下： D&amp;C算法（divided and conqure）是递归的。使用D&amp;C解决问题的过程包括两个步骤。(1) 找出基线条件，这种条件必须尽可能简单。(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。 散列表（Hash Table）散列函数： 散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。散列函数总是将同样的输入映射到相同的索引。例如你每次输入iTesting，它返回你的总是同一个数字。散列函数将不同的输入映射到不同的索引。比如iTesting对应6， python对于0. 如果散列函数将不同的键映射到同一个位置，就在这个位置存储一个链表。散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。 结合使用散列函数和数组创建了一种被称为散列表 （hash table）的数据结构。不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典 ，你可使用函数dict 来创建散列表。 散列表被用于大海捞针式的查找，散列表适合用于：模拟映射关系；防止重复；缓存/记住数据，以免服务器再通过处理来生成它们。 总结： 你可以结合散列函数和数组来创建散列表。冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。散列表的查找、插入和删除速度都非常快。散列表适合用于模拟映射关系。一旦填装因子超过0.7，就该调整散列表的长度（通常将数组长度加倍）。散列表可用于缓存数据（例如，在Web服务器上）。散列表非常适合用于防止重复。（填装因子是数组中被占用的位置，例如大小为3的数字，有2个被占用，则填装因子为2/3）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python算法分享系列 -- 查找，排序，递归]]></title>
    <url>%2F2017%2F12%2F19%2F%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%2F%E7%AE%97%E6%B3%95%2FPython%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[沉寂了一段时间，继续学习。算法这个系列我想分享很久了，奈何本身对算法不是特别了解，又找不到合适的载体来分享。最近看了本有趣的算法书， 文中通过图文并茂的讲解给我很大启发，尝试着分享下 需要注意的是， 文中各个算法的写法不是简单的拷贝，算理解思想后拿Python3重新写了遍，分享的代码和书中的例子也稍有不同，加了些日常工作中会做的处理，如有不适，请联系我。 二分查找 –仅当列表是有序的时候才能用思想： 1.目标是找数组中的某一个元素，暂叫item2.找出整个数组中间的那个元素，它下标mid，数组被它一分为二3.比较下标mid对应的元素和item，如果mid对应的元素大，查找范围缩小到mid前面的那一半数组，反之，缩小到mid后的那一半数组4.重复3，直到item==mid 对于包含N个元素的列表，用二分查找最多需要log2 N 步。（对数是幂运算的逆运算） 大O表示法指出了算法有多快。例如，假设列表包含n 个元素。简单查找需要检查每个元素，因此需要执行n 次操作。使用大O表示法，这个运行时间为O (n )。单位秒呢？没有——大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速 。 再来看一个例子。为检查长度为n 的列表，二分查找需要执行log n 次操作。使用大O表示法，这个运行时间怎么表示呢？O (log n )。一般而言，大O表示法按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。 O (log n )，也叫对数时间 ，这样的算法包括二分查找。O (n )，也叫线性时间 ，这样的算法包括简单查找。O (n * log n )，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。O (n 2 )，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。O (n !)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。 大O表示法指出了最糟情况下的运行时间. 选择排序思想： 找出数组中最小的元素把数组中最小的元素pop出来到新的数组里。重复以上操作直到原数组为空 需要存储多个元素时，可使用数组或链表。数组的元素都在一起。链表的元素是分开的，其中每个元素都存储了下一个元素的地址。数组的读取速度很快。链表的插入和删除速度很快。在同一个数组中，所有元素的类型都必须相同（都为int、double等） 数字和链表区别：数组： 连续空间， 预留空间， 查找方便， 插入麻烦，必须移动后面的所有元素，如果没有空间，必须将数组复制到其他地方。链表： 分散空间，查找麻烦，插入方便，只需移动前面元素指向的地址。 数组 链表 读取 O（1） O（n） 插入 O（n） O（1） 删除 O（n） O(1) 访问 顺序访问 随机访问 O(n)=线性时间O(1)=常量时间 递归每个递归函数都有两部分：基线条件 （base case）和递归条件 （recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。12345678 def fact(x): if x&lt;=1: #----基线条件 return 1 else: fact(x-1) #---递归条件print(fact(6)) 我们拿 最大公约数 来举例： 思想： 假定x &gt; y（如果x &lt; y，则互换）求x对y的余数，假定余数为z求y与z的最大公约数即为x，与y的最大公约数0没有公约数 最小公倍数 ：思想： 两个数(x, y)的最小公倍数数的算法为：两个数相乘再除以他们的最大公约数0没有公倍数 公约数，公倍数，适用于自然数。 快速排序思想： 少于2个元素的数组不需要排序找一个元素作为基数小于基数的放一个数组大于基数的放一个数组针对小于基数的数组做快速排序，暂且叫low针对大于基数的数组做快速排序, 暂且叫high最终排序后的 low + 【基数】+ high，就是排好序的数组 总结下： D&amp;C算法（divided and conqure）是递归的。使用D&amp;C解决问题的过程包括两个步骤。(1) 找出基线条件，这种条件必须尽可能简单。(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。 散列表（Hash Table）散列函数： 散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。散列函数总是将同样的输入映射到相同的索引。例如你每次输入iTesting，它返回你的总是同一个数字。散列函数将不同的输入映射到不同的索引。比如iTesting对应6， python对于0. 如果散列函数将不同的键映射到同一个位置，就在这个位置存储一个链表。散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。 结合使用散列函数和数组创建了一种被称为散列表 （hash table）的数据结构。不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典 ，你可使用函数dict 来创建散列表。 散列表被用于大海捞针式的查找，散列表适合用于：模拟映射关系；防止重复；缓存/记住数据，以免服务器再通过处理来生成它们。 总结： 你可以结合散列函数和数组来创建散列表。冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。散列表的查找、插入和删除速度都非常快。散列表适合用于模拟映射关系。一旦填装因子超过0.7，就该调整散列表的长度（通常将数组长度加倍）。散列表可用于缓存数据（例如，在Web服务器上）。散列表非常适合用于防止重复。（填装因子是数组中被占用的位置，例如大小为3的数字，有2个被占用，则填装因子为2/3）]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试往何处去 -- 新时期测试如何面对挑战]]></title>
    <url>%2F2017%2F11%2F22%2F%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F%2F%E6%B5%8B%E8%AF%95%E5%BE%80%E4%BD%95%E5%A4%84%E5%8E%BB%2F</url>
    <content type="text"><![CDATA[本人一向务实，很少务虚，最近参与的讨论比较多，也有一些些感悟，分享给大家。勉强算原创吧，标题起的比较大，恬不知耻，主要为了吸引更多从业人员参与讨论，请见谅。 软件测试从前些年的懵懂发展，大家摸着石头过河， 到大多高校设立软件测试专业， 再到近几年各种测试培训盛行，可谓学术与工程齐备，理论和实践并发展。软件测试的进入门槛，也从真正零基础，各行各业拼命涌入，到现在的要求具备专业的计算机专业能力（包括不限于编程能力），软件测试在企业的受重视程度，特别是互联网行业，也从可有可无，到不可或缺。 随着近年来各行各业对软件的强需求，及大数据，云计算，AI的形成，发展， 各种开发模式被不断引进来解决开发中的问题，传统的瀑布模式几乎被淘汰殆尽，敏捷开发已成强弩之末，DevOps思想又从星星点火，到燎原之势。软件开发人员俨然超越了四个现代化，正寄语我们的征途是星辰大海。 但测试人员，还有很多处在石器时代，过着茹毛饮血，敲敲打打（点点点）的日子。 1. 软件测试的过去 远古时代的软件测试人员，严格遵守开发，测试，发布的瀑布流程，他们不知道，也不关心开发如何实现，严格按照需求说明书，来编写测试用例。等到开发把编译完成的版本送到他面前，他才慢条斯理的对着测试用例，一条条执行，看到跟期望结果不一致的地方，一股脑的当bug提上去， 根本不去想bug的出现原因，了不起把重现步骤，测试环境标记清楚。至于一个root cause提多个bug，按bug量论英雄，不在话下。 2. 软件测试的现在 大浪淘沙，现阶段的软件测试人员，大多认识到了测试及早介入的重要性，也有很多接受了敏捷思想，成了敏捷的脑残粉，特别在敏捷开发的项目中，他们大多主动的从需求分析中介入，努力提升软件的可测性，在Grooming大会，Planning大会上，发出测试的声音，让开发一开始就避免掉某些坑。在测试的形式上，不再拘泥于黑盒测试，把白盒测试，接口测试，性能测试，甚至静态代码分析，代码覆盖率测试也纳入测试的版图，测试在组织的话语权也越来越大。 对于有追求的测试来说，不再仅着眼于辅助开发保证软件的质量，他们把目光放到如何提升团队生产率，加快成功发布上，一系列的测试框架，代码build触发自动化测试，为其它测试提供测试工具，眼花缭乱，不胜枚举。对于测试的先行者来说，他们关注测试人员这个职位存在的必要性，为测试行业摇旗呐喊，在各种开发模式中，布道测试的作用。 3. 软件测试的挑战 直到现在，大部分的测试还具有如下鲜明特点： “提前测试”。 即测试人员在软件发布前测试，软件发布后很少再去测试，Live环境上的测试和监控属于Ops的范畴。 期望结果明确。 即测试人员在一个操作之前，已经提前知道这个操作的结果应该是什么。对于同样的输入，一定会有同样的期望结果。 随着云计算，大数据，人工智能的发展，越来越多的公司把自身业务部署在云上，产品也越来越依赖大数据和人工智能。 加上智能设备的发展，可穿戴设备，甚至裸眼屏幕，将会越来越多，在这个大环境下， 提前测试就不那么适用了。测试遇到的挑战也会越来越大，软件的复杂度进一步增加，”提前测试” 开始力不从心。 Test in Production 势在必行。 对于复杂的提供service的产品来说，例如搜索引擎， 仅仅依靠测试人员设计的测试用例，肯定只能覆盖真实用户的少部分使用情况， 大部分用户如何使用，测试人员无法设计出来。这个时候就需要Test in Production。即便是某一个特定的功能点，同样的输入，在不同的时间段，也不能期望实际输出不发生变化。举例来说，你今天输入 “百度 股票价格” 和明天输入 “百度 股票价格”， 得到的结果可能也不同，这个时候，明确的期望结果，也变得不适用。 测试人员就要把检查的重点，从一个固定的结果转化为观察一个 ”模式/趋势“， 就是说，如果你的输出是 百度今天的股票价格， 或者百度股票的趋势，都是可以接受的，但是出来的结果，如果只有百度，没有股票，就是不对的。 还有，如果你们的服务部署在阿里云，腾讯云上，你的测试方法能跟传统的一样吗？如果你的产品基于大数据智能调整哪些功能展现给哪些用户，你的常规测试方法还有用吗？如果你在测试一个人工智能产品，你还能设计出用户常用的case吗？ 4. 软件测试的未来 新形势下，测试应该怎么做呢？ 某个功能的输入数据，将从测试人员准备变成直接导入真实用户数据，采取例如A/B Test， 金丝雀发布的方式来进行。 测试的结果， 将不在关注具体的确定值，转为记录观察输出的趋势，或者行为模式，即Pattern。 这客观要求测试紧跟新的开发模式/思想， 以DevOps为例， DevOps天然强调持续集成，自动化部署，急速部署，多次部署，那么测试，就要在这个上面发力，部署自触发的自动化测试就必不可少，这样对测试的要求将会越来越高，测试对系统的介入程度，将会越来越深，最终测试即开发，开发即测试。未来， 测试应该会 Test in Production（紧随DevOps，自动化比重会加大）。 测试的检查重点，也会从期望的Test Results 转变为Observed Data/pattern。这个已发生，随着技术的发展，比重将会越来越大。 生产环境的监控比重将越来越大，甚至变成新常态。 5. 软件测试的机遇 近几年发生在软件开发业内的新思想，新方法，主要以开发人员为主导。那么是不是就意味着其它角色生存空间被压缩呢？我认为也是也不是，被压缩的是精益思想本来就要去掉的，所谓的”减少浪费“的浪费部分，如那些 “测试人员自主设计的模拟用户行为的测试” 功能测试部分， 还有手工配置测试环境，及”快速交付给客户“过程中因为运维的原因被常常被堵塞的部分。 对于测试人员来说， 困难和机遇并存，新的技术/思想固然层出不穷，但不必戚戚然，一个产品要顺利交付给客户，必不可少要把住质量关，测试人员（我们现在常叫QA，质量保证人员）只需牢记任何思想的演进都是为了快速成功的交付这个原则，测试人员应该通过各种手段，为这个目标增加测试的价值。 测试人员应该牢记，你不仅仅是测试，你是整个产品团队的一部分，你对团队的整体效率负责，你存在的价值是帮助组织快速交付。 测试这个职位有可能会消失，但是每一个组织，每一个客户对软件质量的要求不仅不会消失，还会不断增强，这将会是测试人员最好的时代，是属于我们测试的改革开放，每一个测试人员都应该趁着行业东风，努力做这个伟大时代的弄潮儿！ 参考资料：http://blog.csdn.net/zhubaitian/article/details/50203263http://www.infoq.com/cn/articles/detail-analysis-of-devopshttps://dojo.ministryoftesting.com/lessons/the-future-of-software-testing-part-onehttps://dojo.ministryoftesting.com/lessons/the-future-of-software-testing-part-two]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>测试感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python自动化测试--关于datetime的一点思考2]]></title>
    <url>%2F2017%2F10%2F30%2FPython%E7%9F%A5%E8%AF%86%2FPython%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95--%E5%85%B3%E4%BA%8Edatetime%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%832%2F</url>
    <content type="text"><![CDATA[还记得我们前面讲过的Python自动化测试–关于datetime的一点思考吗？我们使用pytz来处理时间，最后还自己实现了一个时间类来更好的处理现实问题，今天我们介绍一个更加方便的方式： Arrow: better dates and times for Python。 1.安装12#url http://arrow.readthedocs.io/en/latest/pip install arrow 2.简单使用123456789101112import arrowutc = arrow.utcnow()print(utc)#输出：&gt;2017-10-30T05:59:06.678566+00:00utc = arrow.now()print(utc)#输出：&gt;2017-10-30T13:59:06.678566+08:00 可以看到，qrrow带有时区信息。 还记得我们上次讲过的datetime类型吗？ 由此可见，arrow的时间是time clock aware的。 跟datetime的 naive类型不一样。那么，如果我们想得到navie类型的时间，该怎么做呢？ 1234567import arrowutc = arrow.utcnow().naiveprint(utc)#输出：&gt;2017-10-30 14:29:22.418641 3.其它常用方法 arrow.get(x) 123456789101112131415161718192021222324252627282930313233import arrowfrom datetime import datetime&gt; ** Create from timestamps (ints or floats, or strings that convert to a float): **print(arrow.get(1499900664))#输出：&gt;2017-07-12T23:04:24+00:00&gt; ** Use a naive or timezone-aware datetime, or flexibly specify a timezone: **print(arrow.get(datetime.utcnow()))#输出：&gt;2017-10-30T06:39:42.114556+00:00 print(arrow.get(datetime(2017, 10, 30), tz.gettz('US/Pacific')))#输出：&gt;2017-10-30T00:00:00-07:00print(arrow.get(datetime.now(tz.gettz('Asia/Shanghai'))))#输出：&gt;2017-10-30T14:45:44.807080+08:00&gt; ** Parse from a string: **print(arrow.get('2017-10-30 12:30:45', 'YYYY-MM-DD HH:mm:ss'))#输出：&gt;2017-10-30T12:30:45+00:00&gt; ** Search a date in a string: **print(arrow.get('iTesting is awesome October 2017', 'MMMM YYYY'))#输出：&gt;2017-10-01T00:00:00+00:00arrow还可以自动识别字符串中的时间信息，并转为时间，不过这个功能不强大，例如字符串中有特殊符号或多个空格就会失败 Properties 1234567** Get a naive datetime, and tzinfo **import arrowa = arrow.now('US/Pacific')print(a.tzinfo)#输出：&gt;tzfile('US/Pacific') Get any datetime value: 123456789import arrowa = arrow.now('US/Pacific')print(a.year)print(a.month)print(a.day)#输出：&gt;20171030 Call datetime functions that return properties: 12345print(a.date())print(a.time())#输出：&gt;2017-10-3000:34:14.689940 Replace&amp;Shift 更改时间 1234567import arrowa = arrow.now()print(a)print(a.replace(hour=1, minutes=30))#输出：&gt;2017-10-30T15:38:28.064605+08:002017-10-30T02:08:28.064605+08:00 Format 1234import arrowprint(arrow.now().format('YYYY-MM-DD HH:mm:ss ZZ'))#输出：&gt;2017-10-30 15:40:55 +08:00 Convert 时间转换 1234567891011121314151617import arrowprint(arrow.utcnow().to('Asia/Shanghai'))#输出：&gt;2017-10-30T15:42:30.510084+08:00#arrow还帮我们实现了daylight saving的自动转换：t1 = arrow.get(datetime(2017, 11, 5, 1, 59), 'US/Eastern')print(t1)t1 = arrow.get(datetime(2017, 11, 5, 2, 00), 'US/Eastern')print(t1)#输出：&gt;2017-11-05T01:59:00-04:002017-11-05T02:00:00-05:00可以看到，时区信息自动切换了， 这个就比pytz里的方法方便，不需要再把时间给normize了。 以上就是arrow的大致用法，是不是比pytz要简单些？ 对应到我们前面的问题，如何判断t1==t2呢？1234#t1, &lt;class 'datetime.datetime'&gt;， 时区Eastern time2017-08-22 08:49:38#t2, &lt;class 'datetime.datetime'&gt;， 无时区信息 2017-08-22 20:49:38 答案不言而喻：123456789import arrownaive_t1 = arrow.get('2017-11-05 02:00:00').naivet1 = arrow.get(naive_t1, 'US/Eastern')print(t1.to('local'))navie_t2 = arrow.get('2017-11-05 15:00:00').naivet2 = arrow.get(navie_t2, 'Asia/Shanghai')assert t1== t2 总结一下， arrow是一个非常优秀的关于时间处理的第三方库，有了它，你可以更高效的处理时间参数了！]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>datetime</tag>
        <tag>Arrow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QA如何做静态代码分析]]></title>
    <url>%2F2017%2F09%2F27%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FQA%E5%A6%82%E4%BD%95%E5%81%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[及早的介入测试已经成为软件测试界的共识，对逼格较高的QA（别有用心的人才会争论QA！=测试，）来说，已经不满足从从需求分析介入项目开发过程了。如果我们能掌握一门技术，当开发提交代码的一刹那，我就知道这次代码改动的质量如何，是不是引进了新的bug，哪行代码写的不好，哪个功能需要重构， 你觉得开发会不会对你更加佩服呢？（蜜汁微笑） 如果你发现你家厨房地上有一摊水，你是选择拿抹布擦掉就完了呢还是寻找下哪里在漏水？ 静态代码检查可以使得我们在代码提交的一刹那就发现项目中的潜在问题，今天我就来讲讲如何使用SonarQube做静态代码检查。Why SonarQube? SonarQube provides the capability to not only show health of an application but also to highlight issues newly introduced.With a Quality Gate in place, you can fix the leak and therefore improve code quality systematically.Supports multiple programming languages (20+)Centrialize quality with reports and gatesContinuous inspection and DevOps integrationFollow standards: MISRA, CERT, CWE, OWASP…Large user groups: 80,000+ organizations 1.安装如果你的代码以java开发，你需要事先安装：Java JDK 8DB（SQL Server， MySQL， Oracle， PostgreSQL）， Sonar需要一个数据库来存储结果,Apache Derby 是Sonar自带并且默认安装使用的数据库,它能很好的用于Sonar的演示.但在实际项目中推荐使用性能更好更强大的数据库。 以我的项目Python为例，我略过过JDK 和DB（使用sonar默认）的安装，直接：从这个页面下载SonarQube server.从这个页面下载Sonar Scanner.下载完毕后解压，在目标文件夹下的sonarqube-6.5\bin 目录下，根据你机器的系统选择文件夹打开，这里选择windows-x86-64， 看到如下文件了吗？依次以管理员身份运行前3个bat命令，然后通过web打开页面http://localhost:9000， 如果你看到了下述页面，说明安装成功： 2.配置由于我使用默认的db，故略过DB配置部分，直接来看基本配置：首先，点击右上角的Login， 使用默认密码，admin， admin登录， 系统引导你生成一个新的project：其次，看右边的提示，系统会让你去下载并安装配置sonarQube Scanner.我们前面已经安装了，略过安装，直接配置，把scanner的bin目录加入你的环境变量：在scanner的bin目录下， 打开sonar-scanner.properties并配置如下：然后CMD命令执行 sonar-scanner， 你会看到：这样就说明 scanner配置成功了，我们来分析下我们的项目把！ 3.使用找到你要scann的项目目录的code repository，在根目录下建立并更新 sonar-project.properties 文件：举例来说，我有一个ASD_API的项目，我在这个项目根目录下建立文件并修改如下：需要注意的是projectName就是显示在网页上的项目，一般跟你的项目名称一致。sources就是项目所在的文件夹。其它按提示。 最后CMD, 定位到你项目所在的文件夹 ，在命令行中输入：1sonar-scanner成功后你会看到： 此时切换到 http://localost:9000, 你将会看到：可以看出来，此次代码改动是passed的，代码的Reliability， Security， Maintainability都很好，质量还不错嘛～ 我们点击项目名称ASD_API查看详细信息。细节处有魔鬼呀，看来此次改动还有不少问题，主要集中在code smell上：从图中可以看出技术债务需要偿还，大约会花费1小时左右，另外还有21处不符合代码规范的地方，我们点击debt看细节：SonarQube贴心的列出来了需要改动的地方，高亮显示并给出了修改建议：点击我标红的部分，可以看到详细需要改动的地方，有一个分支我没有写完： 如果代码质量太差，你会看到： 想象一下，你直接告诉开发，你某个文件的某一行写的简直像个粑粑，他看后大呼，原来刘项也读书呀！是不是非常刺激？是不是非常惊喜？根据Sonar Scanner的扫描结果，依次review每次code change，是不是感觉对质量的把控更加有自信了? SonarQube可以从以下几个维度来分析代码质量： 我们可以根据SonarQube 扫描出来的结果，结合项目实际，建议开发修改. 如果你们的项目跟jenkins集成，还可以添加SonarQube插件，这样每一个build生成后都会有相应的代码分析结果参考。利用SonarQube进行静态代码分析， 真正做到了从源头解决问题，也使得我们测试人员对代码改动更有信心，怎么样？ 赶快用起来吧！]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>Code-analysis</tag>
        <tag>white box</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python自动化测试--关于datetime的一点思考]]></title>
    <url>%2F2017%2F08%2F23%2FPython%E7%9F%A5%E8%AF%86%2FPython%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95--%E5%85%B3%E4%BA%8Edatetime%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[在测试自动化特别是API测试当中，经常遇见这样的case，一个API的返回值是另外一个API的入参，虽然入参和返回值都是一个时间，但入参是datetime类型的变量，返回值是个str类型的变量。 那么如何处理这些时间变量呢？如果这些时间变量跟时区， 夏令时结合在一起时候，如何处理呢？ 在我的测试过程中，我遇见这样一个问题1.一个页面的Book API需要传入一个课的开始时间，这个时间格式要求是string，例如”2017-08-22 08:49:38”2.Book成功后的返回值包含了一个字典，其中包含时间，也是string格式，但是这个值带时区属性，例如 “starttime_est”:”2017-08-22 08:49:38”.3.另外一个显示已定课的booked API，也包含一个string格式的时间，但是不带时区信息，默认是local time， 格式如下：”2017-08-22 20:49:38”那么我现在定了一节eastern的开始时间是”2017-08-22 08:49:38”的课，我页面上看到的是”2017-08-22 20:49:38”, 我如何来验证这节课就是我定的课呢？ Python中对时间的处理，我们一般用datetime模块，datetime对于string和datetime的转换，我们一般用strptime， strftime来实现。 123456789101112131415from datetime import datetime#类型&lt;class 'datetime.datetime'&gt;， 时区Eastern timet1 = datetime.now() # 这里假设我们当前时间是Eastern time的2017-08-22 08:49:38#类型&lt;class 'str'&gt;t2 = "2017-08-22 20:49:38"#由日期格式转化为字符串格式t1.strftime('%Y-%m-%d %H:%M:%S')#由字符串格式转换为日期格式datetime.strptime(t2, '%Y-%m-%d %H:%M:%S') 其中，时间格式定义如下： 123456789101112131415161718192021222324252627# datetime. strftime (format) # %a 星期的简写。如 星期三为Web # %A 星期的全写。如 星期三为Wednesday # %b 月份的简写。如4月份为Apr # %B 月份的全写。如4月份为April # %c: 日期时间的字符串表示。（如： 08/22/17 10:00:00 local：us） # %d: 日在这个月中的天数（是这个月的第几天） # %f: 微秒（范围[0,999999]） # %H: 小时（24小时制，[0, 23]） # %I: 小时（12小时制，[0, 11]） # %j: 日在年中的天数 [001,366]（是当年的第几天） # %m: 月份（[01,12]） # %M: 分钟（[00,59]） # %p: AM或者PM # %S: 秒（范围为[00,61]） # %U: 周在当年的周数当年的第几周），星期天作为周的第一天 # %w: 今天在这周的天数，范围为[0, 6]，6表示星期天 # %W: 周在当年的周数（是当年的第几周），星期一作为周的第一天 # %x: 日期字符串（如：08/22/17） # %X: 时间字符串（如：10:00:00 # %y: 2个数字表示的年份 # %Y: 4个数字表示的年份 # %z: 与utc时间的间隔 （如果是本地时间，返回空字符串） # %Z: 时区名称（如果是本地时间，返回空字符串） 看起来很简单嘛，字符串类型的t2直接用strptime就转换成时间了呀，等等，t1本来是等于t2的，这样转换后t1和t2分别为：1234#t1, &lt;class 'datetime.datetime'&gt;， 时区Eastern time2017-08-22 08:49:38#t2, &lt;class 'datetime.datetime'&gt;， 无时区信息 2017-08-22 20:49:38 assert t1==t2的结果是False， 为什么呢？因为 t1是aware的时间， t2是naive的时间。 他们的详细区别如下： There are two kinds of date and time objects: “naive” and “aware”. An aware object has sufficient knowledge of applicable algorithmic and political time adjustments, such as time zone and daylight saving time information, to locate itself relative to other aware objects. An aware object is used to represent a specific moment in time that is not open to interpretation A naive object does not contain enough information to unambiguously locate itself relative to other date/time objects. Whether a naive object represents Coordinated Universal Time (UTC), local time, or time in some other timezone is purely up to the program, just like it’s up to the program whether a particular number represents metres, miles, or mass. Naive objects are easy to understand and to work with, at the cost of ignoring some aspects of reality. 很不幸运的是，datetime模块模式生成的是naive类型的datetime对象，例如now（）， utcnow（）。要想生成aware类型的，可以使用now()接受一个tzinfo对象来生成，但是标准库并不提供任何已实现的tzinfo类。 那么自己实现一个了： 123456789101112131415161718192021#注意，一个tzinfo类需要实现utcoffset、dst和tzname这3个方法"""tzinfo是关于时区信息的类tzinfo是一个抽象类，所以不能直接被实例化"""class UTC(tzinfo): """UTC""" def __init__(self,offset = 0): self._offset = offset def utcoffset(self, dt): return timedelta(hours=self._offset) def tzname(self, dt): return "UTC +%s" % self._offset def dst(self, dt): return timedelta(hours=self._offset) 回到本题中来，我eastern time的时间就解决了123t2 = datetime(2017,8,22,8,49,38, tzinfo=UTC(-5))看似没毛病对不对？那是我们没考虑daylight saving啊！ 今天Eastern time跟UTC时间相差是-4，到夏令时结束时候，那么就是-5，再有，我国不实行夏令时，有些国家只有某些地区用夏令时，有些不用。这样我传入的参数-5，-4，都是Eastern time，那我怎么知道这个offset是多少呢？再写个函数判断这些？要累死吧，说不定还写不出来。这时候就需要巨人的肩膀了， pytz这个第3方库保证了时间的精准性和解决了daylight saving时间切换的问题， 来看看它怎么用。1.安装： 12#url https://pypi.python.org/pypi/pytzpython setup.py install 2.设定时区： 12345678910111213from datetime import datetime, timedeltafrom pytz import timezoneimport pytz #给定一个国家代码，拿到这个国家的时区列表print(pytz.country_timezones('CN'))#选择一个时区 c = pytz.country_timezones('CN')[0]#设定时区 tz = pytz.timezone(c) print(tz)#生成当前时区的时间，这个时间带时区信息 print (datetime.now(tz)) 3.使用 12345678 #设定正八时区 tz = pytz.timezone(pytz.country_timezones('CN')[0]) dt = datetime(2017,8,22,20,45,45, tzinfo=tz) #生成当前时区的时间，这个时间带时区信息 print (dt) #### 打印结果如下：2017-08-22 20:45:45+08:06 大家发现问题了没有。默认的正八区，跟UTC的差距不是+8：00，而是+8：06， 这个是构造时区时没有使用naive的时间。pytz构造本地时间只支持两种方式,且都只能localize naive datetime：12345678910111213141516from datetime import datetime, timedeltafrom pytz import timezoneimport pytztz = pytz.timezone(pytz.country_timezones('CN')[0])#方法1：local_dt = tz.localize(datetime(2017,8,22,20,45,45))print(local_dt)#打印结果如下：2017-08-22 20:45:45+08:00#方法2：tz2 = timezone("US/Eastern")eastern = local_dt.astimezone(tz2)print (eastern)#打印结果如下：2017-08-22 08:45:45-04:00 pytz建议我们处理时间一律用UTC的方式， 只有你需要看输出的结果时，才把它转为本地时间。12345import pytzfrom datetime import datetimeprint(datetime(2002, 10, 27, 12, 0, 0, tzinfo=pytz.utc)) 4.要注意的问题： 如果你需要处理夏令时和时区的转换，pytz推荐我们使用normalize（）这个方法, 举例来说，东部时间2017-03-12 日凌晨2点是夏令时起效时间。123456789101112131415161718192021222324import pytzfrom datetime import datetimeeastern = pytz.timezone('US/Eastern')dt4 = datetime(2017, 3, 12, 2, 00)dt4 = eastern.localize(dt4)print (dt4)print (dt4.tzinfo)#打印结果如下：2017-03-12 02:00:00-05:00US/Easterndt6 = eastern.normalize(dt4)print (dt6)print (dt6.tzinfo)#打印结果如下：2017-03-12 03:00:00-04:00US/Eastern可以看到，如果不用normalize（），到夏令时起效时，不会自动帮我们转换时间。如果把dt4的值改为dt4 = datetime(2017, 3, 12, 3, 00)那么2此的结果一致，均为 2017-03-12 03:00:00-04:00 到此，我们就掌握了对datetime的如下操作：1.string 和datetime的转换 –strftime， strptime2.时区的转换。 –timezone（tz）， tz.localize(dt)3.夏令时的转换。 – tz.normalize(dt) 最后再来看看我们的问题如何解决：123456789101112131415from pytz import timezonefrom datetime import datetimetz1 = timezone('US/Eastern')t1 =datetime(2017,8,22,8,49,38)t1 = tz1.localize(t1)print(t1)tz2 = timezone('Asia/Shanghai')t2 = datetime.strptime('2017-08-22 20:49:38', '%Y-%m-%d %H:%M:%S')t2 = tz2.localize(t2)print(t2)assert t1==t2 文章的最后，放出我自己封装的一个datetime处理类,以后处理datetime，直接使用即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#datetime_helper.pyfrom datetime import datetimefrom pytz import timezoneimport pytzclass TimeZone: UTC = pytz.utc Eastern = timezone('US/Eastern') ChinaZone = timezone('Asia/Shanghai')class TimeHelper: """ There are two kinds of date and time objects: “naive” and “aware”. An aware object has sufficient knowledge of applicable algorithmic and political time adjustments, such as time zone and daylight saving time information A naive object does not contain enough information to unambiguously locate itself relative to other date/time objects. Whether a naive object represents Coordinated Universal Time (UTC), local time, or time in some other timezone is purely up to the program """ Format = "%Y-%m-%d %H:%M:%S" @staticmethod def utc_time(naive_dt): dt = TimeZone.UTC.localize(naive_dt) return TimeZone.UTC.normalize(dt) @staticmethod def eastern_time(naive_dt): dt = TimeZone.Eastern.localize(naive_dt) return TimeZone.Eastern.normalize(dt) @staticmethod def china_time(naive_dt): dt = TimeZone.ChinaZone.localize(naive_dt) return TimeZone.ChinaZone.normalize(dt) @staticmethod def switch_timezone(aware_dt, tz): return aware_dt.astimezone(tz) @staticmethod def dt_strf(dt, fmt=Format): return dt.strftime(fmt)]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>datetime</tag>
        <tag>pytz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何高效组织自动化测试用例]]></title>
    <url>%2F2017%2F07%2F06%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%BB%84%E7%BB%87%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[自动化测试用例写多了，不可避免会遇到这个问题,每次运行无需运行所有的用例，那么如何把要运行的用例挑出来并高效组织它们呢？一般说来，通用的做法都是把要运行的用例用特殊标记Mark出来，然后框架运行时，自动寻找这些带标记的case，并把它们装到一个新的test suite里。所以高效组织测试用例的关键就是两部分： 1. 如何标记待测试用例.2. 运行时如何收集这些带标记的用例。以下列出来我经历过的方法： 1.给所有的测试用例编号，把测试用例按照 编号， summary， Path， ClassName， 测试运行与否的flag等等，写到一个外部文件里，通常是Excel，每次测试框架运行时，先去这个文件里，一行一行的读文件，如果发现“测试运行与否的flag”的值是True， 就把这条case拿出来放到一个临时变量里，读完整个文件，就拿到了所有要运行的case， 这个时候，导入这个case需要的所有依赖，运行这个case，并把运行结果写回到一个results的文件里。 那么，改动老的case，增加新的case，怎么办呢？勤快一点的，每写一个/更改一个自动化用例，手工更新这个外部表格。 懒一点的，写一段代码，每写/改一个case，手工运行这段代码，把更改写进去。 2.利用装饰器，经典的如TestNG，可以在测试用例前加@BeforeSuite， 今天要讲的也是这个。如何在python里实现。先说下思想： 我期望自动化测试运行时候，可以根据我提供的不同的tag，运行不同的测试用例。 前提是我写自动化用例的时需给每个测试用例，都加上tag并赋值。在运行时候，框架通过我提供的不同的tag，去找这些被标记的case，然后组织起来运行。 要实现这个，我们需要接收用户参数，可以用： 1.sys.argv[1:]来自己写代码处理，也可以用标准库argparse来，我们用后者。argparse 的用法很直观, 先看段代码：： 123456789101. 先创建一个parser： parser = argparse.ArgumentParser(prog='para')2. 加入一些参数：parser.add_argument('-w', action='store', default='.', help='specify the work space')parser.add_argument('-target', action='store', help='specify the run target file')parser.add_argument('-tag', action='store', help='run by tag')parser.add_argument('-n', action='store', help='concurrent user')3. Parseing 这些参数options = parser.parse_args()print （options） 这个时候，如在command line里输入1python __init__.py -target test -tag smoke -n 3 就会得到如下结果： 12 Namespace(n='3', tag='smoke', target='test', w='.')使用argparse就可以方便的获取用户参数，并处理。关于argparse的用法，请参考官网。 2.用户输入的参数我们接收处理了,那么如何处理这些tag呢，这就要用到装饰器：123456789101112 def TestCase(enabled=True, tags=None, **kwargs): def tracer(cls): cls.__type__ = 'Test' cls.__enabled__ = enabled if not tags: cls.__tags__ = None else: # 想想看，如果tag有好几个，这块代码应该怎么改 cls.__tags__ = tags return cls return tracer 上面的代码呢，我们定义了一个装饰器，这个装饰器唯一的作用，是接收传入的类，然后给这些类增加一些属性，这些属性后续用来判断是否要执行。 使用时在新建立测试类上加上@Testcase即可。 3.测试用例类，这些测试类或者测试类中的函数实现了一个个的功能。12345678910111213141516 class RealTest(): @TestCase(tags='smoke') def test1(self): logging.info("this is test 1") time.sleep(5) @TestCase(enabled=True, tags='smoke') def test2(self): logging.info("this is test2") time.sleep(5) @TestCase(enabled=False, tags='smoke') def test3(self): logging.info("this is test3") time.sleep(5) 我们可以利用装饰器里的tag参数， enable参数来实现测试用例的筛选。 4.我们再定义一个类，这个类作为一个test case的执行器，把要运行的测试用例装进来，并发，或者顺序执行。12345678910111213141516 class TestExecutor(threading.Thread): def __init__(self, cls, worker): threading.Thread.__init__(self) self.cls = cls self.workers = worker self._lock = threading.RLock() def run(self): self.workers.acquire() logging.info("Thread &#123;threadname&#125;".format(threadname=self.current_executor())) self.cls(self) self.workers.release() def current_executor(self): return threading.current_thread() 5.利用threading.Semaphore实现线程并发限制。6.实现：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import argparseimport threadingimport timeimport logginglogging.basicConfig(level=logging.INFO , format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')def TestCase(enabled=True, tags=None, **kwargs): def tracer(cls): cls.__type__ = 'Test' cls.__enabled__ = enabled if not tags: cls.__tags__ = None else: # 想想看，如果tag有好几个，这块代码应该怎么改 cls.__tags__ = tags return cls return tracerclass TestExecutor(threading.Thread): def __init__(self, cls, worker): threading.Thread.__init__(self) self.cls = cls self.workers = worker self._lock = threading.RLock() def run(self): self.workers.acquire() logging.info("Thread &#123;threadname&#125;".format(threadname=self.current_executor())) self.cls(self) self.workers.release() def current_executor(self): return threading.current_thread()class RealTest(): @TestCase(tags='smoke') def test1(self): logging.info("this is test 1") time.sleep(5) @TestCase(enabled=True, tags='smoke') def test2(self): logging.info("this is test2") time.sleep(5) @TestCase(enabled=True, tags='smoke') def test3(self): logging.info("this is test3") time.sleep(5)if __name__ == "__main__": s = threading.Semaphore(2) parser = argparse.ArgumentParser(prog='para') parser.add_argument('-w', action='store', default='.', help='specify the work space') parser.add_argument('-target', action='store', help='specify the run target file') parser.add_argument('-tag', action='store', help='run by tag') parser.add_argument('-n', action='store', help='concurrent user') options = parser.parse_args() real_cases = [] for module_element in dir(RealTest): pre_test_class = getattr(RealTest,module_element) # @Mark if options.tag: if hasattr(pre_test_class, "__type__") and \ hasattr(pre_test_class, "__enabled__") \ and pre_test_class.__enabled__\ and hasattr(pre_test_class, "__tags__")\ and pre_test_class.__tags__ \ and pre_test_class.__tags__.lower() == options.tag.lower(): real_cases.append(pre_test_class) threads = [] for item in real_cases: threads.append(TestExecutor(item, s)) for t in threads: t.start() for t in threads: t.join() 这里重点讲下标记为 1#@Mark 的语句，实际上这个就是如何把标记的case挑选出来的核心方法。我们使用了反射机制 反射： 有时候我们会碰到这样的需求，需要执行对象的某个方法，或是需要对对象的某个字段赋值，而方法名或是字段名在编码代码时并不能确定，需要通过参数传递字符串的形式输入。举个具体的例子：当我们需要实现一个通用的DBM框架时，可能需要对数据对象的字段赋值，但我们无法预知用到这个框架的数据对象都有些什么字段，换言之，我们在写框架的时候需要通过某种机制访问未知的属性。这个机制被称为反射（反过来让对象告诉我们他是什么），或是自省 dir([obj]):调用这个方法将返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。 hasattr(obj, attr):这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。 getattr(obj, attr):调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为’bar’，则返回obj.bar。 对于所有的测试类，我们会逐个把他们导入（示例里无这段代码，关于case class的导入可以根据 -target这个参数的值来代码实现，此处未展示。）对于每一个类，我们通过dir（）， getattr（）拿到测试类所有的可用方法，然后这些方法因为有装饰器TestCase的加持，我们可以顺利的根据参数-tags拿到要运行的测试用例。然后我们根据拿到的每一个测试用例,判断它们是否有需要的属性（ enabled，type）， 然后对于每个有这个属性的用例，我们在放到真正运行的测试用例list里。最后对测试用例list的用例，每一个都放入TestExecutor里执行，TestExecutor 实现了多线程及多线程限制。 我们来看下运行效果：输入：python Android/init.py -target test -tag smoke -n 3输出：因为我们限制了并发线程数为2， 所以我们先看到以下输出。12345Namespace(n='3', tag='smoke', target='test', w='.')2017-07-07 20:01:25,009 - __init__.py[line:31] - INFO: Thread &lt;TestExecutor(Thread-1, started 11284)&gt;2017-07-07 20:01:25,009 - __init__.py[line:42] - INFO: this is test 12017-07-07 20:01:25,009 - __init__.py[line:31] - INFO: Thread &lt;TestExecutor(Thread-2, started 10196)&gt;2017-07-07 20:01:25,010 - __init__.py[line:47] - INFO: this is test25秒后，又看到如下：122017-07-07 20:01:30,010 - __init__.py[line:31] - INFO: Thread &lt;TestExecutor(Thread-3, started 14156)&gt;2017-07-07 20:01:30,011 - __init__.py[line:52] - INFO: this is test3 如此一来，我们仅需要写测试用例时，添加合适的tag，然后运行时用参数区分，就可以不修改代码的的情况下运行不同的case了。]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>自动化测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appium自动化框架入门实践]]></title>
    <url>%2F2017%2F06%2F14%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FAppium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[如何在Windows上搭建Appium测试框架？ 环境安装 Download latest node and npm tools MSI (version &gt;= 6.0). The npm and nodejs paths should be in your PATH environment variable. Open admin cmd prompt, Run the command npm install -g appium which will install Appium from NPM To start Appium, you can now simply run appium from the prompt. 3.1 On Windows run Appium.exe as an administrator, or when running from source you need to run cmd as an administrator. 3.2 You must supply the –no-reset or –full-reset flags for Android to work on Windows, all other flags are here Follow the directions below for setup for either Android or Windows app testing. 4.1 Download the latest Java JDK. Set ‘JAVA_HOME’ to be your JDK path. The bin in that directory should be added to your PATH variable. 4.2 Install the Android SDK. Set the ANDROID_HOME environment variable to be your Android SDK path and add the tools and platform-tools folders to your PATH variable. 4.3 To run tests on Windows, you will need to have the Android Emulator booted or an Android Device connected that is running an AVD with API Level 17 or greater. Then run Appium on the command line (via the appium command) 4.4 Your test script should ensure that the platformVersion capability corresponds to the emulator or device version you are testing, and that the app capability is an absolute path to the .apk file of the Android app. Install the Python client library pip install Appium-Python-Client Run a test from any Appium client. 6.1 real device 6.2 simulator–Genymotion 元素识别我们用真机来测试，windows平台上appium只有android配置项，首先打开appium， 配置如下： 解释如下：Application path: apk路径Capabilities: automationName Which automation engine to use Appium (default) or Selendroid platformName Which mobile OS platform to use iOS, Android, or FirefoxOS platformVersion Mobile OS version e.g., 7.1, 4.4 deviceName: command line 运行 adb devices 得到的结果。 noReset Don’t reset app state before this session. See here for more details true, false fullReset Perform a complete reset. See here for more details true, false注意，在windows平台上， fullreset 和noreset一定要选一个。 点击右上角的launch the appium node启动appium，点击inpect图标，等server起来后，在device上打开要测试的app。 这个就列出来当前页面的各个元素，方便我们识别元素。 对于Android来说，android SDK 有个自带的ui automation viewer也同样可以用，打开来如下（同样要求连接设备） 元素识别对于mobile的元素识别，参看我之前文章：UIAutomation Viewer定位Android APP元素利用Android UiSelector（）类来定位元素iOS自动化测试之元素定位 简单示例我们以我司的一个app为例，测试下内容：1.Launch app，输入错误的用户名和密码2.点击登录3.验证弹出错误对话框中的text为Username or password incorrect。示例如下： 保持上一步appium的配置，启动launch the appium node后， 代码如下：12345678910111213141516171819202122232425262728293031323334import timefrom appium import webdriverclass TestAPP(): desired_caps = &#123;&#125; desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '5.0' desired_caps['deviceName'] = 'a92e11aa' desired_caps['app'] = r"D:/_Automation/Mobile_FrameWork/EvcMobile/apps/evc.apk" def __init__(self): self.browser = webdriver.Remote('http://localhost:4723/wd/hub', self.desired_caps) def set_username_or_email(self, username): time.sleep(10) self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/username']").click() self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/username']").send_keys(username) def set_password(self, password): self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/password']").click() self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/password']").send_keys(password) def click_login_button(self): self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/login']").click()if __name__ == "__main__": test = TestAPP() test.set_username_or_email("iTesting") test.set_password(1) test.click_login_button() time.sleep(1) print (test.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/notificationText']").get_attribute('text')) assert test.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/notificationText']").get_attribute('text') == "Username or password incorrect" 正常运行，代码没有问题，appium自动化的第一步就算完成了。 框架优化step 1 ，分离测试代码和被测试app， 并添加测试框架unittest，：123456789101112131415161718192021222324252627282930313233343536373839404142434445import unittestimport timefrom appium import webdriverclass EFAPP(): def __init__(self, driver): self.browser = driver def set_username_or_email(self, username): time.sleep(10) self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/username']").click() self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/username']").send_keys(username) def set_password(self, password): self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/password']").click() self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/password']").send_keys(password) def click_login_button(self): self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/login']").click() time.sleep(2) assert self.browser.find_element_by_xpath("//*[@resource-id='com.ef.evc2015:id/notificationText']").get_attribute('text') == "Username or password incorrect"class EFAPPTests(unittest.TestCase): def setUp(self): desired_caps = &#123;&#125; desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '5.0' desired_caps['deviceName'] = 'a92e11aa' desired_caps['app'] = r"D:/_Automation/Mobile_FrameWork/EvcMobile/apps/evc.apk" self.browser = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) def test_login_failure(self): ef_app = EFAPP(self.browser) ef_app.set_username_or_email("iTesting") ef_app.set_password(1) ef_app.click_login_button() def tearDown(self): self.browser.quit()if __name__ == "__main__": suite = unittest.TestLoader().loadTestsFromTestCase(EFAPPTests) unittest.TextTestRunner(verbosity=2).run(suite) 运行结果如下： 看起来像大功告成了，不过还有一个问题，所有的待测元素全都写在方法内部，不利于管理和重用，每次xpath改动，都需要改动每个方法。 框架优化step 2， 加入page_object模式。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import unittestimport timefrom abc import ABCMeta, abstractmethodfrom DateTime import DateTimefrom assertpy import assert_thatfrom page_objects import PageObject, PageElementfrom appium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.wait import WebDriverWaitclass BasePage(PageObject): __metaclass__ = ABCMeta WAIT_FOR_SCROLL_TIME = 2 def __init__(self, driver): # Don't change the variable name w. it's used by PageObject self.w = driver self.driver = driver assert_that(self.has_loaded()).is_true() def has_loaded(self): try: return self.is_target_page() except NoSuchElementException: return False # This function will be implement by sub class @abstractmethod def is_target_page(self): pass def is_element_displayed(self, by, value, timeout=60): return WebDriverWait(self.driver, timeout).until( lambda driver: driver.find_element(by, value).is_displayed())class EFAPP(BasePage): EMAIL_OR_USERNAME_TEXT_FIELD_XPATH ="//*[@resource-id='com.ef.evc2015:id/username']" PASSWORD_TEXT_FIELD_XPATH = "//*[@resource-id='com.ef.evc2015:id/password']" LOGIN_BUTTON_XPATH = "//*[@resource-id='com.ef.evc2015:id/login']" LOGIN_ERROR_XPATH = "//*[@resource-id='com.ef.evc2015:id/notificationText']" email_or_username_text_field = PageElement(xpath=EMAIL_OR_USERNAME_TEXT_FIELD_XPATH) password_text_field = PageElement(xpath=PASSWORD_TEXT_FIELD_XPATH) login_button = PageElement(xpath=LOGIN_BUTTON_XPATH) error_message = PageElement(xpath=LOGIN_ERROR_XPATH) def __init__(self, driver): BasePage.__init__(self, driver) def is_target_page(self): return self.is_element_displayed(By.XPATH, self.EMAIL_OR_USERNAME_TEXT_FIELD_XPATH) def set_username_or_email(self, username): self.email_or_username_text_field.click() self.email_or_username_text_field.send_keys(username) def set_password(self, password): self.password_text_field.click() self.password_text_field.send_keys(password) def click_login_button(self): self.login_button.click() time.sleep(2) assert self.error_message.get_attribute('text') == "Username or password incorrect"class EFAPPTests(unittest.TestCase): def setUp(self): desired_caps = &#123;&#125; desired_caps['platformName'] = 'Android' desired_caps['platformVersion'] = '5.0' desired_caps['deviceName'] = 'a92e11aa' desired_caps['app'] = r"D:/_Automation/Mobile_FrameWork/EvcMobile/apps/evc.apk" self.browser = webdriver.Remote('http://localhost:4723/wd/hub', desired_caps) def test_login_failure(self): ef_app = EFAPP(self.browser) ef_app.set_username_or_email("iTesting") ef_app.set_password(1) ef_app.click_login_button() def tearDown(self): self.browser.quit()if __name__ == "__main__": suite = unittest.TestLoader().loadTestsFromTestCase(EFAPPTests) unittest.TextTestRunner(verbosity=2).run(suite) 等等，是不是少了点什么？ 一旦你关闭了appium，所有的测试都会失败， 框架优化step 3， 监测，启动，关闭appium。在代码里添加如下：1234567891011class AppiumUtils(): def __init__(self): #start adb os.system('taskkill /F /IM adb.exe') os.system('adb devices') #launch appium os.system('taskkill /F /IM node.exe') command = ''' start /b "" "&#123;node_exe_path&#125;" "&#123;appium_js_path&#125;" --address "&#123;server_ip&#125;" --port "&#123;port&#125;" --command-timeout "&#123;command_timeout&#125;" --platform-name "&#123;platform_name&#125;" --platform-version "&#123;platform_version&#125;" --device-name "&#123;device_name&#125;" --app "&#123;app&#125;" --no-reset --log-no-color &gt; "&#123;log_path&#125;" ''' os.system("%s" % command) time.sleep(60) # wait appium start completely.这段代码目的是为了每次自动化开始时候，杀掉所有影响启动的appium服务，以确保每次appium都能正确启动，其中，大括号包起来的是你自己需要配置的各个配置项，最后一个sleep语句我简化了，其实可以动态判断appium有没有启动，这个不深入了。 改动EFAPPTests这个类，在setUp里添加如下代码：12345class EFAPPTests(unittest.TestCase): def setUp(self): AppiumUtils() 。。。 至此， 一个简单的appium测试框架就搭建成功了， 你还可以优化如下： 所有配置项单独分开放到config.py 里， 比如device信息， apk信息等。 为每一个待测的case添加一个page，page里为所有这个页面测试需要用到的元素及方法。 利用unittest这个框架，添加新的case，skip掉(@unittest.skip）不需要跑的case。 添加logging模块，记录运行信息。 添加Test Report模块，记录每次运行的结果，划分饼图，等等。 可以利用之前我讲过的ptest自动化框架组织你的用例，这样整个android自动化框架都搭建起来了。 。。。。不断优化，最终会生成最合适的移动端测试框架。]]></content>
      <categories>
        <category>mobile-test</category>
      </categories>
      <tags>
        <tag>Mobile-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageObject 模式浅谈]]></title>
    <url>%2F2017%2F05%2F18%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FPageObject%20%E6%A8%A1%E5%BC%8F%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[PageObject 模式是什么？它如何起到到减少冗余代码，提升测试效率的目的？先想象下这个例子：在自动化测试过程中，特别是基于UI的功能自动化，我们经常要进行查找元素，操作元素的操作，一般来说，代码是如下这个样子的：12 self.driver.find_element_by_xpath("//option[@value='10']")如果这个元素会被多个method用到，那么当元素变化时（例如XPATH变了）， 我们就不得不更新每个引用到这个元素的代码,非常麻烦。 有没有好的办法解决这个问题呢？ PageObject 应运而生 Page Objects Within your web app’s UI there are areas that your tests interact with. A Page Object simply models these as objects within the test code. This reduces the amount of duplicated code and means that if the UI changes, the fix need only be applied in one place. 简单来说就是： PageObject是一种程序设计模式，将面向过程转变为面向对象(页面对象)，将测试对象及单个的测试步骤封装在每个Page对象中，以page为单位进行管理。可以使代码复用，降低维护成本，提高程序可读性和编写效率。PageObject可以将页面定位和业务操作分开，分离测试对象（元素对象）和测试脚本（用例脚本），提高用例的可维护性。 记住，PageObject是一种程序设计模式，是一种思想， PageObject 的好处是： Creating reusable code that can be shared across multiple test casesReducing the amount of duplicated codeIf the user interface changes, the fix needs changes in only one place PageObject应该怎么使用呢？基于测试实践，我们一般这样应用： 把每个要测试的对象封装在一个page内， 这个page里包含这个对象可能的所有操作。 创建一个BasePage，这个BasePage包含所有待测page都能用到的公用方法，这个BasePage对应的类应该是个抽象类。 测试脚本自由引用page及page里的方法。 python里有个第三方库page-objects， 基于python实现了PageObject模式，并且封装了很多有用的方法。我们以它为例，举例如下（例子基于我的Github项目）： abstract_base_page.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546import timefrom abc import ABCMeta, abstractmethodfrom DateTime import DateTimefrom assertpy import assert_thatfrom page_objects import PageObject, PageElementfrom selenium.common.exceptions import NoSuchElementExceptionfrom selenium.webdriver import ActionChainsfrom selenium.webdriver.support.wait import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECimport settingsclass AbstractBasePage(PageObject): __metaclass__ = ABCMeta WAIT_FOR_SCROLL_TIME = 2 def __init__(self, driver): # Don't change the variable name w. it's used by PageObject self.w = driver self.driver = driver assert_that(self.has_loaded()).is_true() def has_loaded(self): try: return self.is_target_page() except NoSuchElementException: return False # This function will be implement by sub class @abstractmethod def is_target_page(self): pass def is_element_displayed_on_page(self, ele, timeout=settings.TIME_OUT): try: WebDriverWait(self.driver, timeout).until(lambda driver: ele.is_displayed()) result = True except Exception: result = False return result #...其它的公用方法..... 解释如下：1.abc 模块用来创建抽象类。2.page_objects模块用来实现pageobject模式。语法请自行google。 baidu.py123456789101112131415161718192021222324252627282930313233import timefrom page_objects import page_elementimport settingsfrom settings.test_config import DEFAULT_SLEEP_TIMEfrom page.abstract_base_page import AbstractBasePageclass BAI_DU(AbstractBasePage): SEARCH_DIALOG_ID = "kw" SEARCH_ICON_ID = "su" MEMBER_COUNT_XPATH = "//option[@value='10']" SAVE_XPATH = ".//*[@id='save']" csearch_input_dialog = page_element(id_=SEARCH_DIALOG_ID) search_icon = page_element(id_=SEARCH_ICON_ID) member_count = page_element(xpath=MEMBER_COUNT_XPATH) save_button = page_element(xpath=SAVE_XPATH) def __init__(self, browser): self.browser = browser AbstractBasePage.__init__(self, browser) def is_target_page(self): self.browser.get(settings.BAI_DU_HOME + "/") return self.is_element_displayed_on_page(self.search_icon) def search(self, search_string): self.search_input_dialog.send_keys(search_string) self.search_icon.click() time.sleep(DEFAULT_SLEEP_TIME) self.browser.close() 解释如下：1.page_objects封装了Selenium的一些方法，我们不需要通过driver.find_element_by_xpath()等来查找元素，转而用pageelement（locator）这样的方式来定位， page-objects支持的locator如下： keyword Arg Description id_ Element ID attribute css CSS Selector name Element name attribute class_name Element class name tag_name Element HTML tag name link_text Anchor Element text content partial_link_text Anchor Element partial text content xpath XPath 2.每个子类，都应该实现抽象类里的抽象方法， 在本例中是is_target_page(). test.py(测试用例)12345678910111213141516171819202122from ptest.assertion import assert_that, assert_equalsfrom ptest.decorator import TestClass, BeforeMethod, Test, AfterMethodfrom ptest.plogger import preporterfrom common.selenium_helper import SeleniumHelperfrom page.baidu import BAI_DU@TestClass(run_mode='parallel')class TestBaidu: @BeforeMethod(description="prepare test data") def before(self): preporter.info("Test is about to start") self.browser = SeleniumHelper.open_browser("chrome") @Test(tags =["regression", "smoke"]) def test_baidu_search(self): """Test search""" baidu = BAI_DU(self.browser) baidu.search("test") assert_equals(1, 1) 测试脚本，可以任何组合各个page的任意方法。 由此可以见， 使用了page_objects 后， 测试对象， 测试方法， 测试脚本全部解耦， 测试对象的任何改变，只需要更改相应的page对应的类就好了。 最后附上:Page_objects的pypi地址 Page_objects文档]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发系列--Flask+SAE新浪云部署微信公众号]]></title>
    <url>%2F2017%2F04%2F05%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--Flask%2BSAE%E6%96%B0%E6%B5%AA%E4%BA%91%E9%83%A8%E7%BD%B2%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[近期，腾讯公布了2016年业绩报告，其中显示微信活跃用户数已达5.49亿， 如果你还不明白这代表什么，来看看 国内三大电信运营商的表现： 2016年6月20日, 中国移动用户总数达8.35亿， 其中4G用户达4.09亿。2016年2月， 中国联通移动用户数2.57亿，4G用户5480.2万。2016年上半年，电信移动用户数2.07亿，其中4G用户数9010万户。 三者的4G用户相加为 5.53亿上下。 也就是说，全中国每一个用4G网络的人几乎都是微信的客户！！！ 为什么要说这个，同志们，技术人员不能只低头干活，不抬头看路啊！ 加上微信近期将会推出公众号–企业应用号。什么意思呢，就是说以后我们手机里，只需要微信一个APP就可以了， 其它所有的APP都将以web App的方式嵌入到微信中，用户像关注公众号一样的使用。那么开发者怎么办？当然是做公众号开发嵌入微信了。 细思极恐啊，同志们，微信就是未来，你不懂微信你就没有未来啊！ 好的，装逼结束，我们来看如何开发公众号： 申请服务器 搭建服务 申请公众号 开发者基本配置 提供服务如果你不知道如何在本地搭建并发布你的服务， 请参考旧文&lt;利用Apache+Flask+python部署网页应用&gt; 今天我们来尝试用比较流行的新浪云来部署我们的应用，好处是有了一个外部域名，可以直接被微信服务器访问。 1.登录新浪云，进入 我的首页 ，点击 创建新应用 ，创建一个新的应用 itesting。运行环境选择 Python2.72.编辑应用代码要想让微信和新浪云通信，以下下文件不可缺少：index.wsgi123import saefrom main import appapplication = sae.create_wsgi_app(app)新浪云上的 Python 应用的入口为index.wsgi:application，也就是index.wsgi这个文件中名为application的 callable object。在 我的应用中，该 application 为一个 wsgi callable object。 config.yaml 。在目录下创建应用配置文件 config.yaml ，内容如下： name: itesting version: 1 main.py1234567891011121314151617181920212223242526272829303132333435363738from flask import Flask, request, make_responseimport hashlibimport xml.etree.ElementTree as ETapp = Flask(__name__)app.debug = True@app.route('/welcome')def hello_world(): return "Welcome to Kevin's website!"@app.route('/', methods=['GET', 'POST'])def wechat(): if request.method == 'GET': if len(request.args) &gt; 0: temparr = [] #此处为公众号里设置的token token = settings.token signature = request.args["signature"] timestamp = request.args["timestamp"] nonce = request.args["nonce"] echostr = request.args["echostr"] temparr.append(token) temparr.append(timestamp) temparr.append(nonce) temparr.sort() newstr = "".join(temparr) sha1str = hashlib.sha1(newstr) temp = sha1str.hexdigest() if signature == temp: return make_response(echostr) else: return make_response("Access denied") else: return make_response("Wrong args received") else: return make_response("Welcome to iTesting") 这里面有微信的逻辑，开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带参数如下表所示： 参数 描述 signature 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。 timestamp 时间戳 nonce 随机数 echostr 随机字符串 开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：1）将token、timestamp、nonce三个参数进行字典序排序2）将三个参数字符串拼接成一个字符串进行sha1加密3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 3.上传到新浪云切换到项目目录，用git命令在你应用的git代码目录里，添加一个新的git远程仓库 sae。12345$ git remote add sae https://git.sinacloud.com/itesting#编辑代码并将代码部署到 `sae` 的版本1。$ git add .$ git commit -m 'Init my first app'$ git push sae master:1成功后输入 http://itesting.applinzi.com/ 测试，如果返回 “Wrong args received”， 说明配置成功。 4.进入公众号， 左侧菜单选择开发-》基本配置，配置URL为上述地址，然后其它选项填好， 保存，当显示保存成功则说明配置成功。 配置好后，所有用户发给你的消息都将通过新浪云服务器处理，你需要自己写处理的代码逻辑。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发系列--自动回复实现天气预报查询]]></title>
    <url>%2F2017%2F04%2F05%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[上次我们讲了微信公众号的部署，今天我们来实现一个小功能，自动回复天气预报的播报。 使用方法如下： 在iTesting公众号里直接回复 “城市 天气”，将会把上海最近的天气信息返回给你， 例如输入上海 天气 ， 会返回给你上海的天气情况。 通过仔细阅读微信开发文档，我们知道： 当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。 简单来说，当你输入信息要求微信服务器返回你一个信息时，是在做一个Post请求，这个post请求是text格式的，微信收到会转给你自己的服务器，你的服务器处理好后，按照微信的要求把内容返回，然后你就可以看到回复了。原理知道了，那么如何开发？步骤如下： 首先把回复的xml准备好，放在文件里，例如 txt_message.xml. 123456&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&#123;to_user&#125;]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[&#123;from_user&#125;]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;&#123;c_time&#125;&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[&#123;content_value&#125;]]&gt;&lt;/Content&gt;&lt;/xml&gt; 调用天气预报API生成天气。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: UTF-8 -*-import sysreload(sys)sys.setdefaultencoding("utf-8")import requestsimport settingsclass GetWeather(object): headers = &#123;'apikey': settings.baidu_apikey&#125; def get_city_code(self, city): url = 'http://apis.baidu.com/apistore/weatherservice/citylist?cityname=%s'%city r = requests.get(url, headers=self.headers) j = r.json()['retData'] for i in j: if i['name_cn'] == city: return i['area_id'] def get_weather(self, city): city_code = self.get_city_code(city) url = 'http://apis.baidu.com/apistore/weatherservice/recentweathers?cityname=&#123;&#125;&amp;cityid=&#123;&#125;'.format(city, city_code) r = requests.get(url, headers=self.headers) raw_data = r.json() if raw_data.has_key("retData"): if type(raw_data['retData']) == dict: j = raw_data['retData']['today'] content = "今日&#123;city&#125;的天气情况如下：\n" \ "日期：&#123;date&#125;," \ "&#123;week&#125;, " \ "当前温度：&#123;curTemp&#125;, " \ "&#123;type&#125;, &#123;fengxiang&#125;, &#123;fengli&#125;" \ "最高气温：&#123;hightemp&#125;, " \ "最低气温：&#123;lowtemp&#125;, " \ "PM值：&#123;aqi&#125;" .format(city=city, date=j['date'], week=j['week'], curTemp=j['curTemp'],type=j['type'],\ fengxiang=j['fengxiang'], fengli=j['fengli'], hightemp=j['hightemp'],\ lowtemp=j['lowtemp'], aqi=j['aqi']) return content else: return "您输入的城市有误，请重新输入." else: return "您输入的城市有误，请重新输入."if __name__ == "__main__": w = GetWeather() print w.get_weather('上海') 把上述步骤里得到的返回值，嵌入到step1的变量里，返回给微信Server。具体做法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@app.route('/', methods=['GET', 'POST'])def wechat(): if request.method == 'GET': if len(request.args) &gt; 0: temparr = [] token = settings.token signature = request.args["signature"] timestamp = request.args["timestamp"] nonce = request.args["nonce"] echostr = request.args["echostr"] temparr.append(token) temparr.append(timestamp) temparr.append(nonce) temparr.sort() newstr = "".join(temparr) sha1str = hashlib.sha1(newstr) temp = sha1str.hexdigest() if signature == temp: return make_response(echostr) else: return make_response("Access denied") else: return make_response("Wrong args received") else: raw_data = request.stream.read() xml_raw = ET.fromstring(raw_data) msg = &#123;&#125; for child in xml_raw: msg[child.tag] = child.text msgtype = msg['MsgType'] tou = msg['ToUserName'] fromu = msg['FromUserName'] time_str = str(int(time.time())) if msgtype == "event": event_msg = xml_raw.find('Event').text print event_msg if event_msg == "subscribe": sub_content = settings.welcome_message else: sub_content = "error" xml_reader = XMLHelper().read_xml("txt_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=sub_content)) elif msgtype == "image": media_id = msg['MediaId'] xml_reader = XMLHelper().read_xml("img_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id)) elif msgtype == "voice": media_id = msg['MediaId'] xml_reader = XMLHelper().read_xml("voice_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id)) elif msgtype == 'text': # co = xml_raw.find('Content').text.strip().split(' ') # if co[len(co)-1] == '天气': # weather = GetWeather() # auto_response_content = weather.get_weather(co[:-1][0]) # else: r = RobotHelper() auto_response_content = r.get_robot(xml_raw.find('Content').text) xml_reader = XMLHelper().read_xml("txt_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=auto_response_content)) elif msgtype in ["video","shortvideo"]: title = "My video" description = "Check out my video" media_id = msg['MediaId'] xml_reader = XMLHelper().read_xml("video_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id, title=title, description=description)) else: unknown_content = u"""我不知道你在干什么,无法回复你""" xml_reader = XMLHelper().read_xml("txt_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=unknown_content)) response.content_type = 'application/xml' return response 这样就实现了基于文本格式的天气预报功能，是不是没有那么难？ 其实，如果你仔细研究下微信开发文档你就发现，微信开发的本质是接口测试，不过接口测试的结果被我们的服务器拿来使用，变成了一个个功能而已。 怎么理解呢？我们开发一个个功能时，实际上就是一次次对微信接口发起请求，微信通过开放给我们一个个接口，接收按照固定格式的post数据，处理后返回结果，我们收到结果后，自己写代码处理完毕，再按照微信要求的格式传给我们的服务器，服务器接收后，展示或者返回相应结果。 到现在为止，我们基本解锁了微信开发，高大上的微信开发也不过是接口测试而已。。。 我相信通过上述解释大家肯定可以实现更多好玩的功能了， 大家可以尝试下我写的自动回复机器人功能，有问题直接留言给我， 我会答疑解惑：）]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发系列--本地调试环境搭建]]></title>
    <url>%2F2017%2F04%2F05%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[上次我们讲了如何利用Flask + 新浪云部署微信开发，在开发的过程中我们发现如下问题： 1.程序出现问题，调试比较麻烦，log保存需要自己写代码。2.每次更改都需要发布到应用服务器，一旦有问题，立刻影响公众号正常使用。3.服务器无效代码太多，这对于有代码洁癖的完全不能忍好吗！如果能本地调试就好了，我们只发布正确的版本到应用服务器，最好调试简单，方便，log即开即看，那么有没有可能呢？ 必须有，今天我们就来介绍一款内网传透神器– ngrok. ngrok 是一个反向代理，通过在公共的端点和本地运行的Web 服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析和重放.下面以我们本地的服务器为例《利用Apache+Flask+python部署网页应用》，来介绍下如何使用：1.下载：https://ngrok.com/2.安装：下载好后cmd命令进入到解压的目录，然后运行命令如下： ngrok http 8088 –authtoken “ your token,get from ngrok.com” 当你看到如下信息说明运行成功，Forwarding里的地址就是外网能访问的地址。这里需注意，你注册号后会有一个唯一的token，用作绑定地址。Tunnel Status onlineVersion 2.0/2.0Web Interface http://127.0.0.1:4040Forwarding http://92832de0.ngrok.io -&gt; localhost:80Forwarding https://92832de0.ngrok.io -&gt; localhost:80 Connnections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 3.使用上述地址访问确应用服务器保配置正确，然后去微信-》开发-》开发者工具，里申请公众平台测试帐号，然后在配置里，填写上述url 和token。保存成功后，所有的用户消息都将通过微信转往我们的外网服务器。4.以我们的应用为例, 在浏览器输入 http://localhost:4040，等我们的程序运行，无论成功与否，所有的get， post请求都可以在这个地址看到，如果有错误你可以可以直接看到具体出错信息，因为我们用的是apache，出错后也可以直接去Apache文件夹下面的log里看error，是不是超级方便？5.那么你修改好错误后，如何生效呢？重启apache server即可。然后去往测试公众号里发送请求，就可以看到最新的反馈了。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Apache+Flask+python部署网页应用]]></title>
    <url>%2F2017%2F04%2F05%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%88%A9%E7%94%A8Apache%2BFlask%2Bpython%E9%83%A8%E7%BD%B2%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[当你开发好一个网页程序后，除了本地浏览，你当然期望把它发布出去供大家欣赏。我们今天就来讲下如何用Apache 部署你的应用程序（注：发布后只能通过ip访问，你需注册域名才能通过域名访问）。 重要的事情说三遍：for i in range（3）:“以下所有的安装要么全部安装32bit，要么全部安装64bit，否则运行不起来。” 1.安装 Python唯一注意的是安装选项需选择应用于所有用户。 2.安装Apache:地址：https://httpd.apache.org/download.cgi 以window为例，我们选择Files for Microsoft Windows， 然后安装Apache Haus下所有的相应版本，例如：注意看, 竖排的软件为兼容的组合，如果你安装vc11，那么vc11这一列的都要安装，安装好后根据文件里的 readme进行配置，其中要注意的是主要是mod_wsgi 的安装，这个是用来和python通信的。 注意：× 根据需要配置你的SRVROOT文件路径（apache安装文件conf下的httpd.conf），这里为”C:\Apache24”.× 根据需要更改你的端口号。（可以在command line下用netstat -ao的方式看端口号有没有被占用。）× 注意需成功配置mod_wsgi, 提示：在apache安装目录下 启用 LoadModule wsgi_module modules/mod_wsgi.so 并将mod_wsgi 文件copy到modules目录。 全部安装好后，command line进入apache的bin目录，输入httpd来看安装是否正确，然后输入httpd -k install 来安装windows service，然后启动。 3.安装flask1pip install Flask 4.开发你的app 我们写一个welcome页面，需要2个文件： main.py 1234567from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return "Welcome to Kevin's website!"if __name__ == '__main__': app.run() main.wsgi （这个文件用做网关跟apache通信，记住文件名称，apache配置要用）To run your application you need a yourapplication.wsgi file. This file contains the codemod_wsgi is executing on startup to get the application object. The object calledapplication in that file is then used as application. 123import sys, ossys.path.insert(0, os.path.dirname(__file__))from main import app as application 5.配置 Apache。 在httpd.conf里，配置如下： 去掉前面的#号。Include conf/extra/httpd-vhosts.conf 在conf的extra下，配置httpd-vhosts.conf 如下： DocumentRoot D:\wechat_test\wechat ServerName localhost WSGIScriptAlias / D:\wechat_test\wechat\main.wsgi Require all granted 注意： 端口号跟httpd.conf的Listen端口一致。 wsgi目录， Directory跟你app里定义的一致。 把文件里原有的不需要的配置command out掉。 6.重启下Apache services，然后浏览器里输入http://localhost:8088看你开发的app首页有没有正确load：成功，下面你可以继续完善你的app了 ：）]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口测试自动化框架实践]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[接口测试自动化框架实践之前介绍过一个接口测试的框架 Jmeter + Ant + Jenkins，分为了2期介绍。现在把它们总结在一篇文章中，方便大家学习。 对接口测试概念还不甚理解的同学，请移步iTesting的历史文章《接口（API）测试》。简要来说，这个框架有两部分组成，可以直接点击链接进入：1.Jmeter的脚本生成及参数化如果上述链接失效：请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。2.Ant + Jenkins集成如果上述链接失效：请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。]]></content>
      <categories>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>API-Test</tag>
        <tag>自动化测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web自动化框架实践指南]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2FWeb%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[我们今天来看看一个成熟的Web自动化框架是什么样子的，如果你还对测试框架的概念有所疑惑，请移步iTesting公众号的历史文章测试框架之我见。以下是Web自动化框架实践正文：贴一个图，是iTesting现在所在项目用的框架，我们来一步步分析说明： 注意观察图中每一个小方格右上方的数字，从1 到7，代表了测试框架的不同部分，我们来逐一介绍： 0： Core Framework。这个是测试框架的灵魂，我们可以看出它又分为几个部分，最底层就是Selenium， Webdriver，包括它们支持的原生库。倒数第二层是支持最底层的第3方库，二次开发生成的自定义库，API还有自己定义的Keywords。再上一层是一些公共的方法，这些方法普遍应用倒数第2层的API或者Mehod，这一层的方法实现了具体的功能，微信搜索iTesting，关注本公众号，比如说连接数据库，并进行增删改查的功能；连接Web Service并调用相应接口的功能；自动生成要运行的所有测试用例的功能；自动注释掉一些测试用例的功能。最上一层是解耦的测试脚本，每一个测试脚本完成一项特定的功能，比如，登录，定课，注销等。 1： Config FileConfig file用来提供测试运行时的各种参数，配置。这个文件或者文件夹存放了测试需要的precondition，settings，运行环境参数，还有运行每一个具体case时候需要的测试数据。测试所需的共同的配置可以放到一个文件里（例如Timeout，多线程支持标志位），环境运行参数可以放到另外一个文件里（例如UAT， LIVE），测试数据可以保存在Excel， XML，或者直接写在文件里，以环境运行参数为分隔符（例如UAT和Live下都有同一个变量名username）。 2： AUT application under test这个模块就是我们要测试的application。它分为2个部分：一个部分是Pages（2-2）， 即各个待测试页面。Pages里包含了页面上所有的待测元素，以及这个页面上的所有用户能做的操作，我们通常把这些操作封装成一个个的函数，以使它们来实现特定的功能，例如book_pl_class(class_info)函数，这个函数接受一个入参，入参是一个Entity 类，包括了一节课所有必要信息，函数本身实现了pl class的预订（通过接收参数，点击相应元素等操作）。函数返回值是一节课的所有信息。应注意的是Pages里不应该包含测试用例逻辑，所有的特定测试逻辑应该与页面具体操作解耦。 Pages我们引用了Page Object模式（将测试对象及单个的测试步骤封装在每个Page对象中，以page为单位进行管理），这个模式的好处是将测试方法和测试对象完全解耦，我们举个例子， 在使用page object模式之前我们的代码可能是这样：12345def login(self, user_name, password): user_element = self.browser.find_element_by_id("username") user_element.send_keys(user_name) password_element = elf.browser.find_element_by_id("password") password_element.send_keys(password +Keys.RETURN)login方法和各个element对象（这里只有username 和password这两个element）耦合在一起，当UI改变导致element的定位方式改变后，我们不得不去方法内部更改元素定位的方法，另外当某个元素在不同方法重复使用时，还需要反复查找。这样引发的问题是，当一个方法需要很多页面元素操作才完成时， 定位元素的大量代码和方法实现的功能代码耦合在一起，不仅更改起来困难，而且方法不直观，不便于用户理解。 我们来看引入了page obejct后代码变成了什么：1234567891011USER_NAME_XPATH = "//input[@id='UserName']"PASSWORD_XPATH = "//input[@id='Password']"LOGIN_XPATH = "//a[@class='et-btn-submit']")user_name_textbox = PageElement(xpath=USER_NAME_XPATH)password_textbox = PageElement(xpath=PASSWORD_XPATH)login_button = PageElement(xpath=LOGIN_XPATH）def login(self, user_name, password): self.user_name_textbox.send_keys(user_name) self.password_testbox.send_keys(password) self.login_button.click()你看，只要login的功能逻辑不变，就无需更改login方法，任凭UI如果改变，我们只需要在方法外更改element的locator，无论username这个元素需要多少函数中引用，我们只需定义一次就好了，是不是很方便维护又一目了然啊。 还有，测试过程中经常发现这样的问题，页面一开始就redirect到了非目标页面，因为我们没有针对目标页面本身做断言，导致代码继续执行，这样浪费了大量时间。我们可以通过验证目标页面正确与否的方法来避免这个问题。代码如下：12345678class LoginPage(AbstractBasePage): Target_XPATH = "//a[@class='et-btn-submit']" def __init__(self, driver): AbstractBasePage.__init__(self, driver) def is_target_page(self): return self.is_element_displayed(By.XPATH, self.Target_XPATH)这里我们利用了一个BasePage的类，里面定义了 is_target_page的抽象方法，然后子类继承过来实现。关于Pages还要很多好的优化方法，可以使我们的代码看起来简单可重用，这里不详细介绍细节了。 另一部分就是Test scenarios（2-1），即具体的测试suite和测试用例，Test scenarios由一个个test case组成，每一个test case 通过引用相应的Pages类/函数，和Core framework 里面的test scripts，来实现具体的功能， 而Test scenarios通过组合不同的test cases来覆盖不同的业务需求.其中， Test Scenarios/Test case 里均会用到 config file的各种参数配置。所有的Test Scenarios创建好后（我们把每个test scenario封装成一个测试类）， 就要决定如何执行这些测试类了。那么，这些测试类每次运行都需要全部执行吗？如果不需要，哪些是需要执行的，哪些是要ignore的呢？这个时候Core framework里的common method的具体Method派上了用场，common里实现了generate_test_scenarios的方法和ignore_test_scenarios方法，利用ignore_test_scenarios方法，我们会在tests文件夹下面的ignore_testcase_lists文件里列出所有要ignore的test scenarios，然后利用generate_test_scenarios方法我们最终把所有要执行的scenarios都放到init 里。 3： Main file。 测试主函数。测试主函数用来执行生成的各种Test Suites， 包括实现多线程支持和错误处理机制。它也是测试的入口函数。需要注意的是， Main 函数会装载 Test下面的init文件，所有在init文件里的用例都会被执行（是顺序还是同时要看函数中对多线程的支持及实现）。 4： Test Report模块。Main 函数同时也会包含生成test report的方式，测试完成后，会根据需要生成txt格式，html格式test report并保持到系统本地。 5： Error Handling模块。测试运行中，如果发现错误，会根据Error handling规则触发相应的错误处理机制，同时会触发screen shots函数和log函数，把所有错误截图和log信息保存在系统本地。 6：Email Reports。测试报告Email发送模块，这个模块可以在第7步里开发配置，也可以直接把代码写在Main 函数里，运行完随机发送测试报告。 7：Jenkins持续集成。利用Jenkins，驱动Main 函数，实现每日构建，代码改动构建。并集成Test report模块，Email Report模块，实现测试框架的闭环。 我们再来看一下这个框架的文件结构：其中，a20, common, _common对应 0：core framework，pages，entity , tests对应2：AUT，setings，对应 1：config file。Main函数及report，screenshots等位于 **_common下。 以上就是iTesting项目组测试框架的使用情况，由于种种原因，恕不能放出源代码，请见谅。 为了更好的理解测试框架，iTesting利用Python里的unittest和前文中测试框架设计思想，重新设计了一个简化版的测试框架，可以帮助你快速上手测试框架，请关注github。地址：Github地址]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>自动化测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试框架之我见]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%2F%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%88%91%E8%A7%81%2F</url>
    <content type="text"><![CDATA[什么是框架？框架可以是被重用的基础平台；框架也可以是组织架构类的东西。我认为，框架就是一系列基础设施，这些设施起到一个基础工具的作用，是一个创建别的工具的工具。 其次，什么是自动化测试呢？自动化测试是用软件（通常指有一系列测试配置前提下）去执行测试并且判断实际结果和期望结果是否一致的一种测试方法。 那么，什么是自动化测试框架呢？自动化测试框架由一个或多个自动化测试基础模块、自动化测试管理模块、自动化测试统计模块等组成的工具集合。这些模块集合组合到一块，应具备以下特质：· 测试框架与被测应用程序独立。即一套框架可以服务多种程序的自动化。· 测试框架应被高度模块化，易于扩展、维护。各个模块之间应解耦，独立。· 测试脚本所使用的测试语言应该是与框架独立的。不同的测试框架可能在不同的应用领域有不同的表现，有些适用于Java应用程序的测试， 有些可能适用于Web应用程序的测试，那么当需要从一个测试框架迁移到另外一个测试框架时，所有的测试脚本应该不需要重写。· 测试框架应该简单易用。 最后，如何创建一个自动化测试框架呢？首先，你要有“自动化测试框架思想”，什么是“自动化测试框架思想”？·模块化思想·库思想·数据驱动思想·关键字驱动思想 我们举例说明：譬如一个英文学习网站，有登录，学习页面（由PL, GL, 自我学习页面等组成），还有退出页面。假设我要分别自动化测试测试PL， GL页面，那么我们应该怎么做呢？手工测试步骤是先登录，然后跳转到我要测试的页面，测试，然后退出。那么自动化测试就是分别写登录，跳转页面，测试，退出页面的代码，然后把它们按顺序组合到一起。我的代码看起来可能是这个样子的（）： 1234567891011121314151617181920…代码块1……打开登录页面……输入用户名……输入密码……点击登录按钮……跳转后检查是否进入到首页……代码块2……找到Menu……找到PL/GL页面的链接……点击连接进入……判断是否进入目标页面……是，进行目标界面的测试，不是，报错退出……代码块3……具体的测试代码，断言等……代码块4……找到退出按钮……点击退出… 模块化思想就是将一个测试用例中的几个不同的测试点拆分并且将其单个点的测试步骤进行了封装，形成了一个模块。举例来说：对于PL 和GL， 我的代码块及代码顺序都是1，2，3，4. 唯一不同的是3里的具体实现，如下所示：12PL: 1, 2, 3(for PL), 4GL: 1, 2, 3(for GL), 4如果代码块1有改动，我需要把 PL 和GL测试代码里对应的模块也更改一遍，如果我有100个case，那么就要改100遍，太不make sense了。 模块化就是把1， 2， 4， 这些共用的操作分别封装，可以形成登录模块（login（）），跳转模块（redirect（）），退出模块（logout（））.封装后我的代码看起来是这样的：12PL: login（）, redirect（）, 3(for GL), logout（）GL: login（）, redirect（）, 3(for GL), logout（）这样的话，当一个模块有变化，你只需单独维护那个模块即可，不再需要更改PL， GL的测试代码了， 是不是效率瞬间提升啊？ 你肯定看出来了，模块化之后，redirect（）函数没有提供入参，这样我分别测试PL和GL的时候，需要更改redirect（）这个模块里的跳转url目标地址。还有如果我想针对特定账户测试PL， GL该怎么做呢？每次测试前再去修改模块化函数login（）的账户信息吗？如果我需要针对不同账户同时测试PL， GL该怎么办？ 测试库思想，就是模块化思想的升华，其为应用程序的测试创造了库文件（可以是APIs、DLLs等），这些库文件为一系列函数的集合。其与模块化思想不同的是，其拓展了接口思想，即可以通过接口去传递参数，而不是一个封死的模块，可以说是一个多了一个“门”的交互型模块。我们根据测试库思想来设计一个api，把login（）， redirect（）更改成 login（username, password）, redirect(url),是不是就解决了啊！我们的代码变成了 ：12PL: login（username, password）, redirect(url), 3(for GL), logout（）GL: login（username, password）, redirect(url), 3(for GL), logout（）另外，针对login 和redirect模块里的跳转检查和目标页面确认检查，我们也可以封装成一个函数 target_check（target）， 这样我们的代码是不是又少了很多，且方便维护扩展了呢 ：） 这样，我们的测试脚本开发人员，只需要focus在具体的测试页面上（例如PL或者GL页面）就可以了，不需要关心通用模块的开发维护了，这样是不是有了测试框架的雏形了？：） 我们满足的把这个框架运行了一段时间，忽然有一天，老板说，我们新开发了100个市场，我们需要这100个市场的用户从登录界面登录后，根据用户country把用户redirect到不同的domain上去，这个需求很紧急，你多久能搞定？创建100个test case，更改这100个case里login模块的username， password? 你傻不傻？ 我们弄一个Excel，封装一个读写Excel的api，然后只写一个测试用例，循环100次，每次读取不同的username和password，我们的代码变成了：12For i in range(0,100):login（username[i], password[i]）, redirect(url), 3(for GL), logout（）老板开心死了，再来100个市场，你也分秒搞定！这个时候你让他加工资，你说他‘滋瓷’不‘滋瓷’? 这就是所谓数据驱动思想。利用数据驱动结果，不同的数据导致了不同的结果的产生。而对于数据的导入，可以通过很多方式，例如：EXCLE表、XML（用在WEB中）、数据库（DB）、CSV文件、TXT等都可以。 时光如梭，你带了个新人妹子，你来手把手教她如何新写自动化代码如何维护自动化框架，她很笨，代码写的慢，而且调用的api一多她就头晕，经常拖着你加班，一加就到晚上十点多，你还得送她回家，每次送到家她还请你上去坐坐，坐个头啊，已经十点多了，回到家就要12点了, 回去不要打游戏了？回去不要看球赛了？回去不要老婆孩子热炕头了？第二天上不上班了？叔可忍婶不可忍，你鼓捣出这个来：你告诉妹子，她只要在Excel里按格式更新就可以了，不需要再去调用API了，妹子讪讪的去了，世界清静多了，一切都很美好，并没有哪里不对～ 这就是关键字思想。就是不仅把测试数据放到文件里，还把关键指令（用来决定做什么操作，做这个操作要执行哪个测试脚本）也放到外部文件里， 这就叫关键字驱动。上面的例子中， MethodName 这一列是关键字，代码会根据这一列里的方法名调用相应的代码。我们给出一个关键字的实现例子：1234567891011121314151617181920212223def open_browser(browser_name): browser_name = browser_name.lower() if not browser_name in &#123;'chrome', 'firefox', 'ff', 'ie'&#125;: browser_name = 'chrome' if browser_name == 'ie': browser = webdriver.Ie() elif browser_name in ('firefox', 'ff'): binary = None profile = None if settings.FIREFOX_BINARY: binary = FirefoxBinary(settings.FIREFOX_BINARY) if settings.FIREFOX_PROFILE: profile = webdriver.FirefoxProfile(settings.FIREFOX_PROFILE) browser = webdriver.Firefox(firefox_profile=profile, firefox_binary=binary) else： options = webdriver.ChromeOptions() options.add_argument("--use-fake-device-for-media-stream") options.add_argument("--use-fake-ui-for-media-stream") browser = webdriver.Chrome(chrome_options=options) browser.maximize_window() return browser这个例子实现好后，你在代码里写open_browser(‘chrome’)这个关键字, 系统就会自动知道如何执行，执行什么， 以什么配置。以上你都明白了吗？自动化测试框架，不过是一系列文件，代码，组件的集合，这些集合放到一起，方便了我们自动化测试代码的编写，大大的提升了工作效率。后面我们来看看如何根据以上思想实现Web自动化测试框架和Mobile自动化测试框架。]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>basic-knowledge</tag>
        <tag>自动化测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter 运用JDBC连接数据库]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2FJmeter%20%E8%BF%90%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[上次我们讲了如何利用User Parameters来使用外部Json文件，今天我们讲下一个知识点：如何使用Jmeter连接数据库并且验证数据？ 仍以我们之前的例子来说，最后教师给学生打分完毕后，会有一条数据存在数据库中，那么我们就需要去验证这个数据。 下载最新的JDBC Driver: 下载最新的JDBC Driver（我们以SQL SERVER为例）https://msdn.microsoft.com/en-us/library/mt683464.aspx解压并copy你需要的jar 文件到 jmeter/lib 目录 (重启后生效) 选中你需的Test plan， 把jar文件引入： 右键Thread Group-&gt;Add-&gt;Config Element-&gt;JDBC Connection Configuration 配置如下：Variable Name: 写个名字，这个名字后面JDBC Request要用。Database URL: jdbc:sqlserver://localhost:port;DatabaseName=mydb; (localhost，port，mydb自行替换)JDBC Driver Class: com.microsoft.sqlserver.jdbc.SQLServerDriverUsername：数据库连接用户名Password: 数据库连接密码 在ThreadGroup上右键，Add-&gt;Sampler-&gt;JDBC Request: 配置如下： Variable Name Bound to Pool：配置成与JDBC Connection Configuration里一样的值。SQL Query： QueryType：看自己需求选择（本例用Prepared Select Statement）。 下面input text就填写自己需要的SQl语句。其中“？”代表变量，它的值定义在Parameter values里， 如果有多个，用逗号隔开。 Parameter values：SQL 语句里？对应的变量，如果有多个，名称以逗号隔开。 Parameter types：INTEGER, DATE, VARCHAR, DOUBLE Variable names: 这个参数用来保存Select 语句返回的值。引用方法参考下扩展阅读。** Result variable name：创建一个对象变量，保存所有返回的结果 配置好后，run一下看结果：All passed. 扩展知识： Variable names: 如果给这个参数设置了值，它会保存sql语句返回的数据和返回数据的总行数。假如，sql语句返回2行，3列，且variables names设置为A,,C，那么如下变量会被设置为： A_#=2 (总行数) A_1=第1列, 第1行 A_2=第1列, 第2行 C_#=2 (总行数) C_1=第3列, 第1行 C_2=第3列, 第2行 如果返回结果为0，那么A_#和C_#会被设置为0，其它变量不会设置值。 如果第一次返回6行数据，第二次只返回3行数据，那么第一次那多的3行数据变量会被清除。 可以使用${A_#}、${A_1}...来获取相应的值]]></content>
      <categories>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>API-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter利用User Parameters读取外部文件]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2FJmeter%E5%88%A9%E7%94%A8User%20Parameters%E8%AF%BB%E5%8F%96%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[上次我们讲了如何最优化的重用变量，我们使用了User Defined Variables，这些变量一般都是全局的，或者是常量， 假设我们用到的变量来自上一个请求，那么我们如何使用呢？（还记得前面的分享&lt; Jmeter 正则表达式提取器传参&gt;吗？）另外，我们发送的HTTP Request bodydata里，经常需要发送一大串的Json数据,我们之前是写到每一个请求的body里，那么有没有办法写到外部文件里以重用呢？今天我们来讲如何使用User Parameters读取外部文件。仍以我们之前的例子来说： 假设我们的整个测试共有3个HTTP请求，第一步是用户登录，第二步是发送一个query string请求，获取服务器返回的memberid，token，tokentime， 第三步步就是把第二步返回的请求填入上述request body，然后发送请求，最终完成打分。 第二步和第三步之间的参数传递我们已经在文章&lt; Jmeter 正则表达式提取器传参&gt;里实现了，第三部分的request body Data我们之前是放到一个个具体的HTTPRequest Sampler里的，这种方法的一个常见问题是，如果 JSON 结构（或数据）发现变化（也许是因为 API 参数的更改），那么您必须进入 JMeter 测试，找到 HTTP 请求的主体，并修改 JSON 结构（和数据），以满足新的要求。 那么如何解决这个问题呢？ 我们以前的body data如下：1234567891011&#123; &quot;SurveyResult&quot; : &#123; &quot;SurveyTitle&quot; : &quot;ClassTechnicalSurvey&quot;, &quot;SurveyId&quot; : 104, &quot;MemberId&quot; : &quot;$&#123;m_id_g1&#125;&quot;, &quot;ClassId&quot; : &quot;1422994&quot;, &quot;Token&quot; : $&#123;m_id_g2&#125;, &quot;TokenTime&quot; : $&#123;m_id_g3&#125; &#125;,&quot;Detail&quot; : [&#123;…&#125;]&#125; 我们新建立一个json文件，名称customizejson.json，保存在目录..\ _testcase\jsontemplates下，内容如下： 1234567891011&#123; &quot;SurveyResult&quot; : &#123; &quot;SurveyTitle&quot; : &quot;ClassTechnicalSurvey&quot;, &quot;SurveyId&quot; : 104, &quot;MemberId&quot; : &quot;$&#123;__eval($&#123;m_id_g1&#125;)&#125;&quot;, &quot;ClassId&quot; : &quot;1422994&quot;, &quot;Token&quot; : $&#123;__eval($&#123;m_id_g2&#125;)&#125;, &quot;TokenTime&quot; : $&#123;__eval($&#123;m_id_g3&#125;)&#125; &#125;,&quot;Detail&quot; : [&#123;…&#125;]&#125; 上述文件中的 JSON 为每个已定义的替代变量调用了 JMeter __eval() 函数。增加的这一步骤使得在运行时执行 JMeter 脚本的时候可以对变量进行计算。 在HTTP Request Smapler里，设置如下：可以看到以前我们写在BodyData里的JSON数据被 ${__eval(${CUSTOMIZE_JSON})代替。 在这个Sampler上，右键点击Add-&gt;Pre processors-&gt;User Parameters 配置User Parameters 如下：以上定义的CUSTOMIZE_JSON 变量就是前面步骤里在BodyData里填写的变量，它被设置为 FileToString()，并使用指向 JSON 模板文件的路径作为参数。JSON 实体模板文件的所有内容都被读入 CUSTOMIZE_JSON变量。因此，JSON 实体模板文件的内容是在运行时计算的，所定义的所有替代字符串都被翻译成为它们定义的数据。 另外两个变量定义在myuser.properties文件里： #–Json template（路径不需要用引号括起来）JSONTEMPLATE_ROOT=C:\apache-jmeter-2.13\_testcase\jsontemplatesCSVDATA_ROOT=C:\apache-jmeter-2.13\_testcase\jmeter_config.txt 按上述步骤设置好，run一下，我们看看结果：全部pass，并且相应的动态变量也被正确获取替换，成功！ 扩展知识： __FileToString¶The FileToString function can be used to read an entire file. Each time it is called it reads the entire file.If an error occurs opening or reading the file, then the function returns the string “ERR“ evalThe eval function returns the result of evaluating a string expression.This allows one to interpolate variable and function references in a string which is stored in a variable. For example, given the following variables:name=Smithcolumn=agetable=birthdaysSQL=select ${column} from ${table} where name=’${name}’then ${eval(${SQL})} will evaluate as “select age from birthdays where name=’Smith’”.This can be used in conjunction with CSV Dataset, for example where the both SQL statements and the values are defined in the data file.]]></content>
      <categories>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>API-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter 利用User Defined Variables实现变量重用]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2FJmeter%20%E5%88%A9%E7%94%A8User%20Defined%20Variables%E5%AE%9E%E7%8E%B0%E5%8F%98%E9%87%8F%E9%87%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[我们上次讲了如何在不同的HTTP Request之间传递参数，今天来看下，如何优化 HTTP Request本身及如何高效使用变量我们仍然以下述为例： 假设我们的整个测试共有3个HTTP请求，第一步是用户登录，第二步是发送一个query string请求，获取服务器返回的memberid，token，tokentime， 第三步步就是把第二步返回的请求填入上述request body，然后发送请求，最终完成打分。 对于我们的每一个HTTP请求，都需要用到Web Server。我们以前是把它们写在不同的请求中间，如果有变化我们需要一个个修改。其实我们可以把它们定义在一个自定义properties文件里读取，方法如下： 在 jmeter.properties 文件中，取消对 user.properties 设置的注释，并 user.properties的值设置为所创建的文件的名称在 jmeter.properties 文件中指定一个用户属性文件123# Should JMeter automatically load additional JMeter properties?# File name to look for (comment to disable)user.properties=myuser.properties 更改myuser.properties文件1234567891011#----------------------------------------------------------------# FVT API Test Environment parameters#----------------------------------------------------------------## --- Login CredentialsUSER =testPASSWORD=test## --- Application ServerAPP_SERVER=*.englishtown.comAPP_PORT=80 右键ThreadGroup-&gt;Add-&gt; Config Element-&gt;User Defined Variables 配置Name 和Value如下：控制面板的 Value 列中的每个项目的格式为： ${property(VARIABLE_NAME,VARIABLE_NAME)}例如，来自用户属性文件myuser.properties的 APP_SERVER变量被读取为脚本中的 ${property(APP_SERVER, APP_SERVER)} 函数。 引用时，在每一个HTTP Request的Server or IP里，填写 ${APP_SERVER}就可以了。user_defined_variable3.png扩展知识： 在 JMETER_HOME/bin 目录下的三个文件中定义 JMeter 的属性和变量。在启动 JMeter 时，它会按以下顺序加载这些文件：jmeter.properties一个可选的用户定义的属性文件system.properties当 JMeter 正在运行的时候，如果要添加任何新属性或改变现有的属性，则必须先关闭 JMeter，然后重新启动它，使更改生效。jmeter.properties 文件存储与 JMeter 应用程序本身有关的属性。这个文件中仅 保留了特定于 JMeter 程序的属性或特定于框架的属性。创建一个单独的文件（文件名由您选择），用该文件来存储测试环境特定的属性和变量，它们对于和接受测试的应用程序有关联的所有脚本来说是全局的属性和变量 — 例如，管理员的用户名/密码。]]></content>
      <categories>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>API-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter 正则表达式提取器传参]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2FJmeter%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E5%99%A8%E4%BC%A0%E5%8F%82%2F</url>
    <content type="text"><![CDATA[上次我们讲了如何利用Jmeter做接口测试，讲的比较浅，今天来补充一点细节，如何在不同的HTTP Request间传递参数，即前一个请求的输出部分是后一个请求的输入时，应该怎么办 拿上次的教师打分API为例：123456789101112131415161718192021222324252627POST: /survey/evc/EVCSurvey/SaveUAT URL: http://**.englishtown.com/***/Survey/SaveSave Survey Result Request &#123; "SurveyResult" : &#123; "SurveyTitle" : "ClassTechnicalSurvey", "SurveyId" : 1000000, "MemberId" : 12345678, "ClassId" : "987654321", "Token" : "dd556a9d36c1984bbab94f37483f484f", "TokenTime" : "2016-07-26T08:56:32.8807460Z" &#125;, "Detail" : [&#123; "Key" : 764, "Value" : 1, "Type" : 3, "Order" : 1 &#125;,&#123;...&#125; ]&#125;Save Survey Result Response &#123; "IsSuccess" : true, "Description" : "", "StatusCode" : 200 //200-&gt;Success, 0-&gt;None, -300-&gt;Invalid Parameter, -400-&gt;Invalid Token, -500-&gt;Unhandled Exception&#125; 要使用这个API，我们发送的HTTP Request Body需要一些特定的信息，例如memberid， token， tokenTime等，上次的例子里我们把它们当作一个个变量保存在外部文件里，但显然不太合适，因为不同用户登录后用到的值都不相同，我们最后动态的获取他们。下面来看看怎么做：假设我们的整个测试共有3个HTTP请求，第一步是用户登录，第二步是发送一个query string请求，获取服务器返回的memberid，token，tokentime， 第三步就是把第二步返回的请求填入上述request body，然后发送请求，最终完成打分。显然我们的传参行为发生在第二步和第三部， 我们先看参数获取，在第二步的HTTP Request请求下，右键点击Add-&gt;Post Processors-&gt;Regular Expression Extractor添加后可以看到正则表达式抽取器，我们看如何配置：位置1：名称及注释位置2：正则表达式提取内容的范围。（关于各字段的详细说明请查阅协议的相关说明）位置3：正则表达式提取的相关设置3.1引用名称：其他地方引用提取值的变量名称，如填写的是：m_id，具体的引用方式是${m_id}3.2正则表达式：提取内容的正则表达式, 此例中我们需要提取3个参数【稍注意一下： () 表示提取，对于你要提前的内容需要用小括号括起来】。需要注意的是，这3个参数的正则表达式需要是一个，不能分割（就是一个正则匹配所有变量，我本来以为会有分隔符来分割）。3.3模板：用$$引用起来，如果在正则表达式中有多个提取表达式（多个括号括起来的东东），则可以是$1$，$2$等等，表示解析到的第几个值给m_id，正则表达式的提取模式，值从1开始，值0对应的是整个匹配的表达式3.4缺省值：正则匹配失败时取缺省值 下面我们给出第二步server的返回值的部分关键内容，结合上图3.2正则表达式的说明，来看下如何填写这个正则表达式：12345[&#123;&quot;member_id&quot;:23803871, ...&quot;token&quot;:&quot;9c0ed9431545dfc3dbaf1e5c7c0ae9ee&quot;,&quot;tokenTime&quot;:&quot;2016-07-25T14:41:17.2994676Z&quot;,.....&#125;]由上可以看出，3.2正则表达式我们书写的”memberid”:([0-9]).“token”:(“[A-Za-z0-9]“).“tokenTime”:(“[0-9A-Za-z-:.]*”) 可以全部匹配merberid，token， tokenTime的内容。小技巧：可以google在线正则先去确保正则表达式书写正确，然后再按Jmeter语法写入。 拿到参数值后，如何传入下一个HTTP Request呢，非常简单，直接用第二步正则表达式里我们定义的引用名称（Reference Name）就可以了。本例用${m_id_g1}, ${m_id_g2}, ${m_id_g3} 来分别表示不同的参数。如图所示。我们只定义了m_id一个引用变量，那么m_id_g1, m_id_g2是什么鬼？看下Jmeter语法： Suppose you want to match the following portion of a web-page:name=”file.name” value=”readme.txt” and you want to extract both file.nameand readme.txt.A suitable regular expression would be:name=”([^”]+)” value=”([^”]+)”This would create 2 groups, which could be used in the JMeter Regular Expression Extractor template as $1$ and $2$.The JMeter Regex Extractor saves the values of the groups in additional variables.For example, assume:Reference Name: MYREFRegex: name=”(.+?)” value=”(.+?)”Template: $1$$2$Do not enclose the regular expression in / /The following variables would be set:MYREFfile.namereadme.txtMYREF_g0name=”file.name” value=”readme.txt”MYREF_g1file.nameMYREF_g2readme.txtThese variables can be referred to later on in the JMeter test plan, as ${MYREF},${MYREF_g1} etc. 明白了吧，对于本例，tempalte用了$0$, 即取所有匹配的表达式，m_id_g1,则表示匹配的表达式里第一个匹配上的内容，m_id_g2就表示第2个，因为我们有正则匹配上3个符合的内容，g1,g2,g3分别表示这3个。以上就是如何应用jmeter传参，更多内容敬请关注iTesting。]]></content>
      <categories>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>API-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口测试自动化框架实践指南（二）]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接口测试自动化框架实践指南（二） 上次我们分享了接口自动化框架的第一部分Jmeter的脚本生成及参数化，今天我们来看第二部分：Ant + Jenkins集成： 通过ant一键执行一个或多个jmeter脚本，并批量生成html格式的报告。 通过Jenkins自动化构建，完成测试框架搭建并生成测试报告。在此之前我们需正确安装并配置如下软件： 验证java C:>Java -versionjava version “1.8.0_06” 验证ant C:>ant -versionApache Ant(TM) version 1.9.6 compiled on June 29 2015 使用Ant运行jmeter脚本。：1、首先我们默认Jmeter脚本已经录制好了，并测试通过，存在（查询模块.jmx）脚本2、为了能够在ant中使用jmeter task，必须将“ant-jmeter-1.1.1.jar”这个jar包放到ant的classpath中去。这个jar包位置 jmeter的安装目录下的 extras 目录中。也可直接将这个jar拷贝至ant安装目录下的lib目录中。这样Ant运行时才能找到”org.programmerplanet.ant.taskdefs.jmeter.JMeterTask”这个类，从而成功触发JMeter脚本 。3、jmeter默认保存的是.csv格式的文件，所以我们先要设置一下bin/jmeter.properties文件内容，保存 jmeter.save.saveservice.output_format=xml4、使用Ant运行所有的*.jmx脚本，生成.jtl文件放入 ..\resultLog\jtl文件中，ant再将相应的文件转换为对应的html文件放入..\resultLog\html中. build.xml文件中的内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project name="ant-jmeter-test" default="run" basedir="."&gt; &lt;tstamp&gt; &lt;format property="time" pattern="yyyyMMddhhmm" /&gt; &lt;/tstamp&gt; &lt;!-- 需要改成自己本地的 Jmeter 目录--&gt; &lt;property name="jmeter.home" value=".." /&gt; &lt;!-- jmeter生成jtl格式的结果报告的路径--&gt; &lt;property name="jmeter.result.jtl.dir" value="..\resultLog\jtl" /&gt; &lt;!-- jmeter生成html格式的结果报告的路径--&gt; &lt;property name="jmeter.result.html.dir" value="..\resultLog\html" /&gt; &lt;!-- 生成的报告的前缀--&gt; &lt;property name="ReportName" value="TestReport" /&gt; &lt;property name="jmeter.result.jtlName" value="$&#123;jmeter.result.jtl.dir&#125;/$&#123;ReportName&#125;$&#123;time&#125;.jtl" /&gt; &lt;property name="jmeter.result.htmlName" value="$&#123;jmeter.result.html.dir&#125;/$&#123;ReportName&#125;$&#123;time&#125;.html" /&gt; &lt;target name="run"&gt; &lt;antcall target="test" /&gt; &lt;antcall target="report" /&gt; &lt;/target&gt; &lt;target name="test"&gt; &lt;taskdef name="jmeter" classname="org.programmerplanet.ant.taskdefs.jmeter.JMeterTask" /&gt; &lt;jmeter jmeterhome="$&#123;jmeter.home&#125;" resultlog="$&#123;jmeter.result.jtlName&#125;"&gt; &lt;!-- 声明要运行的脚本"*.jmx"指包含此目录下的所有jmeter脚本--&gt; &lt;testplans dir="." includes="*.jmx" /&gt; &lt;property name="jmeter.save.saveservice.output_format" value="xml"/&gt; &lt;/jmeter&gt; &lt;/target&gt; &lt;path id="xslt.classpath"&gt; &lt;fileset dir="$&#123;jmeter.home&#125;/lib" includes="xalan*.jar"/&gt; &lt;fileset dir="$&#123;jmeter.home&#125;/lib" includes="serializer*.jar"/&gt; &lt;/path&gt; &lt;target name="report"&gt; &lt;tstamp&gt; &lt;format property="report.datestamp" pattern="yyyy/MM/dd HH:mm" /&gt;&lt;/tstamp&gt; &lt;xslt classpathref="xslt.classpath" force="true" in="$&#123;jmeter.result.jtlName&#125;" out="$&#123;jmeter.result.htmlName&#125;" style="$&#123;jmeter.home&#125;/extras/jmeter-results-detail-report_21.xsl"&gt; &lt;param name="dateReport" expression="$&#123;report.datestamp&#125;"/&gt; &lt;/xslt&gt; &lt;!-- 因为上面生成报告的时候，不会将相关的图片也一起拷贝至目标目录，所以，需要手动拷贝 --&gt; &lt;copy todir="$&#123;jmeter.result.html.dir&#125;"&gt; &lt;fileset dir="$&#123;jmeter.home&#125;/extras"&gt; &lt;include name="collapse.png" /&gt; &lt;include name="expand.png" /&gt; &lt;/fileset&gt; &lt;/copy&gt; &lt;/target&gt;&lt;/project&gt; 切换目录到build.xml所在文件夹，运行ant查看结果是否生成（.jtl 和.html）。 集成Jenkins。 Jinkeins安装好后，需要添加如下插件：Performance plugin 、 HTML Publisher plugin 、ant Git, Email Extension Plugin 插件。 在Manage Jenkins –&gt;Config System 里，配置JDK， Ant安装路径。 新建一个freestyle project，配置Source Code Management（一般选用Git）， Build Triggers（何时触发build运行）， 然后build下配置Execute shell，Ant， 然后在Post Build Actions下面配置Publish HTML Reports 和 Publish Performance Test Results Report， 如下图： 配置好后Jenkins会根据你前文设置的Trigger自动download代码执行。结果如下：到此为止我们的接口测试框架就搭建完成了， 怎么样是不很简单? 以上只是iTesting的一个简单接口测试框架，实际应用中，框架还有以下可以优化的地方：1.Jmeter脚本的编写，参数化，及断言调用数据库，前一个post的返回结果是后一个post的入参（这个时候如何传递value）等。2.Build.xml文件编写。这个决定了那些jmx file会运行，报告如何生成。3.Jenkins配置，关键是HTML report和Performance report的配置。]]></content>
      <categories>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>API-Test</tag>
        <tag>测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口测试自动化框架实践指南（一）]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接口测试自动化框架实践指南 对接口测试概念和好处还不甚理解的同学，请移步iTesting的历史文章《接口（API）测试》。今天介绍的接口测试自动化框架组成如下：Jmeter + Ant + Jenkins。我们分为两个部分介绍：1.Jmeter的脚本生成及参数化 Ant + Jenkins集成在详细框架搭建前，我们以一个Restful格式的API为例。这个API的是用做学生上完课后老师给学生的打分：123456789101112131415161718192021222324252627POST: /survey/evc/EVCSurvey/SaveUAT URL: http://**.englishtown.com/***/Survey/SaveSave Survey Result Request &#123; "SurveyResult" : &#123; "SurveyTitle" : "ClassTechnicalSurvey", "SurveyId" : 1000000, "MemberId" : 12345678, "ClassId" : "987654321", "Token" : "dd556a9d36c1984bbab94f37483f484f", "TokenTime" : "2016-04-24T08:56:32.8807460Z" &#125;, "Detail" : [&#123; "Key" : 764, "Value" : 1, "Type" : 3, "Order" : 1 &#125;,&#123;...&#125; ]&#125;Save Survey Result Response &#123; "IsSuccess" : true, "Description" : "", "StatusCode" : 200 //200-&gt;Success, 0-&gt;None, -300-&gt;Invalid Parameter, -400-&gt;Invalid Token, -500-&gt;Unhandled Exception&#125; 我们来看看如何测试这个接口： 手工写test case（如入参的检查，返回值检查，数据库查询，invalid case等不再赘述） 把test case转成一个个jmeter脚本。 运行脚本，查看期望结果（例如返回值，数据库记录等）。 用Ant生成build.xml文件，并成功运行并生成jtl和html格式报告。 集成Ant到Jenkins, 配置自动运行并生成测试报告发送邮件等。今天先介绍第一部分Jmeter的脚本生成及参数化：我们拿正确输入入参，返回正确返回值为例，来介绍如何生成Jmeter脚本。Jmeter安装好后，我们先添加需要用到的选项，按以下步骤添加： 右键Test Plan，Add → ThreadGroup. 右键ThreadGroup， Add → Config Element → HTTP Request Defaults.设置 Server name or IP （*.englishtown.com）， port留空。 右键ThreadGroup， Add → Config Element → HTTP Cookie Manager 右键ThreadGroup， Add → Config Element → HTTP Header Manager并设置如下： 然后右键ThreadGroup，分别add-&gt;Listener-&gt; Aggregate Reportadd-&gt;Listener-&gt; Aggregate ReportView Results in Treeadd-&gt;Listener-&gt; Aggregate ReportSummary Report关注iTesting，后续更精彩。 然后右键ThreadGroup，add-&gt;Config Element-&gt;CSV Data Set Config， 重命名为set variable。并设置如下（这个txt文件里为参数化的值）： 然后右键ThreadGroup，add-&gt;Sampler-&gt;HTTP Request，并重命名为suvery，根据前文API的描述，我们的post请求里配置如下（放在Body Data里），Jmeter参数化格式 ${}： 然后右键suvery， add-&gt;Assertions-&gt;Response Assertions， 并根据API返回值设置assertion 最终我们得到以下配置项并配置完毕如下图所示，点击Run运行。 我们得到的结果如下。 最后我们检查下数据库看看有没有写入就可以了。以上是用jmeter生成脚本，如果不想通过GUI方式运行，也可以用命令行直接调用：格式如下：-n This specifies JMeter is to run in non-gui mode-t [name of JMX file that contains the Test Plan].-l [name of JTL file to log sample results to].-r Run all remote servers specified in JMeter.properties (or remote servers specified on command line by overriding properties)The script also lets you specify the optional firewall/proxy server information:-H [proxy server hostname or ip address]-P [proxy server port]Example : JMeter -n -t my_test.jmx -l log.jtl -H my.proxy.server -P 8000对于我们的例子如下：C:\apache-jmeter-2.13\bin&gt;jmeter -n -t C:\Users\kevin.cai\Desktop\HTTP_Request.jmx -l log.jtl 到此jmeter脚本就生成了，文件后缀*.jmx。我们可以根据需求设计出更多的jmeter脚本以备后用。 明天我们讲如何集成Ant和Jenkins。]]></content>
      <categories>
        <category>api-test</category>
      </categories>
      <tags>
        <tag>API-Test</tag>
        <tag>测试框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口（API）测试]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F%E6%8E%A5%E5%8F%A3(API)%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[什么是接口测试 1.什么是接口测试接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。（像不像集成测试？） 接口可以分下面几种 ：第一种是函数级别的，测试需要对接口的各个参数进行测试，如：Int MathAdd（int a， int b）。第二种是对象级别的，开发在使用API接口时，先引入包名，在使用之前声明一个对象，之后可以使用对象提供的方法，而测试时，需要测试的是API的功能及对数据输入的正确性。第二种和第一种的差别是，我们只需关注提供给用户使用的接口就可以了，不用关心接口调用其他函数情况，相对于第一种来说，测试的粒度要大一些，范围小一些。第三种是http协议的接口，App客户端和后端服务连接，一般采用的都是http协议，客户端通过get和post的方法从后端服务获取数据。第三种相对于第二种来说，粒度更大，我们关注的接口更少，但是这些接口都是核心功能。 而我们所要做的接口测试，先要了解是基于哪一种类型的接口测试，不同类型的接口测试方法可能是不一致的，总体来说，不管是那种类型，我们只要把被测接口当做是服务方，而把我们的测试手段当做是客户方，我们的目的就是，通过我们的测试手段，去验证服务端满足了他声明提供的功能。 接口测试的目的接口测试的目的是测试接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换，传递和控制管理过程，还包括处理的次数。外部接口测试一般是作为系统测试来看待的。 为什么做接口测试节省测试成本，数据模型推算，N多上层bug是由于地层的同一bug引起的，接口测试能够提供系统复杂度上升情况下的低成本高效率的解决方案。 接口测试实施在多系统多平台的构架下，有着极为高效的成本收益比，接口测试天生为搞复杂性的平台带来高效的缺陷监测和质量监督能力。平台越复杂，系统越庞大，接口测试的效果越明显。 如何设计接口测试用例接口测试用例设计和测试用例设计一样，用例设计的内容应该包括：主要测试功能点、测试环境、测试数据、执行操作以及预期结果。 选择好测试对象。对于一个系统做接口测试选择好的测试对象是接口测试关键， 因为我们不可能测试所有接口。 可将这些最外层的接口分为两类：1). 数据进入系统的接口；进入系统的接口实际是我们用例的执行调用的接口。可通过变化参数对这些接口进行调用 ，模拟外部的使用；2). 数据流出系统的接口。流出的接口则是我们用例真正该验证的点。数据从哪里流出，流出时的状态如何 ，此时系统又是什么状态都是我们所应该验证的。 确认完整的测试对象的功能.确认外部接口提供给使用这些接口的外部用户什么样的功能，外部用户真正需要什么样的功能。此两个功能一定要准确详细，用例的设计要严格按照测试对象功能设计才是正确的用例。最后当出发点、对象、功能都确定了，就可以真正设计用例了。 接口测试工具WiresharkPostmanSoapUI web接口测试 :服务器接口测试：是测试浏览器与服务器的接口。这个很容易理解，我们知道web开发一般分前端和后端，前端开发人员用html/css/javascript等技术。后端开发人用php/java/python/ruby等各种语言。用户输入的数据是输入到的前端页面上，怎样把这些数据传递的后台的呢？通过http协议的get与post请求来实现前后端的数据传递。这也可认为是接口测试，调用的登录接口还是查询接口，传参的是用户密码还是搜索关键字。 外部接口测试：这个很典型的例子就是第三方登录，比如你做的新系统免于新用户重新注册的麻烦会提供第三方登录，那用户在登录的时候调用的就是第三方登录的接口，由第三方验证用户名和密码并且返回给当前系统。 web接口测试要点：1、请求是否正确，默认请求成功是200，如果请求错误也能返回404、500等。2、检查返回数据的正确性与格式；json是一种非常创建的格式。3、接口的安全性，一般web都不会暴露在网上任意被调用，需要做一些限制，比如鉴权或认证。4、接口的性能，web接口同样注重性能，这直接影响用户的使用体验。]]></content>
      <categories>
        <category>api-test</category>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>API-Test</tag>
        <tag>basic-knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动APP专项测试]]></title>
    <url>%2F2017%2F04%2F03%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2F%E7%A7%BB%E5%8A%A8APP%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[APP测试，除了传统的那些测试方法外，需要额外关注以下方面：兼容性测试、流量测试、电量测试、弱网络测试、稳定性测试、安全测试和环境相关测试。 第一：兼容性测试针对App通常会考虑这些方面：1）操作系统版本包括Andoird版本，iOS版本2）屏幕分辨率android 800480, 960640,1280720(720p),19201080(1080p),2560*1440(2k).对于iOS,考虑最近几代机型对应的分辨率即可.3）不同厂家的ROM不同厂家的ROM,大多厂家都对android 系统进行了定制、实际中会遇到例如调用相机和底层服务出现的不兼容问题以及摇一摇遇到的不同手机对于方向和重力传感器灵敏度设置不同的问题.4) 网络类型网络类型通常考虑wifi,2g,3g4g下的功能情况。另外针对m版网站考虑不同浏览器类型和屏幕分辨率.第二：流量测试在移动产品的测试中，很有必要对App使用的流量进行度量，大致来说，流量可以从用户使用的的相关性角度分为：一类是用户的操作直接导致的流量消耗；另一类是后台，即在用户没有直接使用情况下的流量消耗。流量的测试方法：基于系统自带功能.eg android proc/uid_stat/{uid} /tcp_send android proc/uid_stat/{uid} /tcp_rcv通过API或者系统埋点来获取数据。通用的流量测试方法：手机抓包，或者wifi代理（Fiddler， Charles）。常见的流量节省方法：数据压缩。压缩包含接口文本数据的压缩，js文件的压缩及图片的压缩。不同数据格式的采用例如采用JSON格式作为接口数据返回格式通常比XML格式要小。控制访问的频次这个主要针对后台数据上报，PUSH消息检查等定时机制的。只获取必要的数据有时候APP一页的内容非常多，而用户可能只会看一部分，过多的从后台拉去数据就是浪费，所以可以采用分屏加载或者懒加载的方式来减少流量消耗。缓存可将图片，js等数据暂存起来，但由于手机存储空间有限，也需要控制整个缓存大小，并给用户提供清理缓存的选项。针对不同网络类型设计不同的访问策略有些APP不同的网络类型返回的内容不一样。第三：电量测试在电器电池技术没有取得巨大突破前提下，这方面始终会存在一些瓶颈，如果一些App架构设计的不好，或者代码偶缺陷，就可能导致电量消耗比较高，所以电量测试也是很重要的。工具 GSam Battery Monitor Pro.第四：弱网络测试移动互联网产品相比PC互联网产品，有一个特点是前者使用的网络比较多样，除了Wif之外，很多时候是在移动网络下使用的，移动网络遇到的情况又比较复杂，比如地铁、隧道、体育场等。所以网络不稳定的情况是比较容易发生的，很多情况下App的一些问题是在复杂的网络情况下才会暴露，与其让用户发现和投诉这些问题，不如我们在测试阶段尽量模拟这样的网络情况，及早发现和修复这些问题。工具：Windows下的Network Delay SimulatorMac下的Network Link Conditioner第五：稳定性测试在保证基本功能正确基础之上，App的稳定性就显得非常重要，如果一个App经常出现闪退或者卡死，那么用户体验就会受到很大伤害，在有其他竞争产品的情况下很容易造成用户的流失。第六：安全测试包括安装包的安全测试（能否反编译代码、安装包是否签名，完整性校验，权限设置检查等）。敏感信息测试（数据库，日志，配置文件）。软键盘劫持（金融类APP登录页面的用户名密码输入框）、账户安全（密码是否明文，密码传输是否加密，账户输入错误次数过多锁定，同时会话提醒， 注销机制）数据通信安全（关键数据是否散列或加密，关键连接是否使用安全通信，是否对数字证书合法性进行验证，是否校验数据合法性。组件安全测试。服务器端接口测试（SQL注入测试、XSS跨站脚本攻击， CSRF跨站请求伪造，越权访问等）。第七：环境相关的测试在实际项目中，有一些缺陷我发现是和App所处的运行环境相关的，所以设计测试的时候，要多考虑这些场景，比如：1）干扰测试收到电话、收到短信、收到通知栏消息、无电提示框弹出、第三方安全软件告警弹出。2）权限测试一些用户在实际使用App的时候回有意识阻止某些功能。例如有的用户感觉让某个App访问电话本或者相册可能泄漏隐私，就在手机中设置了禁止了该App访问相册的权限。3）边界测试手机环境本身也有其边界情况需要在测试中覆盖。常见的场景有：可用存储空间过少、没有SD卡/双SD卡、飞行模式、系统时间有误（晚于和早于标准时间）、第三方依赖（比如我们的App依赖第三方App，但是现在第三方App没有安装或者版本过低的测试情况）。4）Android定位测试用白盒方式模拟]]></content>
      <categories>
        <category>mobile-test</category>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>Mobile-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负载压力测试]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E8%B4%9F%E8%BD%BD%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[负载压力测试是在一定约束条件下测试系统所能承受的并发用户量、运行时间、数据量，以确定系统所能承受的最大负载压力。 负载压力测试有助于确认被测系统是否能够支持性能需求，以及预期的负载增长等。负载压力测试不只是关注不同负载场景下的响应时间等指标，它也要通过测试来发现在不同负载场景下会出现的，例如速度变慢、内存泄漏等问题的原因。负载压力测试是性能测试的重要组成部分，负载压力测试包括并发性能测试、疲劳强度测试、大数据量测试等内容。一般包括如下： 1. 性能测试性能测试用来保证产品发布后系统的性能能够满足用户需求。其中系统性能包括执行效率、资源占用、稳定性、安全性、兼容性、可扩展性、可靠性等。 2. 性能评测性能评测包括：在真实环境下，检查系统服务等级的满足情况，评估并报告整个系统的性能；对系统的未来容量作出预测和规划。负载压力测试结构剖析 3. 性能调优性能调优一般的步骤为首先查找形成系统瓶颈或者故障的根本原因，其次是进行性能调整和优化，最后便是评估性能调整的结果。 4. 负载测试负载测试时通过逐步增加系统负载，测试系统性能的变化，并最终确定在满足性能指标的情况下，系统所能承受的最大负载量的测试。 5. 压力测试压力测试是通过逐步增加系统负载，测试系统性能的变化，并最终确定在什么负载条件下系统性能处于失效状态，并以此来获得系统能提供的最大服务级别的测试。 6. 并发性测试并发性测试的过程，是一个负载测试和压力测试的过程。即逐渐增加并发用户数负载，直到系统的瓶颈或者不能接收的性能点。并发性测试分为三类：a、应用在客户端性能的测试；b、应用在网络上性能的测试；c、应用在服务器上性能的测试； 7. 疲劳强度测试8. 大数据量测试大数据量测试包括独立的数据量测试和综合数据量测试两类。 负载压力测试的目的： 在真实环境下检测系统性能，评估系统性能以及服务等级的满足情况 例如电信计费软件，众所周知，每月20日左右是市话交费的高峰期，全市几千个收费网点同时启动。收费过程一般分为两步，首先要根据用户提出的电话号码来查询出其当月产生费用，然后收取现金并将此用户修改为已交费状态。一个看起来简单的两个步骤，当成百上千的终端同时执行这样的操作时情况就大不一样了，如此众多的交易同时发生，对应用程序本身、操作系统、中心数据库服务器、中间件服务器、网络设备的承受力都是一个严峻的考验。决策者需要模拟系统负载压力，预见软件的并发承受力，这是在测试阶段就应该解决的重要问题。 一个企业自己组织力量或委托软件公司代为开发的应用系统，在生产环境中实际使用起来以后，往往会产生这样一个问题，即这套系统能不能承受大量的并发用户同时访问，这个问题是系统负载压力需求的体现。 这里强调在真实环境下检测系统性能，在实施过程中大家认为这样做会遇到很多阻力，比如系统上线运行之后，真实环境下不允许负载压力测试为系统带来大量的垃圾数据，测试数据与真实业务数据混在一起无法控制测试结果，负载压力测试如果使服务器宕机会给系统带来巨大损失等。那么在这种条件下不允许的情况下，应该采用什么肃然措施弥补呢？我们可以使用一种“模拟环境”来做测试，这种环境是指与实际真实应用环境基本等级保持一致的测试环境。 预见系统负载压力承受力，在应用实际部署之前，评估系统性能。 目前的大多数公司企业需要支持成百上千名用户，各类应用环境，以及由不同供应商的元件组装起来的复杂产品。难以预知的用户负载和越来载复杂的应用程序，使公司时时担忧会发生投放性能差，用户遭受反应慢，系统失灵等问题。其结果就是导致公司收益的损失。 检测系统性能强调对系统当前性能的评估中，通过评估，可以在应用实际部署之前，预见系统负载压力承受力。这种测试的意义在于指导系统总体设计，既可以避免浪费不必要的人力、物力和财力，又避免硬件和软件的设计不匹配，使系统具有更长、更健壮的生命力。 如何确定系统的“负载压力承受力”是一个非常复杂且关键的问题。 对于系统性能检测，有时我们所从事的工作仅仅是被动监控一些性能指标，而预见系统负载压力承受力，则不可避免地会借助自动化的负载压力测试工具。 分析系统瓶颈、优化系统 系统性能检测和预见为分析系统瓶颈和优化提供了原始数据，打好了基础。 系统瓶颈即应用系统中导致系统性能大幅下降的原因。 瓶颈大大降低了系统性能，一般情况下，发现瓶颈并找出原因并不是件容易的事。很多时候你可能无法准确定位系统瓶颈之所在。瓶颈可能定位在硬件中，也可能定位在软件中，对于后者，是无能为力的。硬件中的瓶颈可能会非常容易排除,一般来讲，解决硬件瓶颈的方法只是简单地向系统中添加CPU、磁盘或者内存等，如果硬件瓶颈是由于系统缓冲区设计或内存总线造成的，那么通常情况下就无能为力了。硬件瓶颈与软件瓶颈相比，更建议先解决软件瓶颈，原因有三，其一是软件瓶颈往往导致系统性能衰减更快，反过来讲，消除软件瓶颈，系统性能提升更快；其二是人为因素更易导致软件瓶颈，要消除软件瓶颈，开发人员会更主动，并且可以节省资源；其三，盲目增加硬件则无形中增加维护费用，将来，软硬件不匹配的问题终究还会暴露出来。 优化调整系统是在发现瓶颈，故障定位之后要完成的事情，实现优化之后即可消除瓶颈，提高性能。 性能测试指标： 指标 说明 ProcessorTime 服务器CPU占用率，一般平均达到70%时，服务就接近饱和 Memory Available Mbyte 可用内存数，如果测试时发现内存有变化情况也要注意，如果是内存泄露则比较严重 Physicsdisk Time 物理磁盘读写时间情况 Web服务器指标 指标 说明 Requests Per Second（Avg Rps） 平均每秒钟响应次数＝总请求时间 / 秒数 Avg time to last byte per terstion （mstes） 平均每秒业务脚本的迭代次数 ,有人会把上面那个混淆 Successful Rounds 成功的请求 Failed Requests 失败的请求 Successful Hits 成功的点击次数 Failed Hits 失败的点击次数 Hits Per Second 每秒点击次数 Successful Hits Per Second 每秒成功的点击次数 Failed Hits Per Second 每秒失败的点击次数 Attempted Connections 尝试链接数 指标 说明 User 0 Connections 用户连接数，也就是数据库的连接数量 Number of deadlocks 数据库死锁 Butter Cache hit 数据库Cache的命中情况 系统的瓶颈定义 性能项 命令 指标 CPU限制 vmstat 当%user+%sys超过80%时 磁盘I/O限制 Vmstat 当%iowait超过40%(AIX4.3.3或更高版本)时 应用磁盘限制 Iostat 当%tm_act超过70%时 虚存空间少 Lsps，-a 当分页空间的活动率超过70%时 换页限制 Iostat, stat 虚存逻辑卷%tm_act超过I/O(iostat)的30%，激活的虚存率超过CPU数量(vmstat)的10倍时 系统失效 Vmstat, sar 页交换增大、CPU等待并运行队列 稳定系统的资源状态]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>basic-knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试，集成测试，系统测试，确认测试]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%EF%BC%8C%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%EF%BC%8C%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[从测试阶段的划分可以分为单元测试、集成测试、系统测试、确认测试。下面内容来自网络相关资料的整理。 1. 单元测试（1）定义：单元测试（又称为模块测试）是针对程序模块(软件设计的最小单位)来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 （2）单元测试任务包括：1 模块接口测试；2 模块局部数据结构测试；3 模块边界条件测试；4 模块中所有独立执行通路测试；5 模块的各条错误处理通路测试。 模块接口测试是单元测试的基础。只有在数据能正确流入、流出模块的前提下，其他测试才有意义。测试接口正确与否应该考虑下列因素： 1 输入的实际参数与形式参数的个数是否相同； 2 输入的实际参数与形式参数的属性是否匹配； 3 输入的实际参数与形式参数的量纲是否一致； 4 调用其他模块时所给实际参数的个数是否与被调模块的形参个数相同； 5 调用其他模块时所给实际参数的属性是否与被调模块的形参属性匹配； 6 调用其他模块时所给实际参数的量纲是否与被调模块的形参量纲一致； 7 调用预定义函数时所用参数的个数、属性和次序是否正确； 8 是否存在与当前入口点无关的参数引用； 9 是否修改了只读型参数； 10 对全程变量的定义各模块是否一致； 11是否把某些约束作为参数传递。 如果模块内包括外部输入输出，还应该考虑下列因素： 1 文件属性是否正确； 2 OPEN/CLOSE语句是否正确； 3 格式说明与输入输出语句是否匹配； 4缓冲区大小与记录长度是否匹配； 5文件使用前是否已经打开； 6是否处理了文件尾； 7是否处理了输入/输出错误； 8输出信息中是否有文字性错误； 检查局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整、正确。局部数据结构往往是错误的根源，应仔细设计测试用例，力求发现下面几类错误： 1 不合适或不相容的类型说明； 2 变量无初值； 3 变量初始化或省缺值有错； 4 不正确的变量名（拼错或不正确地截断）； 5 出现上溢、下溢和地址异常。 除了局部数据结构外，如果可能，单元测试时还应该查清全局数据（例如FORTRAN的公用区）对模块的影响。 在模块中应对每一条独立执行路径进行测试，单元测试的基本任务是保证模块中每条语句至少执行一次。此时设计测试用例是为了发现因错误计算、不正确的比较和不适当的控制流造成的错误。此时基本路径测试和循环测试是最常用且最有效的测试技术。计算中常见的错误包括： 1 误解或用错了算符优先级； 2混合类型运算； 3变量初值错； 4精度不够； 5表达式符号错。 比较判断与控制流常常紧密相关，测试用例还应致力于发现下列错误： 1不同数据类型的对象之间进行比较； 2错误地使用逻辑运算符或优先级； 3因计算机表示的局限性，期望理论上相等而实际上不相等的两个量相等； 4比较运算或变量出错； 5循环终止条件或不可能出现； 6迭代发散时不能退出； 7错误地修改了循环变量。 一个好的设计应能预见各种出错条件，并预设各种出错处理通路，出错处理通路同样需要认真测试，测试应着重检查下列问题： 1输出的出错信息难以理解； 2记录的错误与实际遇到的错误不相符； 3在程序自定义的出错处理段运行之前，系统已介入； 4异常处理不当； 5错误陈述中未能提供足够的定位出错信息。 边界条件测试是单元测试中最后，也是最重要的一项任务。众的周知，软件经常在边界上失效，采用边界值分析技术，针对边界值及其左、右设计测试用例，很有可能发现新的错误。 （3）单元测试过程 一般认为单元测试应紧接在编码之后，当源程序编制完成并通过复审和编译检查，便可开始单元测试。测试用例的设计应与复审工作相结合，根据设计信息选取测试数据，将增大发现上述各类错误的可能性。在确定测试用例的同时，应给出期望结果。 应为测试模块开发一个驱动模块（driver）和（或）若干个桩模块（stub）,下图显示了一般单元测试的环境。驱动模块在大多数场合称为“主程序”，它接收测试数据并将这些数据传递到被测试模块，被测试模块被调用后，“主程序”打印“进入-退出”消息。 驱动模块和桩模块是测试使用的软件，而不是软件产品的组成部分，但它需要一定的开发费用。若驱动和桩模块比较简单，实际开销相对低些。遗憾的是，仅用简单的驱动模块和桩模块不能完成某些模块的测试任务，这些模块的单元测试只能采用下面讨论的综合测试方法。 提高模块的内聚度可简化单元测试，如果每个模块只能完成一个，所需测试用例数目将显著减少，模块中的错误也更容易发现。集成测试：在单元测试的基础上，将模块按照设计要求组装进行测试。一般包括逻辑关系检查、数据关系检查、业务关系检查、模块间接口检查、外部接口检查。 2. 集成测试（1）定义： 集成测试也叫组装测试、联合测试、子系统测试或部件测试。集成测试是在单元测试的基础上，将所有模块按照概要设计要求组装成为子系统或系统。 （2）集成测试的关注点： 1.在把各个模块连接起来时，穿越模块接口的数据是否会丢失。 2.各个子功能组合起来，能否达到预期的要求的父功能。 3.一个模块的功能是否会对另一个模块的功能产生不利的影响。 4.全局数据结构是否有问题，会不会被异常修改。 5.单个模块的误差积累起来，是否会放大，从而达到不可接受的程度。 （3）集成测试的模式： ① 非增殖式集成方式。先分别测试每个模块，再把所有模块按设计要求一次全部组装起来所要的系统，然后进行整体测试。使用这种方式可能发现一大堆错误，但为每个错误定位和纠正非常困难，并且在改正一个错误的同时又可能引入新的错误，新旧错误混杂，更难断定出错的原因和位置。 ② 增殖式集成方式。又称渐增式集成方式。首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。最后通过增殖逐步组装成为要求的软件系统。 常用的增殖方法有：自顶向下集成测试、自底向上集成测试、核心集成测试等。 自顶向下的增殖方式：将模块按系统程序结构，沿控制层次自顶向下进行集成。由于这种增殖方式在测试过程中较早地验证了主要的控制和判断点。在一个功能划分合理的程序结构中，判断常出现在较高的层次，较早就能遇到。如果主要控制有问题，尽早发现它能够减少以后的返工。 自底向上的增殖方式：从程序结构的最底层模块开始组装和测试。因为模块是自底向上进行组装，对于一个给定层次的模块，它的子模块(包括子模块的所有下属模块)已经组装并测试完成，所以不再需要桩模块。在模块的测试过程中需要从子模块得到的信息可以直接运行子模块得到。 自顶向下增殖的方式和自底向上增殖的方式各有优缺点。自顶向下增殖方式的缺点是需要建立桩模块。要使桩模块能够模拟实际子模块的功能将是十分困难的。同时涉及复杂算法和真正输入/输出的模块一般在底层，它们是最容易出问题的模块，到组装和测试的后期才遇到这些模块，一旦发现问题，导致过多的回归测试。而自顶向下增殖方式的优点是能够较早地发现在主要控制方面的问题。自底向上增殖方式的缺点是“程序一直未能做为一个实体存在，直到最后一个模块加上去后才形成一个实体”。就是说，在自底向上组装和测试的过程中，对主要的控制直到最后才接触到。但这种方式的优点是不需要桩模块，而建立驱动模块一般比建立桩模块容易，同时由于涉及到复杂算法和真正输入/输出的模块最先得到组装和测试，可以把最容易出问题的部分在早期解决。此外自底向上增殖的方式可以实施多个模块的并行测试。 核心集成测试：核心系统先行集成测试法的思想是先对核心软件部件进行集成测试，在测试通过的基础上再按各外围软件部件的重要程度逐个集成到核心系统中。每次加入一个外围软件部件都产生一个产品基线，直至最后形成稳定的软件产品。核心系统先行集成测试法对应的集成过程是一个逐渐趋于闭合的螺旋形曲线，代表产品逐步定型的过程。 ③ 混合增殖式测试 3. 系统测试（1）定义：系统测试是在所有单元、集成测试后，对系统的功能及性能的总体测试。 （2）系统测试内容：系统不仅仅包括软件本身，而且还包括计算机硬件及其相关的外围设备、实际运行时大批量数据、非正常操作(如黑客攻击)等。通常意义上的系统测试包括压力测试、容量测试、性能测试、安全测试、容错测试等。 · 压力测试(s”esstest)：也称为强度测试、负载测试。压力测试是模拟实际应用的软硬件环境及用户使用过程的系统负荷，长时间或超大负荷地运行测试软件，来测试被测系统的性能、可靠性、稳定性等。压力测试的目的就是在软件投入使用以前或软件负载达到极限以前，通过执行可重复的负载测试，了解系统硼J靠性、性能瓶颈等，以提高软件系统的可靠性、稳定性，减少系统的宕机时间和因此带来的损失。 · 容量测试(c印ac时test)：预先分析出反映软件系统应用特征的某项指标的极限值，如某个web站点可以支持多少个并发用户的访问量、网络在线会议系统的与会者人数。知道了系统的实际容量，如果不能满足要求，就应该寻求新的解决方案， 以提高系统的容量。若一时没有新的解决方案，就有必要在产品发布说明书上明确这些容量的限制，避免引起软件产品使用上的纠纷。如果实际容量已满足要求，就能帮助用户建立对产品的信心。 · 性能测试(pe晌nllance test)：通过测试确定系统运行时的性能表现，如得到运行速度、响应时间、占有系统资源等方面的系统数据。对丁那些实时或嵌入式系统，系统有时满足了功能要求，但未必能够满足性能要求，如某个}{_9站可以被访问， 而且司以提供预先设定的功能，但每打开一个页面都需要1～2分钟，用户不可忍 受，其结果没有用户愿意使用这个网站所提供的服务。 · 安全测试(securhyten)：检查系统对非法侵入的防范能力。安全测试期间。测试人员假扮非法入侵者，采用各种办法试图突破防线。系统安全设计的准则是，使非法侵入的代价超过被保护信息的价值。 · 容错测试(recovervtest)：主要检查系统的容错能力。当系统出错时，能否在指定时间间隔内修正错误并重新启动系统。容错测试首先要通过各种手段，让软件强制性地发生故障，然后验证系统是否能尽快恢复。对于自动恢复需验证熏新初始化、检查点、数据恢复和重新启动等机制的正确性 4. 确认测试（1）定义：确认测试又称有效性测试。有效性测试是在模拟的环境下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。任务是验证软件的功能和性能及其他特性是否与用户的要求一致。对软件的功能和性能要求在软件需求规格说明书中已经明确规定，它包含的信息就是软件确认测试的基础。 确认测试的目的是向未来的用户表明系统能够像预定要求那样工作。经集成测试后，已经按照设计把所有的模块组装成一个完整的软件系统，接口错误也已经基本排除了，接着就应该进一步验证软件的有效性，这就是确认测试的任务，即软件的功能和性能如同用户所合理期待的那样。 （2）基本方法： 通过集成测试之后，软件已完全组装起来，接口方面的错误也已排除，确认测试即可开始。确认测试应检查软件能否按合同要求进行工作，即是否满足软件需求说明书中的确认标准。 1. 确认测试标准 实现软件确认要通过一系列黑盒测试。确认测试同样需要制订测试计划和过程，测试计划应规定测试的种类和测试进度，测试过程则定义一些特殊的测试用例，旨在说明软件与需求是否一致。无论是计划还是过程，都应该着重考虑软件是否满足合同规定的所有功能和性能，文档资料是否完整、准确人机界面和其他方面（例如，可移植性、兼容性、错误恢复能力和可维护性等）是否令用户满意。 确认测试的结果有两种可能，一种是功能和性能指标满足软件需求说明的要求，用户可以接受；另一种是软件不满足软件需求说明的要求，用户无法接受。项目进行到这个阶段才发现严重错误和偏差一般很难在预定的工期内改正，因此必须与用户协商，寻求一个妥善解决问题的方法。 2. 配置复审 确认测试的另一个重要环节是配置复审。复审的目的在于保证软件配置齐全、分类有序，并且包括软件维护所必须的细节。 3. α、β测试 事实上，软件开发人员不可能完全预见用户实际使用程序的情况。例如，用户可能错误的理解命令，或提供一些奇怪的数据组合，亦可能对设计者自认明了的输出信息迷惑不解，等等。因此，软件是否真正满足最终用户的要求，应由用户进行一系列“验收测试”。验收测试既可以是非正式的测试，也可以有计划、有系统的测试。有时，验收测试长达数周甚至数月，不断暴露错误，导致开发延期。一个软件产品，可能拥有众多用户，不可能由每个用户验收，此时多采用称为α、β测试的过程，以期发现那些似乎只有最终用户才能发现的问题。 α测试是指软件开发公司组织内部人员模拟各类用户行对即将面市软件产品（称为α版本）进行测试，试图发现错误并修正。α测试的关键在于尽可能逼真地模拟实际运行环境和用户对软件产品的操作并尽最大努力涵盖所有可能的 用户操作方式。经过α测试调整的软件产品称为β版本。紧随其后的β测试是指软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，并要求用户报告异常情况、提出批评意见。然后软件开发公司再对β版本进行改错和完善。]]></content>
      <categories>
        <category>basic-knowledge</category>
        <category>block-box</category>
      </categories>
      <tags>
        <tag>basic-knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白盒测试用例设计]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。 这一方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。 常用的软件测试方法有两大类：静态测试方法和动态测试方法。其中软件的静态测试不要求在计算机上实际执行所测程序，主要以一些人工的模拟技术对软件进行分析和测试；而软件的动态测试是通过输入一组预先按照一定的测试准则构造的实例数据来动态运行程序，而达到发现程序错误的过程。 白盒测试的测试方法有： 代码检查法静态结构分析法静态质量度量法逻辑覆盖法用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。 基本路径测试法用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。 域测试 域测试是一种基于程序结构的测试方法，基于对程序输入空间（域）的分析，选择测试点进行测试。域测试主要测试如下错误：1）域错误：程序的控制流存在错误，对于某一特定的输入可能执行的是一条错误路径，这种错误称为路径错误，也叫做域错误。2）计算型错误：对于特定输入执行的路径正确，但赋值语句的错误导致输出结果错误，称为计算型错误。3）丢失路径错误：由于程序中的某处少了一个判定谓词而引起的丢失路径错误。 域测试的缺点是：1）为进行域测试对程序提出的限制过多.2）当程序中存在很多路径时，所需的测试点很多. 符号测试符号测试的基本思想是允许程序的输入不仅仅是具体的数值数据，而且包括符号值，符号值可以是基本的符号变量值，也可以是符号变量值的表达式。符号测试的优点如下：1）符号测试执行的是代数运算，可以作为普通测试的扩充。2）符号测试可以看做是程序测试和程序验证的一种折中办法。3）符号测试程序中仅有有限的几条执行路径。符号测试的缺点是：1）分支问题不能控制。2）二义性问题不能控制。3）大程序问题不能控制。 Z路径覆盖Z路径覆盖是路径覆盖的一个变体,路径覆盖是白盒测试最为典型的问题,着眼于路径分析的测试可称为路径测试。完成路径测试的理想情况是做到路径覆盖,对于比较简单的小程序实现路径覆盖是可能做到的,但是如果程序中出现多个判断和多个循环，可能的路径数目将会急剧增长，达到天文数字，以至实现路径覆盖不可能做到。 为了解决这一问题，我们必须舍掉一些次要因素，对循环机制进行简化，从而极大地减少路径的数量，使得覆盖这些有限的路径成为可能。我们称简化循环意义下的路径覆盖为Z路径覆盖。 这里所说的对循环化简是指，限制循环的次数。无论循环的形式和实际执行循环体的次数多少，我们只考虑循环一次和零次两种情况。也即只考虑执行时进入循环体一次和跳过循环体这两种情况。 对于程序中的所有路径可以用路径树来表示。当得到某一程序的路径树后，从其根结点开始，一次遍历，再回到根结点时，把所经历的叶结点名排列起来，就得到一个路径。如果我们设法遍历了所有的叶结点，那就得到了所有的路径。 当得到所有的路径后，生成每个路径的测试用例，就可以做到Z路径覆盖测试。 程序变异。程序变异方法与前面提到的结构测试和功能测试都不一样，它是一种错误驱动测试。 错误驱动测试方法，是指该方法是针对某类特定程序错误的。 错误驱动测试主要有两种，即程序强变异和程序弱变异。 白盒测试综合策略:（1）在测试中，首先尽量使用测试工作进行静态结构分析（2）采用先静态后动态的组合方式，先进行静态结构分析，代码检查和静态质量度量，然后现进行覆盖测试（3）利用静态结构分析的结果，通过代码检查和动态测试的方法对结果进一步确认，使测试工作更为有效（4）覆盖率测试是白盒测试的重点，使用基本路径测试达到语句覆盖标准；对于重点模块，应使用多种覆盖标准衡量代码的覆盖率（5）不同测试阶段，侧重点不同单元测试：以代码检查、逻辑覆盖集成测试：增加静态结构分析、静态质量度量系统测试：根据黑盒测试结果，采用白盒测试.]]></content>
      <categories>
        <category>basic-knowledge</category>
        <category>white-box</category>
      </categories>
      <tags>
        <tag>basic-knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白盒测试之基本路径测试法]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本路径测试是一种白盒测试方法，它在程序控制图的基础上，通过分析控制构造的环行复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每一个可执行语句至少执行一次。 1. 工具/原料 图形矩阵 控制流图 2. 方法/步骤画出控制流图。使用控制流图制作方法对程序流程图进行简化，以突出的表示程序控制流的结构。对于复合条件，则可将其分解为多个单个条件，并映射成控制流图。图例如图所示。 确定程序基本集的独立路径数量，再确保所有语句至少执行一次的测试数量的上界。需要注意的是测试可以被设计为基本路径集的执行过程，但基本路径集通常并不唯一。一般而言控制流图中区域的数量对应于环形复杂度。 再根据上面的独立路径，去设计输入数据，使程序分别执行到上面四条路径。于是形成路程测试用例。为了确保基本路径集中的每一条路径的执行，根据判断结点给出的条件，选择适当的数据以保证某一条路径可以被测试到 有关圈复杂度： 圈复杂度是一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在定义之前不曾用到的边。 有以下三种方法计算圈复杂度： 流图中区域的数量对应于环型的复杂性; 给定流图G的圈复杂度V(G)，定义为V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量; 给定流图G的圈复杂度V(G)，定义为V(G)=P+1，P是流图G中判定结点的数量。]]></content>
      <categories>
        <category>basic-knowledge</category>
        <category>white-box</category>
      </categories>
      <tags>
        <tag>basic-knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白盒测试之逻辑覆盖法]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95%2F</url>
    <content type="text"><![CDATA[逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的技术。根据覆盖目标的不同和覆盖源程序语句的详尽程度，逻辑覆盖又可分为： 语句覆盖(SC) 判定覆盖(DC) 条件覆盖(CC) 条件/判定覆盖(CC) 条件组合覆盖(MCC) 修正判定条件覆盖(MCDC) 点覆盖 边覆盖 路径覆盖 几种逻辑覆盖标准发现错误的能力呈由弱至强的变化。 下面我们来逐一举例详解： 1. 语句覆盖（SC）：语句覆盖是指选择足够的测试用例，使得运行这些测试用例时，被测程序的每一个语句至少执行一次，其覆盖标准无法发现判定中逻辑运算的错误. 我们看下面的被测试代码：1234int foo(int a, int b)&#123;return a / b;&#125;假如我们的测试人员编写如下测试案例：TeseCase: a = 10, b = 5 测试人员的测试结果会告诉你，他的代码覆盖率达到了100%，并且所有测试案例都通过了。然而遗憾的是，我们的语句覆盖率达到了所谓的100%，但是却没有发现最简单的 Bug，比如，当我让b=0时，会抛出一个除零异常。 简言之，语句覆盖，就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。这里的“若干个”，意味着使用测试用例越少越好。 语句覆盖率的公式可以表示如下：语句覆盖率=可执行的语句总数/被评价到的语句数量 x 100% 2. 判定覆盖(DC)判定覆盖是设计足够多的测试用例，使得程序中的每一个判断至少获得一次“真”和一次“假”，即使得程序流程图中的每一个真假分支至少被执行一次。但若程序中的判定是有几个条件联合构成时，它未必能发现每个条件的错误。例：int a,b;if(a || b)执行语句1else执行语句2 要达到这段程序的判断覆盖,我们采用测试用例:1)a = true , b = false;2)a = false, b = false 3. 条件覆盖(CC)条件覆盖是指选择足够的测试用例，使得运行这些测试用例时，判定中每个条件的所有可能结果至少出现一次，但未必能覆盖全部分支.例：int a,b;if(a || b)执行语句1else执行语句2 要达到这段程序的条件覆盖,我们采用测试用例:1)a = true , b = false ;2)a = false, b = true 4. 判定/条件覆盖（CDC）判定/条件覆盖是使判定中每个条件的所有可能结果至少出现一次，并且每个判定本身的所有可能结果也至少出现一次。例：int a,b;if(a || b)执行语句1else执行语句2 要达到这段程序的判定/条件覆盖,我们采用测试用例:1)a = true , b = true;2)a = false, b = false 5. 条件组合覆盖（MCC）选择足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。显然，满足“条件组合覆盖”的测试用例是一定满足“判定覆盖”、“条件覆盖”和“判定/条件覆盖”的。 例：int a,b;if(a || b)执行语句1else执行语句2 要达到这段程序的判定/条件覆盖,我们采用测试用例:1)a = true , b = true;2)a = false, b = false3)a = true, b = false4)a = false, b = ture 6. 修正判定条件覆盖（MC/DC）MC/DC首先要求实现条件覆盖、判定覆盖，在此基础上，对于每一个条件C，要求存在符合以下条件的两次计算： 1）条件C所在判定内的所有条件，除条件C外，其他条件的取值完全相同； 2）条件C的取值相反； 3）判定的计算结果相反。 核心意思是每个条件都要独立影响判定结果。为什么说“两次计算”，而不是“两个用例”呢？当循环中有判定时，一个用例下同一判定可能被计算多次，每次的条件值和判定值也可能不同，因此，一个用例就可能完成循环中判定的MC/DC。 MC/DC是条件组合覆盖的子集。条件组合覆盖要求覆盖判定中所有条件取值的所有可能组合，需要大量的测试用例，实用性较差。MC/DC具有条件组合覆盖的优势，同时大幅减少用例数。满足MC/DC的用例数下界为条件数+1，上界为条件数的两倍，例如，判定中有三个条件，条件组合覆盖需要8个用例，而MC/DC需要的用例数为4至6个。如果判定中条件很多，用例数的差别将非常大，例如，判定中有10个条件，条件组合覆盖需要1024个用例，而MC/DC只需要11至20个用例。 下面是MC/DC的示例： 代码： {% codeblock lang:c %} int func(BOOL A, BOOL B, BOOL C) { if(A && (B || C)) return 1; return 0; } {% endcodeblock %} 用例： 对于条件A，用例1和用例2，A取值相反，B和C相同，判定结果分别为1和0； 对于条件B，用例1和用例3，B取值相反，A和C相同，判定结果分别为1和0； 对于条件C，用例3和用例4，C取值相反，A和B相同，判定结果分别为0和1。 7. 路径覆盖（PC）MC/DC被称为“最严格的标准”，但这种说法是将条件组合覆盖和路径覆盖排除在外为基础的。MC/DC显然不如条件组合覆盖严格，但是条件组合覆盖需要太多用例，实际应用中难以做到，所以排除，那么，路径覆盖是否也难以做到？使用先进的工具，对于一般的代码，实现路径覆盖还是可能的。另外，路径代表了从函数入口到出口的所有可能的代码组合，这些组合会不会出问题？只有路径覆盖能发现，这与MC/DC侧重于判定内的条件的组合关系是完全不同的。 ＭC/DC与路径覆盖的侧重点不同，两者都有其优势和局限性，如果组合起来，优势互补，形成“MC/DC-路径覆盖”，就是真正意义上的“最严格的标准”了。 有些程序，路径数量可能大得惊人，可用以下规则和方法减少路径数量： 计算路径时，不考虑循环的次数，将循环结构视为循环体“至少执行一次”和“从不执行”两个分支； 不考虑条件的计算结果只考虑判定的计算结果，条件间的组合关系由条件覆盖、C/DC和MC/DC负责； 一个分支如果不可达，通过该分支的所有路径也不可达，可以让工具自动排除； 当代码很复杂时，理想的处置方式是将部分代码独立为函数，如果做不到，可以让工具来模拟，即在逻辑结构图中，将部分代码临时屏蔽，被屏蔽的代码视为一个函数调用。交替屏蔽可以既减少路径数量，又保证路径覆盖的效果。 对于一般复杂度的代码，采用以上规则和方法后，路径数量和用例数量可以维持在一个现实可覆盖的的范围内。 路径覆盖的主要缺陷是：不相关的逻辑块会组合出大量没有意义的路径。一个函数的路径，可能达到几万条甚至几百万条。如果路径超过100条，通常路径覆盖就没有意义了。对于一般企业来说，建议用MC/DC作为统一的覆盖标准，只有特别关键的代码，才要求完成“MC/DC-路径覆盖”。 路径覆盖要求设计足够多的测试用例，在白盒测试法中，覆盖程度最高的就是路径覆盖，因为其覆盖程序中所有可能的路径。对于比较简单的小程序来说，实现路径覆盖是可能的，但是如果程序中出现了多个判断和多个循环，可能的路径数目将会急剧增长，以致实现路径覆盖是几乎不可能的。]]></content>
      <categories>
        <category>basic-knowledge</category>
        <category>white-box</category>
      </categories>
      <tags>
        <tag>basic-knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑盒测试用例设计]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。黑盒测试法注重于测试软件的功能需求，主要试图发现下列几类错误。 功能不正确或遗漏；界面错误；输入和输出错误；数据库访问错误；性能错误；初始化和终止错误等。 常用的黑盒测试方法有：等价类划分用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。 边界值分析用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。 错误推测法基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。 因果图用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。 功能图 场景法用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。 测试方法选择的综合策略：（1）首先进行等价类划分，包括输入条件和输出条件的等价划分，将无限测试变成有限测试，这是减少工作量和提高测试效率最有效的方法。（2）在任何情况下都必须使用边界值分析方法。经验表明，用这种方法设计出的测试用例发现程序错误的能力最强。（3）如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法和判定表驱动法。（4）对于业务流清晰的系统，可以利用场景法贯穿整个测试案例过程，在案例中综合使用各种测试方法。（5）可以用错误推测法追加一些测试用例，这需要依靠测试工程师的智慧和经验。（6）对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度。如何没有达到要求的覆盖标准，应当再补充足够的测试用例。（7）对参数配置类得软件，要用正交试验法选择较少的组合方式达到最佳效果。（8）功能图法也是很好的测试用例设计方法，我们可以通过不同时期条件的有效性设计不同的测试数据。 (9) 对于业务清晰的系统，可以利用场景法贯穿整个测试案例过程，在案例中综合使用各种测试方法。]]></content>
      <categories>
        <category>basic-knowledge</category>
        <category>block-box</category>
      </categories>
      <tags>
        <tag>basic-knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试的原则]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[测试应该遵循怎样的原则呢？ 1、所有的测试都应追溯到用户需求。因为软件的目的是使用户完成预定的任务，满足其需求，而软件测试揭示软件的缺陷和错误，一旦修正这些错误就能更好地满足用户需求。 2、应尽早地和不断地进行软件测试。由于软件的复杂性和抽象性，在软件生命周期各阶段都可能产生错误，所以不应把软件测试仅仅看作是软件开发的一个独立阶段，而应当把它贯穿到软件开发的各个阶段去。在需求分析和设计阶段就应开始进行测试工作，编写相应的测试计划及测试设计文档，同时坚持在开发各阶段进行技术评审和验证，这样才能尽早发现和预防错误，杜绝某些缺陷和错误，提高软件质量，测试工作进行得越早，越有利于提高软件的质量，这是预防性测试的基本原则。 3、完全测试是不可能的， 测试需要终止。因为，测试输入量大、输出结果多、路径组合太多，用有限的资源来达到完全测试是不现实的。 4、测试只能证明软件存在错误而不能证明软件没有错误。测试是无法显示潜在的错误和缺陷，继续进一步错误可能还会找到其它错误和缺陷。 5、充分关注测试中的集群现象。在测试的程序段中，若发现的错误数目多，则残存在其中的错误也越多，因此应当花较多的时间和代价测试那些具有更多错误数目的程序模块。 6、程序员应避免检查自己的程序。考虑到人们的心理因素，自己揭露自己程序中的错误是件不愉快的事，自己不愿意否认自己的工作;另一方面，由于思维定势，自己难以发现自己的错误。因此，测试一般由独立的测试部门或第三方机构进行。 7、尽量避免测试的随意性。软件测试是有组织、有计划、有步骤的活动，要严格按照测试计划进行，要避免测试的随意性。]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>basic-knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appium远程运行自动化脚本]]></title>
    <url>%2F2017%2F04%2F02%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FAppium%E8%BF%9C%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[前面我分享过移动端测试&lt;移动APP自动化测试之元素定位&gt;, 但没有像web端测试那样系统，例如框架一笔带过，分布式运行甚至都没有提。近期有读者问我一个问题，如何实现Appium在远程运行自动化脚本？ 我建议他自己研究下，此文即为他的研究成果，分享给大家， 以下是正文： Appium的远程设置客户端控制脚本，服务器控制手机和appium server（注：最终脚本运行在这个机器上）。 客户端（PC1）配置IP地址要同服务器（appium server）在一个网段内。 服务端设置地址和端口号，设置Server Address为0.0.0.0，Port为4723。 （注：服务器端实际IP为192.168.3.35） 开启appium server服务 在客户端（PC1）上验证能不能访问appium server在浏览器上输入服务器的地址：（如下图所示） 在客户端（PC1）中，修改脚本 手机设备插在服务器mac上 在客户端（PC1）中，执行脚本如果在appium server（MAC机器上）能跑自动化，证明远程设置成功啦！ ——-我是分割线———-总结起来就一句话，webdriver.Remote（）这个方法控制脚本运行在哪个机器上，你想要脚本运行在哪台机器上，就在你的远程脚本里配置这个ip，并在被运行脚本的这台机器上的Appium server上，配置server地址为127.0.1或0.0.0.0。]]></content>
      <categories>
        <category>mobile-test</category>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Mobile-Test</tag>
        <tag>Appium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动化测试之元素定位]]></title>
    <url>%2F2017%2F04%2F02%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FiOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[iOS自动化测试之元素定位 在iOS自动化测试过程中， 如何来定位页面元素呢？ 利用Appium的Inspector第一步，配置好你要运行的app的各项参数，如下图所示：app path指向源代码编译后生成的 *.app文件然后点击Launch（1）打开APP， 然后点击Inspector Icon（2）来load Inspector。 第二步，Inspector打开后如下图所示：最右边是我们的APP HelloKevin， 目前只有一个TextEdit dialog。 左边红色部分是我们可以选择的locator。 第三步， 定位元素。 写好能唯一指定页面元素的locator，然后点击右边的search， 如果定位正确，就会如下图所所示：对应的代码（以Python为例）：123456from page_objects import PageElement........TEXT_EDIT_XPATH = "//UIATextField[1]"text_edit_dialog = PageElement(xpath=TEXT_EDIT_XPATH) self.driver.text_edit_dialog.click()另外几种Locator Type 举例：123el = self.driver.find_element_by_id('ButtonsExplain')el = self.driver.find_element_by_name('TextFields, Uses of UITextField')el = self.driver.find_element_by_class_name('UIATextField') 利用UI AUTomationThis allows elements in iOS applications to be found using recursive element search using the UIAutomation library.Adds the methods driver.find_element_by_ios_uiautomation and driver.find_elements_by_ios_uiautomation.1234el = self.driver.find_element_by_ios_uiautomation('.elements()[0]')self.assertEqual('UICatalog', el.get_attribute('name'))els = self.driver.find_elements_by_ios_uiautomation('.elements()')self.assertIsInstance(els, list) 代码实现如下：123456789101112131415161718192021222324252627282930313233343536def find_elements_by_ios_uiautomation(self, uia_string): """Finds elements by uiautomation in iOS. :Args: - uia_string - The element name in the iOS UIAutomation library :Usage: driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]') """ return self.find_elements(by=By.IOS_UIAUTOMATION, value=uia_string) def find_element(self, by=By.ID, value=None): """ 'Private' method used by the find_element_by_* methods. :Usage: Use the corresponding find_element_by_* instead of this. :rtype: WebElement """ if not By.is_valid(by) or not isinstance(value, str): raise InvalidSelectorException("Invalid locator values passed in") if self.w3c: if by == By.ID: by = By.CSS_SELECTOR value = '[id="%s"]' % value elif by == By.TAG_NAME: by = By.CSS_SELECTOR elif by == By.CLASS_NAME: by = By.CSS_SELECTOR value = ".%s" % value elif by == By.NAME: by = By.CSS_SELECTOR value = '[name="%s"]' % value return self.execute(Command.FIND_ELEMENT, &#123;'using': by, 'value': value&#125;)['value']]]></content>
      <categories>
        <category>mobile-test</category>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Mobile-Test</tag>
        <tag>Appium</tag>
        <tag>自动化测试定位元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIAutomation Viewer定位Android APP元素]]></title>
    <url>%2F2017%2F04%2F02%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FUIAutomation%20Viewer%E5%AE%9A%E4%BD%8DAndroid%20APP%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[如何用UIAutomation Viewer定位Android APP元素We will use android calculator app to get element’s XPath in different ways. Supposing I need XPath of button 5. So i can write XPath in multiple ways for it as bellow.UI Automator Viewer screenshot for button 5 is as bellow. XPath using class and text attribute :In above image you can see that button 5 has text attribute with value = 5 which is unique. Class name is android.widget.Button which is same for all number buttons. So we can create XPath using text attribute value with class name as bellow. 1xpath("//android.widget.Button[@text='5']") XPath using class and resource-id :Here resource-id for button 5 is com.android.calculator2:id/digit5. Trailing part (e.g digit5, digit4, digit7) of resource-id is changing for every number buttons so we can use contains function to get relative XPath of button 5 as bellow. 1xpath("//android.widget.Button[contains(@resource-id,'digit5')]") XPath using class, text attribute and resource-id :We can use combination of text attribute and resource-id with class name to create unique XPath of element button 5 as bellow.1xpath("//android.widget.Button[contains(@resource-id,'digit5') and @text='5']") XPath using class, text attribute and index :We can use same approach as described in point 3 but with index number. Button 5 has index 1 but it is not unique as number buttons 0,2 and 8 has also same index with same class name. So we can include text attribute with indexattribute to locate number button 5.1xpath("//android.widget.Button[@text='5' and @index='1']") XPath using parent and child class hierarchyAs you can see in above image, Parent class android.widget.LinearLayout class with index = 1 has buttons 4, 5, 6 and X. So we can locate that specific row by it’s class index. Child element is member of class android.widget.Button withindex = 1. So we can format XPath using parent and child class hierarchy as bellow.1xpath("//android.widget.LinearLayout[@index='1']/android.widget.Button[@index='1']") XPath using content-desc Supposing element has content-desc which is unique then you can use it to create XPath. Example : DELETE button has unique content-desc = delete. So we can write XPath for delete button using it as bellow.1xpath("//android.widget.Button[@content-desc='delete']") XPath using class nameNote : Using class name In By.className or By.xpath will works only if it is unique for element. If same class name is provided to multiple elements then it will not work. If software application’s element has a class name and it is unique for element then you can use class name only to create XPath. See above image. Options button has class name android.widget.ImageButton which is unique. So we can use it only to create xpath as bellow.1xpath("//android.widget.ImageButton")Locating Android App Element By IDWe can locate elements by ID in android app too. We can use resource-id as a id. Example is as bellow.resource-id for button 5 is “com.android.calculator2:id/digit5” so we can locate to it by id as bellow.1id("com.android.calculator2:id/digit5")Locating Android App Element By classNameSame way, We can use class name to locate element if it is unique.Class name for above option button is “android.widget.ImageButton”. We can locate it using className as bellow.1By.className("android.widget.ImageButton")Locating Android App element by NameIt is possible to locate element by name if element contains unique text.If you see in above image, button Equals has text value “=”. So we can locate it by name using bellow given syntax.1By.name("=")Locating element by findElementsIf you inspect all buttons of android calculator app, All the buttons has same class “android.widget.Button”. If you know, findElements method is useful to get list of all the matching elements from current page as per given element locator mechanism. VIEW MORE DETAIL on findElements. So here we can collect list of all buttons using findElements and store list using javaList interface. Then we access required element using get() method of List interface.Array list Index IDs of button elements of “android.widget.Button” class is as bellow. List calcButtons = driver.findElements(By.xpath(“//android.widget.Button”));Above given syntax will store list of all buttons in list calcButtons with bellow given array list index ids. Bellow given table illustrate array index ids for different buttons of calculator application.]]></content>
      <categories>
        <category>mobile-test</category>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Mobile-Test</tag>
        <tag>Appium</tag>
        <tag>自动化测试定位元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Android UiSelector（）类来定位元素]]></title>
    <url>%2F2017%2F04%2F02%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2F%E5%88%A9%E7%94%A8Android%20UiSelector%EF%BC%88%EF%BC%89%E7%B1%BB%E6%9D%A5%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[在Android自动化测试过程中，有些元素难以定位，比如一个要定位一个元素的某一个子元素，这样上篇文章讲的方法有时候不那么适用，那么我们可以利用Andorid 自带的UiSelector 类来定位元素。123456789101112el = self.driver.find_element_by_android_uiautomator('new UiSelector().text("Animation")')els = self.driver.find_elements_by_android_uiautomator('new UiSelector().clickable(true)') el = self.driver.find_element_by_class_name('android.widget.ListView')sub_el = el.find_element_by_android_uiautomator('new UiSelector().description("Animation")')el = self.driver.find_element_by_class_name('android.widget.ListView')sub_el = el.find_element_by_android_uiautomator('new UiSelector().description("Animation")')el = self.driver.find_element_by_class_name('android.widget.ListView')sub_els = el.find_elements_by_android_uiautomator('new UiSelector().clickable(true)')UiSelector的具体方法如下：Public constructorsUiSelector() Public methodscheckable(boolean val)Set the search criteria to match widgets that are checkable. checked(boolean val)Set the search criteria to match widgets that are currently checked (usually for checkboxes). childSelector(UiSelector selector)Adds a child UiSelector criteria to this selector. className(String className)Set the search criteria to match the class property for a widget (for example, “android.widget.Button”). className(Class type)Set the search criteria to match the class property for a widget (for example, “android.widget.Button”). classNameMatches(String regex)Set the search criteria to match the class property for a widget, using a regular expression. clickable(boolean val)Set the search criteria to match widgets that are clickable. description(String desc)Set the search criteria to match the content-description property for a widget. descriptionContains(String desc)Set the search criteria to match the content-description property for a widget. descriptionMatches(String regex)Set the search criteria to match the content-description property for a widget. descriptionStartsWith(String desc)Set the search criteria to match the content-description property for a widget. enabled(boolean val)Set the search criteria to match widgets that are enabled. focusable(boolean val)Set the search criteria to match widgets that are focusable. focused(boolean val)Set the search criteria to match widgets that have focus. fromParent(UiSelector selector)Adds a child UiSelector criteria to this selector which is used to start search from the parent widget. index(int index)Set the search criteria to match the widget by its node index in the layout hierarchy. instance(int instance)Set the search criteria to match the widget by its instance number. longClickable(boolean val)Set the search criteria to match widgets that are long-clickable. packageName(String name)Set the search criteria to match the package name of the application that contains the widget. packageNameMatches(String regex)Set the search criteria to match the package name of the application that contains the widget. resourceId(String id)Set the search criteria to match the given resource ID. resourceIdMatches(String regex)Set the search criteria to match the resource ID of the widget, using a regular expression. scrollable(boolean val)Set the search criteria to match widgets that are scrollable. selected(boolean val)Set the search criteria to match widgets that are currently selected. text(String text)Set the search criteria to match the visible text displayed in a widget (for example, the text label to launch an app). textContains(String text)Set the search criteria to match the visible text in a widget where the visible text must contain the string in your input argument. textMatches(String regex)Set the search criteria to match the visible text displayed in a layout element, using a regular expression. textStartsWith(String text)Set the search criteria to match visible text in a widget that is prefixed by the text parameter.]]></content>
      <categories>
        <category>mobile-test</category>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Mobile-Test</tag>
        <tag>Appium</tag>
        <tag>自动化测试定位元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动APP自动化测试之元素定位]]></title>
    <url>%2F2017%2F04%2F02%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2F%E7%A7%BB%E5%8A%A8APP%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[在基于UI的移动APP自动化测试中，如何定位页面元素呢？对于iOS和Android，定位元素各有什么特殊技巧吗？本文为你揭晓。 通用方法之Appium之Inspector详细用法请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。iOS only 之 UIAutomation search-ios uiautomation: a string corresponding to a recursive element search using the UIAutomation library (iOS-only) Android only之UiAutomation API-android uiautomator: a string corresponding to a recursive element search using the UiAutomator Api(Android-only)详细用法请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。Android only 之UI Autoamtion Viewer详细用法请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。]]></content>
      <categories>
        <category>mobile-test</category>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Mobile-Test</tag>
        <tag>Appium</tag>
        <tag>自动化测试定位元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解RESTful]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E7%90%86%E8%A7%A3RESTful%2F</url>
    <content type="text"><![CDATA[在测试开发中，我们经常接触到API，在调用API时候特别是第三方API时候，我们常常陷入以下困惑：以一个文件获取为例，我们要获取，上传，删除文件，需要以下接口： api/getfile.php - 获取文件信息，下载文件api/uploadfile.php - 上传创建文件api/deletefile.php - 删除文件 我们必须很熟悉每一个接口的名称才能使用如果我需要调用一个修改文件的接口该怎么办呢？这个接口叫modifyfile吗还是别的名字？如果接口维护人员不能及时提供帮助，我们是不是就无法正确引用了？ 既然都是对文件的操作，我们能不能用一个接口表述对这个文件的所有操作呢？当然可以了，我们可以只用一个接口，但是用不同的http请求来表述不同的操作。：api/file 只需要这一个接口GET 方式请求 api/file - 获取文件信息，下载文件POST 方式请求 api/file - 上传创建文件DELETE 方式请求 api/file - 删除某个文件是不是方便了很多？那么，这个是什么风格的API呢？是怎么实现的呢？我们就要从头说起了。答案就是 RESTFUL。通常采用http+JSON实现。（对API的调用通常包含两个部分，序列化和通信协议。常见的序列化协议包括json、xml、hession、protobuf、thrift、text、bytes等；通信比较流行的是http、soap、websockect，RPC。通常基于TCP实现，常用框架例如netty。web开发中常用的是json-rpc。 RESTful是另外一种方法) 要理解RESTful，首先要理解REST.REST – REpresentational State Transfer， 全称是 Resource Representational State Transfer通俗来讲就是：资源在网络中以某种表现形式进行状态转移。REST是Web自身的架构风格。REST也是Web之所以取得成功的技术架构方面因素的总结。REST是世界上最成功的分布式应用架构风格（成功案例：Web，还不够吗？）。它是为 运行在互联网环境 的 分布式 超媒体系统量身定制的。互联网环境与企业内网环境有非常大的差别，最主要的差别是两个方面：可伸缩性需求无法控制：并发访问量可能会暴涨，也可能会暴跌。安全性需求无法控制：无法控制客户端发来的请求的格式，很可能会是恶意的请求。而所谓的“超媒体系统”，即，使用了超文本的系统。可以把“超媒体”理解为超文本+媒体内容。 REST是HTTP/1.1协议等Web规范的设计指导原则，HTTP/1.1协议正是为实现REST风格的架构而设计的。新的Web规范，其设计必须符合REST的要求，否则整个Web的体系架构会因为引入严重矛盾而崩溃。这句话不是危言耸听，做个类比，假如苏州市政府同意在市区著名园林的附近大型土木，建造大量具有后现代风格的摩天大楼，那么不久之后世界闻名的苏州园林美景将不复存在。 上述这些关于“REST是什么”的描述，可以总结为一句话：REST是所有Web应用都应该遵守的架构设计指导原则。当然，REST并不是法律，违反了REST的指导原则，仍然能够实现应用的功能。但是违反了REST的指导原则，会付出很多代价，特别是对于大流量的网站而言。要深入理解REST，需要理解REST的五个关键词：资源（Resource）资源的表述（Representation）状态转移（State Transfer）统一接口（Uniform Interface）超文本驱动（Hypertext Driven） 什么是资源？资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 什么是资源的表述？资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 什么是状态转移？状态转移（state transfer）与状态机中的状态迁移（state transition）的含义是不同的。状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 什么是统一接口？REST要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。以HTTP/1.1协议为例，HTTP/1.1协议定义了一个操作资源的统一接口，主要包括以下内容：7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONSHTTP头信息（可自定义）HTTP响应状态代码（可自定义）一套标准的内容协商机制一套标准的缓存机制一套标准的客户端身份认证机制REST还要求，对于资源执行的操作，其操作语义必须由HTTP消息体之前的部分完全表达，不能将操作语义封装在HTTP消息体内部。这样做是为了提高交互的可见性，以便于通信链的中间组件实现缓存、安全审计等等功能。 什么是超文本驱动？“超文本驱动”又名“将超媒体作为应用状态的引擎”（Hypermedia As The Engine Of Application State，来自Fielding博士论文中的一句话，缩写为HATEOAS）。将Web应用看作是一个由很多状态（应用状态）组成的有限状态机。资源之间通过超链接相互关联，超链接既代表资源之间的关系，也代表可执行的状态迁移。在超媒体之中不仅仅包含数据，还包含了状态迁移的语义。以超媒体作为引擎，驱动Web应用的状态迁移。通过超媒体暴露出服务器所提供的资源，服务器提供了哪些资源是在运行时通过解析超媒体发现的，而不是事先定义的。从面向服务的角度看，超媒体定义了服务器所提供服务的协议。客户端应该依赖的是超媒体的状态迁移语义，而不应该对于是否存在某个URI或URI的某种特殊构造方式作出假设。一切都有可能变化，只有超媒体的状态迁移语义能够长期保持稳定。 一旦读者理解了上述REST的五个关键词，就很容易理解REST风格的架构所具有的6个的主要特征：面向资源（Resource Oriented）可寻址（Addressability）连通性（Connectedness）无状态（Statelessness）统一接口（Uniform Interface）超文本驱动（Hypertext Driven） 这6个特征是REST架构设计优秀程度的判断标准。其中，面向资源是REST最明显的特征，即，REST架构设计是以资源抽象为核心展开的。可寻址说的是：每一个资源在Web之上都有自己的地址。连通性说的是：应该尽量避免设计孤立的资源，除了设计资源本身，还需要设计资源之间的关联关系，并且通过超链接将资源关联起来。无状态、统一接口是REST的两种架构约束，超文本驱动是REST的一个关键词，在前面都已经解释过，就不再赘述了。 那么什么是RESTful呢？如果一个架构符合REST原则，就称它为RESTful架构。 Server的API如何设计才满足RESTful要求?REST 是面向资源的，这个概念非常重要，而资源是通过 URI 进行暴露。一旦定义好了资源, 需要确定什么样的 actions 应用它们，这些 actions 怎么映射到你的 API 上。RESTful 原则提供了 HTTP methods 映射作为策略来处理 CRUD actions，如下：GET /tickets - 获取 tickets 列表GET /tickets/12 - 获取一个单独的 ticketPOST /tickets - 创建一个新的 ticketPUT /tickets/12 - 更新 ticket #12PATCH /tickets/12 - 部分更新 ticket #12DELETE /tickets/12 - 删除 ticket #12 REST 非常棒的是，利用现有的 HTTP 方法在单个的 /tickets 接入点上实现了显著的功能。没有什么方法命名约定需要去遵循，URL 结构是整洁干净的。 REST 太棒了! 下面的是一个反例：比如：左边是错误的设计，而右边是正确的GET /rest/api/getDogs –&gt; GET /rest/api/dogs 获取所有小狗狗 GET /rest/api/addDogs –&gt; POST /rest/api/dogs 添加一个小狗狗 GET /rest/api/editDogs/:dog_id –&gt; PUT /rest/api/dogs/:dog_id 修改一个小狗狗 GET /rest/api/deleteDogs/:dog_id –&gt; DELETE /rest/api/dogs/:dog_id 删除一个小狗狗左边的这种设计，很明显不符合REST风格，上面已经说了，URI 只负责准确无误的暴露资源，而 getDogs/addDogs…已经包含了对资源的操作，这是不对的。相反右边却满足了，它的操作是使用标准的HTTP动词来体现。总结起来就是：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。 本文是我看了大量REST资料，根据自己理解总结而成，文中大量引用，糅合了不同资料，对这些乐于分享的人表示感谢。对REST的理解，可能有不当之处，欢迎交流指正。 参考资料如下：https://www.zhihu.com/question/28557115http://www.infoq.com/cn/articles/understanding-restful-stylehttps://www.zhihu.com/question/28570307http://blog.csdn.net/douliw/article/details/52592188]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>Web-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议总结]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2FHTTP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[我们在测试中，经常与http协议， URL打交道，不时会修改URL的参数来达到不同的测试目的或者转到不同的页面，那么，你对HTTP协议了解多少呢？今天我们来总结下。简介：HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）的协议。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 主要特点: 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效.Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 支持B/S及C/S模式。 URIHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个URI来定位的.URI一般由三部组成：①访问资源的命名机制②存放资源的主机名③资源自身的名称，由路径表示，着重强调于资源。 URLURL全称是UniformResourceLocator, 中文叫统一资源定位符。是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。互联网上用URL来标识某一处资源的地址,主要用在各种WWW客户程序和服务器程序上.采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：①协议(或称为服务方式)②存有该资源的主机IP地址(有时也包括端口号)③主机资源的具体地址。如目录和文件名等 URNURN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:itesting@awsome.com。 三者关系URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL. URL的组成部分及其含义:以下面这个URL为例 http://www.itesting.com:8080/profile/index.aspx?id=5&amp;page=1#name一个完整的URL包括以下几部分：1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。2.域名部分：该URL的域名部分为“www.itesting.com”。一个URL中，也可以使用IP地址作为域名使用3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/profile/”5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.aspx”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“id=5&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 HTTP请求方法http请求由三部分组成，分别是：请求行、消息报头、请求正文请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本格式：Method Request-URI HTTP-Version CRLF Method表示请求方法； Request-URI是一个统一资源标识符； HTTP-Version表示请求的HTTP协议版本； CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF符）。举例：GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)。 HTTP请求方法（所有方法全为大写）有多种，各个方法的解释如下：GET 请求获取Request-URI所标识的资源POST 在Request-URI所标识的资源后附加新的数据HEAD 请求获取由Request-URI所标识的资源的响应消息报头PUT 请求服务器存储一个资源，并用Request-URI作为其标识DELETE 请求服务器删除Request-URI所标识的资源TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT 保留将来使用OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 常用的是GET， POST， PUT， DELETE那这四种方法除语义外有什么其他区别呢？首先介绍两个概念：安全性和幂等性。如果针对一个URL的方法不改变URL所指资源的状态，就称其为安全的，显然在这四种方法里，只有GET方法是安全的。幂等性，来源于数学上的术语，即对同一操作数的多次操作与一次操作效果是一样的操作符即称幂等操作符，比如取绝对值操作符。类比到网络操作中就是指一方法对同一URL的请求，多次和一次的效果是一致的，就称该方法是幂等的，显然除POST外其他三种方法都是幂等的，总结如下表：http方法 安全 幂等GET 是 是POST 否 否PUT 否 否DELETE 否 否另外在具体技术实现上，这四种方法也有一些区别，那么POST与GET有什么区别呢？ 使用目标不同：POST与GET都用于获取信息，但是GET方式仅仅是查询，并不对服务器上的内容产生任何作用结果；每次GET的内容都是相同的。POST则常用于发送一定的内容进行某些修改操作。 大小不同：由于不同的浏览器对URL的长度大小有一定的字符限制，因此由于GET方式放在URL的首部中，自然也跟着首先，但是具体的大小要依浏览器而定。POST方式则是把内容放在报文内容中，因此只要报文的内容没有限制，它的大小就没有限制。 安全性不同：GET是直接添加到URL后面的，直接就可以在URL中看到内容。而POST是放在报文内部的，用户无法直接看到。 HTTP报文常见属性chrome打开上面的link，按F12 URL, 即http访问的地址 request method, 报文的请求方式 status code, 状态码以及状态短语 Accept Encoding, 内容编码 Connection, 连接方式 Cookie, 添加的cookie内容 Host, 目标主机 User-Agent, 客户端浏览器的相关信息 Set-Cookie, 指定想要在Cookie中保存的内容 HTTP是无状态的，如何保存状态？由于http是一种无状态的协议，因此无论是客户端还是服务器都不记录http的相关信息。这样设计一方面减轻了服务器端的负载，另一方面减小了http请求的开销。 但是针对某些特殊的场景，需要时刻记录用户的相关信息，这该如何处理呢? cookie客户端第一次访问，服务器在http响应头中添加Set-Cookie信息，其值的格式通常是name = value的格式。浏览器收到响应后会根据头中的字段保存cookie，下一次访问时在请求头中附带cookie内容，供服务器根据cookie值进行后续处理。cookie的内容主要包括：名字，值，过期时间，路径和域。 cookie机制采用的是在客户端保持状态的方案。 与 cookie 相对的一个解决方案是 session:session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识- 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie（一般这个cookie的名字都是类似于SEEESIONID），这样浏览器下次发请求的时候，这个session id会被放置在请求头中，和cookie一起发送回来。服务器再通过内存中保存的session id跟cookie中保存的ssession id进行比较，并根据id在内存中找到之前创建的session对象，提供给请求使用，也就是服务器会通过session保存一个状态记录，浏览器会通过cookie保存状态记录，服务器通过两者的对比实现跟踪状态，这样的做，也极大的避免了cookie被篡改而带来的安全性问题。URL重写由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。附加方式：1.作为URL路径的附加信息，表现形式为：http://...../xxx;jsessionid=ByOK … 99zWpBng!-1457887642.作为查询字符串附加在URL后面，表现形式为：http://...../xxx?jsessionid=ByOK … 99zWpBng!-145788764 这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。 cookie和session的区别：1、cookie数据存放在客户的浏览器上，session数据放在服务器上。2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。5、所以个人建议：将登陆信息等重要信息存放为SESSION其他信息如果需要保留，可以放在COOKIE中 HTTP状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常见状态码：200 OK //客户端请求成功 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>Web-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python读取excel文件]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2Fpython%E8%AF%BB%E5%8F%96excel%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[自动化测试中，测试数据一般保存在Excel里，过程产生的数据一般保存在SQL里，上次我们讲里如何读SQL 数据库，今天我们来看下，如何使用Python操作Excel。Python操作Excel的library也有好多种，我们拿 Openpyxl为例子，它可以支持Excel2010： penpyxl is a Python library for reading and writing Excel 2010 xlsx/xlsm/xltx/xltm files 安装：1pip install openpyxl用法:1234567891011121314151617181920212223from openpyxl import load_workbook, Workbookif __name__ == "__main__": # Create a workbook named test and it contains two tabs uat &amp; qa file_name = r'c:\test.xlsx' wb = Workbook() wb.create_sheet('uat',1) wb.create_sheet('qa',1) wb.save(file_name) # Read &amp; write wb2 = load_workbook(r'c:\test.xlsx') # List all sheets print wb2.get_sheet_names() # Get target sheet s = wb2.get_sheet_by_name('qa') # Two ways to set value for specific column/row s.cell(row=2,column=1).value= 6 s['A2'] = 5 # Get value for specific column/row print s.cell(row=2,column=1).value print s['A2'].value以上创建了一个workbook，然后又读取这个workbook，并在指定的sheet里设置单元格的值并读出， 代码本身已经解释了一切，无需再特殊说明用法。这只是Python对Excel的简单实用，如果你有更深层的需求，可以参考官方网页：官网 通过一周两次发布，我们逐步快把测试用常用的方法技术都讲解完毕了，如果大家想要更深层次的了解某个方法，可以直接回复，我会抽取问题最多的来讲解。]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Web-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy连接数据库入门]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FSQLAlchemy%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[自动化测试中常常需要访问数据库来获得所需数据，Python里访问数据库的Library有很多，例如MySQL ，SQLite， SQLAlchemy 等，运用最广泛的当属SQLAlchemy， 我们今天就以SQLAlchemy为例，讲下如何连接，使用，更新数据库。 SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL.SQLAlchemy is most famous for its object-relational mapper (ORM), an optional component that provides the data mapper pattern, where classes can be mapped to the database in open ended, multiple ways - allowing the object model and database schema to develop in a cleanly decoupled way from the beginning. 如何安装：12 pip install SQLAlchemy如何使用：12345678910111213141516171819202122232425262728293031323334353637383940 from sqlalchemy import create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import Column, DateTime, String, Integer, text, and_from sqlalchemy.ext.declarative import declarative_base# 1base = declarative_base()class ClassAudit(base): __tablename__ = 'ClassAudit' Class_id = Column(Integer) StudentMember_id = Column(Integer) Comment = Column(String(100)) ...# 2 class DBHelper(object): def __init__(self): self.engine = create_engine("mssql+pymssql://用户名:密码@数据库ip/数据库名", encoding='latin1', echo=True) DBSession = sessionmaker(bind=self.engine) self.dbsession = DBSession() def query_status(self, class_id, message): query = self.dbsession.query(ClassAudit).filter(and_(ClassAudit.Class_id==class_id, ClassAudit.Comment.like('%'+ '%s' % message + '%' ))) return query.all()if __name__ == "__main__": db_helper = DBHelper() # Method 1 txt = db_helper.query_status('1501287', 'test') for i in txt: print i.Comment # Method 2 sql_string = """select * from teachers..classaudit where class_id='1501287' and comment like '%test%'""" conn = db_helper.engine.connect() txt = conn.execute(sql_string) for i in txt: print i.Comment根据上面的代码我们来逐步说明sqlalchemy的使用步骤： 连接数据库123 &gt;&gt;&gt; from sqlalchemy import create_engine&gt;&gt;&gt; engine = create_engine('sqlite:///:memory:', echo=True) create_engine()用来初始化数据库连接，语法如下：‘数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名’ 声明mapping关系参考上面代码的#1和#2之间的代码。 ClassAudit是数据库表名，这里我们用来来和数据库中真实存在的table对应。要对应的table可以是已经存在的，也可以是要新建立的，如果是新建立的，那么顺序执行下面的3步。否则略过。 创建一个数据库表格并插入数据#创建数据库12345678910111213141516171819 from sqlalchemy import Table, MetaData engine = create_engine('sqlite:///:memory:')metadata = MetaData() user = Table('user', metadata, Column('user_id', Integer, primary_key=True), Column('user_name', String(16), nullable=False), Column('email_address', String(60), key='email'), Column('password', String(20), nullable=False)) metadata.create_all(engine) #插入数据ins = user.insert().values(name='kevin', fullname='Kevin cai')conn = engine.connect()result = conn.execute(ins) 创建一个session123 DBSession = sessionmaker(bind=self.engine)self.dbsession = DBSession() 增加或者更新数据库对象当需要添加数据库记录时使用，也可以用第3步的方法来插入数据。12345 new_audit = ClassAudit(Class_id=1, =’123’,,,,)self.dbsession.add(ClassAudit)self.dbsession.commit()self.dbsession.close() 查询Query的关键字和函数用法如下：123456789 AND:from sqlalchemy import and_session.query.filter(and_(User.name == 'kevin', User.fullname == kevin cai'))LIKE:session.query.filter(User.name.like('%test'))all() :returns a list:query = session.query(User).filter(User.name.like('%ed')).order_by(User.id)query.all() 以上就是sqlalchemy对数据库的操作，这个通常在有很多表格并且这些表格有联系的情况下使用，如果你的代码里只需要查询独立的几个表格，你完全可以不建立表格的对应关系，直接使用sql语句，做法为删除掉上面#1和#2之间的代码，并且参考main函数中Method2的代码即可。 SQLAlchemy是ORM技术的典型代表，希望大家都学会如何使用（Object-Relational Mapping，把关系数据库的表结构映射到对象上)。]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Web-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebService自动化-浅谈WSDL调用]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FWebService%E8%87%AA%E5%8A%A8%E5%8C%96--%E6%B5%85%E8%B0%88WSDL%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在做自动化测试的过程中，有时候需要测试一个业务流程特定的部分， 这个特定部分可能是接口，它往往需要依赖前期产生的数据输出作为输入，这个时候，重新跑一遍前边流程来获得需要的数据显然不合理， 那么利用后端开发发布出来的web service来直接生成所需数据就显得尤为便捷，今天我们就来看如何利用suds调用web service。 Suds is a lightweight SOAP python client for consuming Web Services.The suds Client class provides a consolidated API for consuming web services. The object contains (2) sub-namespaces: serviceThe service namespace provides a proxy for the consumed service. This object is used to invoke operations (methods) provided by the service endpoint. factoryThe factory namespace provides a factory that may be used to create instances of objects and types defined in the WSDL. suds Client 是作为一个API来消费提供的web services， 它有两个子命名空间： Service ：对象用来调用被消费的web service提供的方法。 Factory：提供一个工厂用来生成一个定义在WSDL的对象或方法的实例。 简单来说就是service用来直接调用web service里的方法，factory用来生成一个web service对象实例。 我们用一段代码来说明：1234567891011121314151617181920212223242526from suds.client import Clientclass WebServices(object): WSDL_ADDRESS = "http://*/services/*/StudentPrivateLessonService.svc?wsdl" def __init__(self): self.web_service = Client(self.WSDL_ADDRESS) print self.web_service def is_class_booked(self, class_id, member_id): return self.web_service.service.IsClassBooked(class_id, member_id)["ClassBooked"] def cancel_clas(self, class_id, member_id): parameter = self.web_service.factory.create("CancelClass") print parameter print dir(parameter) parameter.param.Class_id = class_id parameter.param.Member_id = member_id parameter.param.CancelBy = 'T' parameter.param.CancelReason = 'test' return self.web_service.service.CancelClass(parameter.param)if __name__ == '__main__': web_service_class = WebServices() print web_service_class.is_class_booked('315983', '23540202') print web_service_class.cancel_clas('315983', '23540202')以上代码里： WSDL_ADRESS：是我们提供的web service的地址。 init方法： 实现了suds client的生成， client的用法如下：123from suds.client import Clienturl = 'http://*.?wsdl'client = Client(url) is_class_booked 方法：使用了client的service这个命名空间，即直接调用web service 的可用方法。那么如何知道哪个方法如何调用呢？ 参考代码里init方法的print语句，打印出来了所有可用的方法和类型， print的打印结果片段如下：123456789101112131415161718192021Suds ( https://fedorahosted.org/suds/ ) version: 0.4 GA build: R699-20100913Service ( StudentPrivateLessonService ) tns=&quot;http://tempuri.org/&quot; Prefixes (9) ns0 = &quot;EFSchools.Englishtown.TeacherTools.Client.ServiceParams&quot; ns1 = &quot;EFSchools.Englishtown.TeacherTools.Client.ServiceParams.StudentPrivateLesson&quot; --- ns8 = &quot;http://tempuri.org/&quot; Ports (1): (BasicHttpBinding_IStudentPrivateLessonService) Methods (18): --- ** CancelClass(ns1:CancelParameter param, ) --- ** IsClassBooked(xs:int class_id, xs:int member_id, ) --- Types (47): ns4:ArrayOfBatchCancelDetail ns4:ArrayOfBookablePLClass ns4:ArrayOfBookedPLClass ---从打印结果可以看出，IsClassBooked方法可以直接调用，它需要2个参数，类型为int型。 Cancel_class方法：利用了 client的factory这个命名空间。1parameter = self.web_service.factory.create("CancelClass") 创建了Cancel Class这个方法的一个实例，然后通过 print parameter，可以看出这个函数的参数组成：它是一个字典，字典的param的值又是一个字典，故我们要调用这个方法时下需要用Parameter.param.Class_id 这样的方式来引用。 下图是整段代码的运行结果：证明成功，我们再去DB里查下结果：可以看出，有一条新的记录添加出来。 以上，只要给出WSDL的地址，导入suds，通过Client， service， factory这3个类就可以实现web services的自动化调用，是不是很简单？]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Web-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie 基本知识]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2FCookie%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Cookie是当前识别用户，实现持久会话的最好方式。Cookie最初是由网景公司开发，但是现在所有的主要浏览器都支持它。 Cookie的类型：会话Cookie和持久Cookie 会话Cookie是一种临时Cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话Cookie就被删除了。 持久Cookie生存的时间相对较长，他们存储在硬盘上，浏览器退出，计算机重启它们仍然存在。通常会用持久Cookie维护用户会周期性访问的站点的配置文件或登录名。 会话Cookie和持久Cookie的唯一区别就是他们的过期时间。如果设置了Discard参数，或者没有设置Expires或Max-Age参数来说明扩展的过期时间，这个Cookie就是一个会话Cookie。想做持久Cookie—–一定要设置Expires或Max-Age参数。 下面总结记录一些关于http的cookie的知识： cookie的属性一般cookie所具有的属性，包括： Domain：域，表示当前cookie所属于哪个域或子域下面。对于服务器返回的Set-Cookie中，如果没有指定Domain的值，那么其Domain的值是默认为当前所提交的http的请求所对应的主域名的。比如访问 http://www.example.com，返回一个cookie，没有指名domain值，那么其为值为默认的www.example.com。 Path：表示cookie的所属路径。 Expire time / Max-age：表示了cookie的有效期。 expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了。 secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输。 httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的。 关于把cookie从从服务器发送给客户端从服务器端，发送cookie给客户端，是对应的Set-Cookie。包括了对应的cookie的名称，值，以及各个属性。例如：123Set-Cookie: lu=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Jan 2013 21:47:38 GMT; Path=/; Domain=.foo.com; HttpOnlySet-Cookie: made_write_conn=1295214458; Path=/; Domain=.foo.comSet-Cookie: reg_fb_gate=deleted; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Path=/; Domain=.foo.com; HttpOnly 关于把cookie从客户端发送到服务器从客户端发送cookie给服务器的时候，是不发送cookie的各个属性的，而只是发送对应的名称和值。例如：1234GET /spec.html HTTP/1.1Host: www.example.orgCookie: name=value; name2=value2Accept: */* 关于修改，设置cookie除了服务器发送给客户端（浏览器）的时候，通过Set-Cookie，创建或更新对应的cookie之外，还可以通过浏览器内置的一些脚本，比如javascript，去设置对应的cookie，对应实现是操作js中的document.cookie。]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>Web-Test</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用cookie实现自动登录]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2F%E5%88%A9%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在使用Webdriver 自动化测试过程中，譬如，一个网页系统，如果我想测试登录成功后的一个具体页面，比如 学生可以参加的课程的页面，那么一般流程是： 用户登录（UI登录，可以新写脚本，也可以利用已存在的脚本）。 登录成功后跳转到目标页面，验证目标页面是否正确。 开始具体的测试执行。这样就有一个问题，无论测试什么功能step 1 都会被重复执行，我的目标页面必须借助 Step 1才能达到。 假如目标页面UI没有改变，但是Login界面的UI改变了，那么我的脚本会执行失败， 有没有办法去掉无关页面的干扰直接测试目标页面呢？当然有，我们可以利用cookie达到。原理很简单，就是利用服务器返回的登录成功的用户cookie，把它写入到当前的driver中，从而实现不依赖Login UI的目的。 具体做法如下： 利用Requests 直接发送请求给登录的API， 这里以*.englishtown.com/login/handler.ashx 为例，成功登录后拿到server 返回的cookie。 把cookie写入到webdriver的driver， 然后利用driver.get(url)跳转到目标页面。 关于Requests的用法，请查看官方文档。 核心代码如下（Python）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import datetimeimport requestsfrom selenium import webdriverimport settingsclass LoginAPI(object): def __init__(self): self.s = requests.session() def cookie_to_selenium_format(self, cookie): cookie_selenium_mapping = &#123;'path':'', 'secure':'', 'name':'', 'value':'','expires':''&#125; cookie_dict = &#123;&#125; if getattr(cookie, 'domain_initial_dot'): cookie_dict['domain'] = '.' + getattr(cookie, 'domain') else: cookie_dict['domain'] = getattr(cookie, 'domain') for k in cookie_selenium_mapping.keys(): key = k value = getattr(cookie, k) cookie_dict[key] = value return cookie_dict def page_login(self, driver, target_url, account_dict): login_url = settings.COOKIE_LOGIN_URL login_start_time = datetime.datetime.now() try: login_status = self.s.post(login_url, account_dict) login_end_time = datetime.datetime.now() login_duration = login_end_time - login_start_time except requests.exceptions.Timeout: print "Time out" except requests.exceptions.TooManyRedirects: print "Too many redirects" except requests.exceptions.ConnectionError: print "Connection error" login_status = self.s.post(login_url, account_dict) login_end_time = datetime.datetime.now() login_duration = login_end_time - login_start_time except Exception, e: print e if int(login_status.status_code) == 200: all_cookies = tuple(self.s.cookies) driver.get(target_url) driver.delete_all_cookies() for i in range(len(all_cookies)): driver.add_cookie(self.cookie_to_selenium_format(all_cookies[i])) driver.get(target_url) else: raise ValueError, "Response code not equal to 200, log in failed!,\ status code is &#123;&#125;, duration time is &#123;&#125; ".format(login_status.status_code, login_duration)if __name__ == "__main__": login = LoginAPI() target_url = settings.MY_BOOKINGS_PAGE_URL account_dict = settings.Account.B2B_Account driver = webdriver.Chrome() login.page_login(driver, target_url, account_dict)]]></content>
      <categories>
        <category>automation</category>
      </categories>
      <tags>
        <tag>automation</tag>
        <tag>Web-Test</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何模拟不同网络环境及设置丢包率？]]></title>
    <url>%2F2017%2F04%2F02%2F%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97%2F%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%AE%BE%E7%BD%AE%E4%B8%A2%E5%8C%85%E7%8E%87%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们的产品近期收到关于网络情况的很多反馈，学生在上课过程中和老师的视频，音频有时候会不那么流畅，这个时候我们需要知道导致网络问题的原因是什么,于是开发了一个新的功能来显示当前网络的联通情况，这种情况下，就需要我们测试不同的网络连接质量下产品的稳定度，显然我们需要模拟不同的网络情况，那么有没有好用的工具呢？我们开始使用chrome浏览器自带的throtting，不过它只能模拟不同的网络情况无法设置丢包率等。经过搜索，发现了NetWork Enulator Client, 它是一款简单易用的工具，可以模拟不同的网络情况包括丢包率等等。 使用如下： 安装好后打开，新建一个channel： Channel建立好后，还在configuration选项里，选择new Filter, 在弹出的选项里，选择你要的网卡，我们这里全选。 新建立一个Link，Configuration-&gt;New Link,然后在新建立的link上，点击右键，设置incoming/outcoming的丢包率。设置好后保存，点击开始按钮，就可以了。说明：No Loss：默认，不模拟丢包Periodic loss: 模拟周期性的丢包。按填写数量(设为x个)，每x个包，就丢一个包(one packet is dropped per given number of packets)。Random loss: 模拟随机丢包，按给定丢包的概率，随机丢包。Burst loss: 模拟根据给定的可能性进行丢包。当发生一个丢包事件时，接着连续丢几个包（丢包数量控制在最大(max)最小值(min)之间）。G-E loss: 模拟发生数据包丢失遵循Gilbert-Elliot模型，由两个状态组成：好的状态和坏的状态。可分别为这2个状态指定数据包丢失率,同时可设置网络传输在这两种状态的概率（And the network transit between the two states is at given transition probabilities） PS： 进入到cmd， ping自己的网关地址，就可以观察自己的设置是否起效。]]></content>
      <categories>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>Web-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 多进程]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPython%20%E5%A4%9A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python 多进程 前面我们讲了multiple thread的用法， 在Python中，由于GIL（Global Interpreter Lock）的存在（ GIL將会防止多个原生线程同时执行Python字节码。换句话说,GIL將序列化您的所有线程，也就是说，多线程等于时分复用，一个时刻只有一个线程运行），多线程就最多只能用满1个CPU核心，无法真正利用多核的优势。 Python提供了非常好用的多进程包multiprocessing，mutilprocess像线程一样管理进程，这个是mutilprocess的核心，他与threading很是相像，对多核CPU的利用率会比threading好的多。 多进程用法如下： Process1234567891011import multiprocessingimport timedef func(msg): for i in range(3): print msg time.sleep(1)if __name__ == "__main__": p = multiprocessing.Process(target=func, args=("hello", )) p.start() p.join() print "Sub-process done." 生产者消费者多进程模型Queue1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import multiprocessingfrom multiprocessing import Queueimport randomimport timeque = Queue()class ProduceMethod(multiprocessing.Process): def __init__(self, name, que): multiprocessing.Process.__init__(self) self.data = que self.name = "Process%s" %name def run(self): while True: if self.data.qsize() &lt; 2: self.do_produce(self.name) time.sleep(10) else: print "queue is %s, stop produce"%self.data.qsize() time.sleep(1) def do_produce(self, name): print "Before produce, the queue size is %s"%self.data.qsize() product = random.randint(0, 10) self.data.put(product) print "%s produce product -- %s, after produce, queue is %s now"%(name, product,self.data.qsize())class ConsumeMethodEven(multiprocessing.Process): def __init__(self, name, que): multiprocessing.Process.__init__(self) self.data = que self.name = "Thread %s" %name def run(self): while True: if self.data.qsize()&gt;0: self.do_consume(self.name) time.sleep(5) else: print "queue is %s, stop consume"%self.data.qsize() time.sleep(5) def do_consume(self, name): print"before consume,the quque size is %s"%self.data.qsize() product = self.data.get() if product %2 ==0: print"%s consume product -- %s, after consume, queue is %s now"%(name, product, self.data.qsize())if __name__ == "__main__": for i in range(2): p1 = ProduceMethod(i, que) p1.start() c1 = ConsumeMethodEven(1, que) c1.start() 由代码可以看出，多进程的方法名和函数名跟多线程基本一模一样，这样就方便了我们开发者（当然内部实现由很多不同），这也是Python容易上手的的一个作证吧。 Pool123456789101112131415161718192021222324252627import multiprocessingimport timeimport osdef func(msg): print " Sub-process(es) %s said %s."%(os.getpid(), msg) time.sleep(1)if __name__ == "__main__": pool = multiprocessing.Pool(processes=4) print "parent id is %s"%os.getpid() for i in range(10): msg = "hello %d" %(i) #注意要用apply_async，如果用apply，就变成阻塞版本了。 pool.apply_async(func, (msg, )) pool.close() pool.join()看一下运行结果：parent id is 8804 Sub-process(es) 10948 said hello 0. Sub-process(es) 428 said hello 1. Sub-process(es) 8592 said hello 2. Sub-process(es) 16112 said hello 3. Sub-process(es) 10948 said hello 4. Sub-process(es) 428 said hello 5. Sub-process(es) 8592 said hello 6. Sub-process(es) 16112 said hello 7. Sub-process(es) 8592 said hello 8. Sub-process(es) 428 said hello 9. 在运行中，你会看到打印出来的记录是4个一批，打印好4个马上打印下一个4个，那是因为我们设置了processes=4是最多并发进程数量。 何时用多进程：对于计算密集型程序，多进程并发优于多线程并发。计算密集型程序指的程序的运行时间大部分消耗在CPU的运算处理过程，而硬盘和内存的读写消耗的时间很短；相对地，IO密集型程序指的则是程序的运行时间大部分消耗在硬盘和内存的读写上，CPU的运算时间很短。]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python多线程系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Queue详解]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPython%20Queue%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[上次我们讲了多线程的condition来实现 生产者消费者模式，今天我们介绍下另外一个方法， Queue, 它是线程安全的，天生利于实现多生产者多消费者模型。 Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。 我们先来看一个多生产者多消费者的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import threadingimport Queueimport randomimport timecon = threading.Condition()que = Queue.Queue()class ProduceMethod(threading.Thread): def __init__(self, name, que): threading.Thread.__init__(self) self.data = que self.name = "Thread%s" %name def run(self): while True: if self.data.qsize() &lt; 2: self.do_produce(self.name) time.sleep(10) else: print "queue is %s, stop produce"%self.data.qsize() time.sleep(1) def do_produce(self, name): print "Before produce, the queue size is %s"%self.data.qsize() product = random.randint(0, 10) self.data.put(product) print "%s produce product -- %s, after produce, queue is %s now"%(name, product,self.data.qsize())class ConsumeMethodEven(threading.Thread): def __init__(self, name, que): threading.Thread.__init__(self) self.data = que self.name = "Thread %s" %name def run(self): while True: if self.data.qsize()&gt;0: self.do_consume(self.name) self.data.task_done() time.sleep(5) else: print "queue is %s, stop consume"%self.data.qsize() time.sleep(5) def do_consume(self, name): print"before consume,the quque size is %s"%self.data.qsize() product = self.data.get() if product %2 ==0: print"%s consume product -- %s, after consume, queue is %s now"%(name, product, self.data.qsize())if __name__ == "__main__": for i in range(2): p1 = ProduceMethod(i, que) p1.start() c1 = ConsumeMethodEven(1, que) c1.start()运行结果如下：Before produce, the queue size is 0Thread0 produce product -- 4, after produce, queue is 1 nowBefore produce, the queue size is 1Thread1 produce product -- 10, after produce, queue is 2 nowbefore consume,the quque size is 2Thread 1 consume product -- 4, after consume, queue is 1 nowbefore consume,the quque size is 1Thread 1 consume product -- 10, after consume, queue is 0 nowBefore produce, the queue size is 0......可以看到我们完全不需要自己加锁实现线程同步，Queue的get， 和put操作，自带锁，使用的时候，不用对队列加锁操作。 是不是很方便，再来看下Queue的一些用法：Queue.qsize() 返回队列的大小Queue.empty() 如果队列为空，返回True,反之FalseQueue.full() 如果队列满了，返回True,反之False。Queue.full 与 maxsize 大小对应Queue.put(item[, block[, timeout]]) ：写入队列，timeout等待时间，如果可选的参数block为True且timeout为空对象（默认的情况，阻塞调用，无超时）。如果timeout是个正整数，阻塞调用进程最多timeout秒，如果一直无空空间可用，抛出Full异常（带超时的阻塞调用）。如果block为False，如果有空闲空间可用将数据放入队列，否则立即抛出Full异常Queue.put_nowait(item) 相当Queue.put(item, False)Queue.get([block[, timeout]])从队列中移除并返回一个数据。block跟timeout参数同put方法Queue.get_nowait() 相当Queue.get(False)Queue.task_done()：意味着之前入队的一个任务已经完成。由队列的消费者线程调用。每一个get()调用得到一个任务，接下来的task_done()调用告诉队列该任务已经处理完毕。如果当前一个join()正在阻塞，它将在队列中的所有任务都处理完时恢复执行（即每一个由put()调用入队的任务都有一个对应的task_done()调用）join()。Queue.join()：阻塞调用线程，直到队列中的所有任务被处理掉。只要有数据被加入队列，未完成的任务数就会增加。当消费者线程调用task_done()（意味着有消费者取得任务并完成任务），未完成的任务数就会减少。当未完成的任务数降到0，join()解除阻塞。实际上意味着等到队列为空，再执行别的操作。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python多线程系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程系列 -- Condition]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20Condition%2F</url>
    <content type="text"><![CDATA[Python多线程系列 – Condition 经过前几次的学习，我们已经明白了多线程的大致用法，我们也可以用lock， rlock 来控制简单的线程同步，那么稍微复杂点的线程同步，比如我需要等到一定条件触发的情况下才处理数据，该怎么办呢？ 下面我们以经典的消费者，生产者模型， 来讲解下threading.condition的用法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970product = None#Conditioncon = threading.Condition()#Produce methodclass ProduceMethod(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global product if con.acquire(): while True: if product is None: print "Produce....." self.do_produce() print "Now we have %s products" %product #Notify consumer, product is generated con.notify() #Wait notify con.wait() time.sleep(2) def do_produce(self): global product product = 0 while (product &lt;10): product +=1 print product class ConsumeMethod(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global product if con.acquire(): while True: if product is not None: print "Consume...." self.do_consume() #Notify produceser, no product con.notify() #wait notify con.wait() time.sleep(2) def do_consume(self): global product while product&gt;0: print product product -= 1 if product == 0: product = Noneif __name__ == "__main__": t1 = ProduceMethod() t2 = ConsumeMethod() t1.start() t2.start()运行结果可以看到，程序在不停的生产，消费。Produce.....1.........10Now we have 10 productsConsume....10...1Produce.....（继续循环）Condition对象可以在某些事件触发或者达到特定条件后才处理数据，可以把Condiftion理解为一把高级的琐，它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题。 threadiong.Condition在内部维护一个琐对象（默认是RLock），可以在创建Condition对象的时候把琐对象作为参数传入。Condition也提供了acquire, release方法，其含义与Lock的acquire, release方法一致，其实它只是简单的调用内部琐对象的对应的方法而已。Condition还提供了如下方法(特别要注意：这些方法只有在占用Lock(acquire)之后才能调用，否则将会报RuntimeError异常。)： Condition.wait([timeout]):wait方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。 Condition.notify():唤醒一个挂起的线程（如果存在挂起的线程）。注意：notify()方法不会释放所占用的琐。 Condition.notify_all()Condition.notifyAll()唤醒所有挂起的线程（如果存在挂起的线程）。注意：这些方法不会释放所占用的琐。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python多线程系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程系列 -- Lock和RLock]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20Lock%E5%92%8CRLock%2F</url>
    <content type="text"><![CDATA[Lock和RLock 先来说下Lock的作用：用来确保多线程多共享资源的访问。 下面直接看代码， 如果你不用lock：12345678910111213141516171819202122232425262728293031x = 0class ThreadExample_2(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global x time.sleep(1) x +=1 print '%s get the lock, number is %s' \ % (threading.currentThread().getName(), x) if __name__ == "__main__": lock = threading.Lock() for i in range(5): t = ThreadExample_2() t.start()运行结果如下：Thread-1 get the lock, number is 1Thread-5 get the lock, number is 2Thread-4 get the lock, number is 3Thread-3 get the lock, number is 4Thread-2 get the lock, number is 5再次运行一遍，结果如下：Thread-1 get the lock, number is 1Thread-2 get the lock, number is 2Thread-5 get the lock, number is 3Thread-4 get the lock, number is 4Thread-3 get the lock, number is 5两次运行的结果不一样，你肯定不想你的程序随机输出吧？用下lock看看：12345678910111213141516171819202122232425262728293031323334353637x = 0class ThreadExample_2(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global x if lock.acquire(): print '%s get the lock.' % threading.currentThread().getName() x +=1 print x time.sleep(3) print '%s release lock...' \ % threading.currentThread().getName() lock.release() if __name__ == "__main__": lock = threading.Lock() for i in range(5): t = ThreadExample_2() t.start()无论运行几次，都是一个结果：Thread-1 get the lock.1Thread-1 release lock...Thread-2 get the lock.2Thread-2 release lock...Thread-3 get the lock.3Thread-3 release lock...Thread-4 get the lock.4Thread-4 release lock...Thread-5 get the lock.5Thread-5 release lock...解释：Lock对象的状态可以为locked和unlocked使用acquire()设置为locked状态；使用release()设置为unlocked状态。如果当前的状态为unlocked，则acquire()会将状态改为locked然后立即返回。当状态为locked的时候，acquire()将被阻塞直到另一个线程中调用release()来将状态改为unlocked，然后acquire()才可以再次将状态置为locked。 Lock.acquire(blocking=True, timeout=-1),blocking参数表示是否阻塞当前线程等待，timeout表示阻塞时的等待时间 。如果成功地获得lock，则acquire()函数返回True，否则返回False，timeout超时时如果还没有获得lock仍然返回False。 那么Rlock呢？RLock与Lock的区别是：RLock中除了状态locked和unlocked外还记录了当前lock的owner和递归层数，使得RLock可以被同一个线程多次acquire()。 还是来看代码：12345678910111213141516171819lock = threading.Lock() #Lock对象lock.acquire()lock.acquire() #产生了死琐lock.release()lock.release()运行下就看到程序死锁了，永远不会结束。再来看Rlock：lock = threading.RLock() #可以重复locklock.acquire()lock.acquire() lock.release()lock.release()print "done without problem"输出结果“done without problem” 正常。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python多线程系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程 -- Join]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B%20--%20Join%2F</url>
    <content type="text"><![CDATA[Python多线程 – Join join([timeout])Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates – either normally or through an unhandled exception – or until the optional timeout occurs. join方法，阻塞进程直到线程执行完毕。如果一个线程或者一个函数在执行过程中要调用另外一个线程，并且待到其完成以后才能接着执行，那么在调用这个线程时可以使用被调用线程的join方法。 下面通过一段代码来说明join是如何工作的：1234567891011121314151617class ThreadExample_1(object): def func(self,t): print '%s--First method of thread -- start' %t t.start() t.join() print 'First method of thread -- end'class ThreadExample_2(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): time.sleep(2) print 'second method of thread'if __name__ == "__main__": t2 = ThreadExample_2() t1 = threading.Thread(target=ThreadExample_1().func, args=(t2,)) t1.start()我们创建了2个子线程，一个t2， 一个t1，其中t1继承自ThreadExample_1,args为t2. 那么先来看下输出：123&lt;ThreadExample_2(Thread-1, initial)&gt;, First method of thread -- startsecond method of threadFirst method of thread -- end可以看到， ThreadExample_2的一个实例即t2作为参数传入了主线程的func函数，在第一个print语句输出后，由start()调起了run()并成功进入join阻塞状态，接着，第二个print语句卡在哪里直到t2这个子线程执行完毕才打印出来。 为了进一步说明join的作用我们更改代码如下：123456789101112131415161718class ThreadExample_1(object): def func(self,t): print '%s, First method of thread -- start'%t t.start() t.join(1) print 'First method of thread -- end'class ThreadExample_2(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): time.sleep(2) print 'second method of thread't2 = ThreadExample_2()if __name__ == "__main__": t2 = ThreadExample_2() t1 = threading.Thread(target=ThreadExample_1().func, args=(t2,)) t1.start()我们给join一个timeout时间1秒钟， 再来看下运行结果：123&lt;ThreadExample_2(Thread-1, initial)&gt;, First method of thread -- startFirst method of thread -- endsecond method of thread可以看到由于join设置了timeout，导致子线程t2没有完成就被退出运行状态，所以主线程的第二个print语句先于t2的print打印出来。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python多线程系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Python中的with语句]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2F%E6%B5%85%E8%B0%88Python%E4%B8%AD%E7%9A%84with%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[浅谈Python中的with语句 ** with 语句作为 try/finally 编码范式的一种替代，用于对资源访问进行控制的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。 ** 术语要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。下面是一组与上下文管理器和with 语句有关的概念。上下文管理协议（Context Management Protocol）： 包含方法 enter()和 exit()，支持该协议的对象要实现这两个方法。上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了enter()和exit() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 enter() 和exit() 方法实现，enter() 方法在语句体执行之前进入运行时上下文，exit() 在 语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的enter() 方法，执行完语句体之后会执行 exit() 方法。 ** 基本语法和工作原理with 语句的语法格式如下： 清单 1. with 语句的语法格式with context_expression [as target(s)]: with-body这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 enter() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码： 清单 2. 使用 with 语句操作文件对象1234with open(r'somefileName') as somefile: for line in somefile: print line # ...more code这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码： 清单 3. try/finally 方式操作文件对象1234567somefile = open(r'somefileName')try: for line in somefile: print line # ...more codefinally: somefile.close()比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。with 语句的执行过程类似如下代码块： 清单 4. with 语句执行过程123456789101112131415161718192021context_manager = context_expressionexit = type(context_manager).__exit__ value = type(context_manager).__enter__(context_manager)exc = True # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理try: try: target = value # 如果使用了 as 子句 with-body # 执行 with-body except: # 执行过程中有异常发生 exc = False # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常 # 由外层代码对异常进行处理 if not exit(context_manager, *sys.exc_info()): raisefinally: # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出 # 或者忽略异常退出 if exc: exit(context_manager, None, None, None) # 缺省返回 None，None 在布尔上下文中看做是 False 执行 contextexpression，生成上下文管理器 contextmanager调用上下文管理器的enter() 方法；如果使用了 as 子句，则将 enter() 方法的返回值赋值给 as 子句中的 target(s)执行语句体 with-body,不管是否执行过程中是否发生了异常，执行上下文管理器的 exit() 方法，exit() 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 exit(None, None, None) ；如果执行过程中出现异常，则使用 sys.excinfo 得到的异常信息为参数调用 exit(exctype, excvalue, exctraceback)出现异常时，如果exit(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理 * 自定义上下文管理器开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的enter() 和exit() 两个方法： contextmanager.enter_() ：进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话*contextmanager.exit(exctype, excvalue, exctraceback) ：退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常，返回True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由 statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为 False 就可以了。之后，上下文管理代码会检测是否exit() 失败来处理异常下面通过一个简单的示例来演示如何构建自定义的上下文管理器。注意，上下文管理器必须同时提供enter() 和exit() 方法的定义，缺少任何一个都会导致 AttributeError；with 语句会先检查是否提供了exit() 方法，然后检查是否定义了enter() 方法。假设有一个资源 DummyResource，这种资源需要在访问前先分配，使用完后再释放掉；分配操作可以放到enter() 方法中，释放操作可以放到exit() 方法中。简单起见，这里只通过打印语句来表明当前的操作，并没有实际的资源分配与释放。 清单 5. 自定义支持 with 语句的对象1234567891011121314class DummyResource:def __init__(self, tag): self.tag = tag print 'Resource [%s]' % tag def __enter__(self): print '[Enter %s]: Allocate resource.' % self.tag return self # 可以返回不同的对象 def __exit__(self, exc_type, exc_value, exc_tb): print '[Exit %s]: Free resource.' % self.tag if exc_tb is None: print '[Exit %s]: Exited without exception.' % self.tag else: print '[Exit %s]: Exited with exception raised.' % self.tag return False # 可以省略，缺省的None也是被看做是Fals DummyResource 中的enter() 返回的是自身的引用，这个引用可以赋值给 as 子句中的 target 变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。exit() 方法中对变量 exc_tb 进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生exit() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。下面在 with 语句中访问 DummyResource ： 清单 6. 使用自定义的支持 with 语句的对象123456789101112131415161718192021222324252627with DummyResource('Normal'): print '[with-body] Run without exceptions.'with DummyResource('With-Exception'): print '[with-body] Run with exception.' raise Exception print '[with-body] Run with exception. Failed to finish statement-body!'第1个 with 语句的执行结果如下：清单 7. with 语句1执行结果Resource [Normal][Enter Normal]: Allocate resource.[with-body] Run without exceptions.[Exit Normal]: Free resource.[Exit Normal]: Exited without exception.可以看到，正常执行时会先执行完语句体 with-body，然后执行__exit__() 方法释放资源。第2个 with 语句的执行结果如下：清单 8. with 语句2执行结果Resource [With-Exception][Enter With-Exception]: Allocate resource.[with-body] Run with exception.[Exit With-Exception]: Free resource.[Exit With-Exception]: Exited with exception raised.Traceback (most recent call last): File "G:/demo", line 20, in &lt;module&gt; raise ExceptionException可以看到，with-body 中发生异常时with-body 并没有执行完，但资源会保证被释放掉，同时产生的异常由 with 语句之外的代码逻辑来捕获处理。可以自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。Python 在线文档 Writing Context Managers 提供了一个针对数据库连接进行管理的上下文管理器的简单范例。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多线程系列 -- 线程创建方式]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2Fpython%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[自动化项目中用到到多线程，温故知新之余，我决定花点时间详细讲下Python的多线程模块threading应用。 今天先讲如何创建线程：threading模块是在thread之上进行了封装，也是推荐使用的多线程模块，在某些版本中thread模块可能不存在，要使用dump_threading来代替threading模块。 线程创建的两种方式： Thisclass represents an activity that is run in a separate thread of control. Thereare two ways to specify the activity: by passing a callable object to theconstructor, or by overriding the run() method in a subclass. Noother methods (except for the constructor) should be overridden in a subclass.In other words, only override the init()and run() methods of this class. Once a thread object iscreated, its activity must be started by calling the thread’s start() method. This invokes the run() method in a separatethread of control. 直接用代码来区分吧12345678910111213141516171819202122#encoding: UTF-8import threadingimport timeclass ThreadExample_1(object): def func(self): print 'First method of thread'#方法1：将要执行的方法作为参数传给Thread的构造方法t1 = threading.Thread(target=ThreadExample_1().func)t1.start()#方法2：从Thread继承，并重写run()class ThreadExample_2(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): print 'second method of thread't2 = ThreadExample_2()t2.start()]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python多线程系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用wxpython开发类“记事本”软件]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2F%E5%88%A9%E7%94%A8wxpython%E5%BC%80%E5%8F%91%E7%B1%BB%E2%80%9C%E8%AE%B0%E4%BA%8B%E6%9C%AC%E2%80%9D%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在学习编程的过程中，你总会忍不住想实现一个小的软件，而当你有这个想法时，你会发现，做软件，GUI是绕不过去的坎，那么python里，有什么优秀的GUI类库，可以极大的提高我们的生产率呢？ wxPython is a GUI toolkit for the Python programming language. It allows Python programmers to create programs with a robust, highly functional graphical user interface, simply and easily。 今天我们就来详细解析下如何用wxpython实现一个类似与notepad的软件。0.开发好后的GUI如下：看起来是不是还算可以？那么如何实现呢？ 安装wxpython。http://downloads.sourceforge.net/wxpython/wxPython3.0-win64-3.0.2.0-py27.exe 使用。2.1 先写个helloworld对话框来理解基本用法。 123456789101112131 #!/usr/bin/env python2 import wx34 # Create a new app, don't redirect stdout/stderr to a window.5 app = wx.App(False) 67 # A Frame is a top-level window.8 frame = wx.Frame(None, wx.ID_ANY, "Hello World") 910 # Show the frame.11 frame.Show(True) 1213 app.MainLoop() Note： A wx.Frame is a top-level window. The syntax is x.Frame(Parent, Id, Title). Most of the constructors have this shape (a parent object, followed by an Id). In this example, we use None for “no parent” and wx.ID_ANY to have wxWidgets pick an id for us.2.2 notepad的实现中的关键点来进行讲解。2.2.1 把wx.Frame替换成我们的text editor 12345678910111213 1 #!/usr/bin/env python 2 import wx 3 class MyFrame(wx.Frame): 4 """ We simply derive a new class of Frame. """ 5 def __init__(self, parent, title): 6 wx.Frame.__init__(self, parent, title=title, size=(200,100)) 7 self.control = wx.TextCtrl(self, style=wx.TE_MULTILINE) 8 self.Show(True) 9 10 app = wx.App(False)11 frame = MyFrame(None, 'Small editor')12 app.MainLoop() 2.2.2 text editor有了，还需要在上面做菜单及菜单选项。 12345678910111213141516171819202122232425 1 import wx 2 3 class MainWindow(wx.Frame): 4 def __init__(self, parent, title): 5 wx.Frame.__init__(self, parent, title=title, size=(200,100)) 6 self.control = wx.TextCtrl(self, style=wx.TE_MULTILINE) 7 self.CreateStatusBar() # A Statusbar in the bottom of the window 8 9 # Setting up the menu.10 filemenu= wx.Menu()11 12 # wx.ID_ABOUT and wx.ID_EXIT are standard IDs provided by wxWidgets.13 filemenu.Append(wx.ID_ABOUT, "&amp;About"," Information about this program")14 filemenu.AppendSeparator()15 filemenu.Append(wx.ID_EXIT,"E&amp;xit"," Terminate the program")16 17 # Creating the menubar.18 menuBar = wx.MenuBar()19 menuBar.Append(filemenu,"&amp;File") # Adding the "filemenu" to the MenuBar20 self.SetMenuBar(menuBar) # Adding the MenuBar to the Frame content.21 self.Show(True)22 23 app = wx.App(False)24 frame = MainWindow(None, "Sample editor")25 app.MainLoop() 2.2.3 菜单选项有了，但只是GUI不能交互，得加上交互部分。 1234567891 class MainWindow(wx.Frame):2 def __init__(self, parent, title):3 wx.Frame.__init__(self,parent, title=title, size=(200,100))4 ...5 menuItem = filemenu.Append(wx.ID_ABOUT, "&amp;About"," Information about this program")6 self.Bind(wx.EVT_MENU, self.OnAbout, menuItem)1 def OnAbout(self, event):2 ... 2.2.4. 菜单选项有了，每一项菜单选项都有对应的交互函数了，那么运行下看看。如果看到文章开头的界面和功能，则说明运行成功。 上文只是描述了如何借用wxpython进行GUI开发，具体的源代码及实现请参考github：Github]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典Dict总结]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPython%E5%AD%97%E5%85%B8Dict%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Python字典Dict总结, 实现对字典排序python 字典（dict）的特点就是无序的，按照键（key）来提取相应值（value），如果我们需要字典按值排序的话，怎么办呢？假设有这么一个字典 ：1dict = &#123;‘apple’:3, “orange”:2, “oil”:3&#125; *按照key排序12return_dict = sorted(dict.iteritems(), key=lambda d:d[0], reverse=True)print return_dict *按照value排序12return_dict = sorted(dict.iteritems(), key=lambda d:d[1], reverse=True)print return_dict 字典实现一键对应多值在编码中，比如你得到了一个字典，字典里是一个sprint的每个story及它对应的优先级，那么我们要统计优先级为P的story都有哪些，该怎么办呢？这就涉及到如何利用字典实现一键对应多值。例如原生字典如下:12345dict = &#123;"ATEAM-0001": "P1", "ATEAM-0002": "P0", "ATEAM-0003": "P1"&#125;new_dict = &#123;&#125;for k, v in dict.iteritems(): new_dict.setdefault(v,[]).append(k)print new_dict 扩展阅读：Following is the syntax for setdefault() method − dict.setdefault(key, default=None) Parameterskey – This is the key to be searched.default – This is the Value to be returned in case key is not found. Return ValueThis method returns the key value available in the dictionary and if given key is not available then it will return provided default value.]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 求List的交集，并集，差集.]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPython%20%E6%B1%82List%E7%9A%84%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Python 求List的交集，并集，差集 1.获取两个list 的交集 #方法一:12345a=[1，2，6，3，4，5]b=[2, 5, 12]temp = [i for i in a if i in b]print temp#[2，5] #方法二1print list(set(a).intersection(set(b))) 2.获取两个list 的并集 1print list(set(a).union(set(b))) 3.获取两个 list 的差集1print list(set(b).difference(set(a))) 扩展阅读：python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消 除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和 sysmmetric difference(对称差集)等数学运算： Operation Equivalent Result s.update(t) s |= t return set s with elements added from t s.intersection_update(t) “s &amp;= t” return set s keeping only elements also found in t s.difference_update(t) “s -= t” return set s after removing elements found in t s.symmetric_difference_update(t) “s ^= t return set s with elements from s or t but not both s.add(x) add element x to set s s.remove(x) remove x from set s; raises KeyError if not present s.discard(x) removes x from set s if present s.pop() remove and return an arbitrary element from s; raises KeyError if empty s.clear() remove all elements from set s]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python统计列表重复项]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPython%E7%BB%9F%E8%AE%A1%E5%88%97%E8%A1%A8%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[Python编程中经常遇到的问题，如何统计一个列表中重复项？总结如下： 方法1：1234test_list = [1,2,2,3,3,3,4,4,4,4]test_set = set(test_list) #test_set是另外一个列表，里面的内容是test_list里面的无重复 项for item in test_set: print("the %d has found %d" %(item,test_list.count(item))) 方法2:利用字典的特性来实现。123456List=[1,2,2,3,3,3,4,4,4,4]a = &#123;&#125;for i in List: if List.count(i)&gt;1: a[i] = List.count(i)print (a) 方法3：12from collections import CounterCounter([1,2,2,3,3,3,4,4,4,4])]]></content>
      <categories>
        <category>dev-in-test</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Punit详解]]></title>
    <url>%2F2017%2F04%2F01%2FPython%E7%9F%A5%E8%AF%86%2FPunit%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[我们之前发布了Web自动化框架实践指南文章，并放出了一个简化版的自动化框架，有同学后台留言说，不知道那些测试用例是如何组织的，如何决定哪些用例要run，那些要skip，我们今天来解答下。 代码里可以看到，我测试用例的组织主要靠python unittest来完成。这个有点像junit，我们先来讲如何使用： 导入unittest模块 定义继承自unittest.TestCase的测试用例类 定义setUp和tearDown，setUp()方法中进行测试前的初始化工作， tearDown()方法中执行测试后的清除工作，setUp()和tearDown()都是TestCase类中定义的方法。 定义测试用例，名字以test开头。然后完成具体测试用例的编写，断言，判断等。 调用unittest.main()启动测试或者提供名为suite()的全局方法来启动测试。 举例如下：123456789101112131415161718192021222324252627282930313233343536__author__ = 'kevin'import unittestimport settingsfrom common.take_screenshot import take_screenshotfrom common.selenium_helper import SeleniumHelperfrom page.b2s import LoginPageclass TestB2SLogin(unittest.TestCase): def setUp(self): self.browser =SeleniumHelper.open_browser("chrome") @take_screenshot def test_blank_user_login(self): login = LoginPage(self.browser) login.login(settings.blank_user,settings.blank_password) login.blank_user_login_validation() @unittest.skip("Won't run") @take_screenshot def test_invalid_user_login(self): login = LoginPage(self.browser) login.login(settings.invalid_user,settings.invalid_password) login.invalid_user_login_validation() def tearDown(self): self.browser.delete_all_cookies() self.browser.quit()if __name__ == "__main__": def suite(): return unittest.makeSuite(TestB2SLogin, "test") unittest.main(defaultTest = 'suite') 以上是针对登录page的所有测试用例，在这些用例中，不需要执行的只需要在函数定义前加入如下代码即可： 1@unittest.skip("Won't run") 假设我们有N张Page，那么我们每一张Page先定义一个类，然后针对每一个定义的Page类在定义个Test类，这个Test类继承了unittest.TestCase，在每一个Test类中，定义了M个测试方法（每一个测试方法即为一个testcase），想要skip的testcase，只需按照上述方法即可实现运行时skip。 等我们针对所有Page的所有Tests类的每一个方法都标记了skip与否后，我们在main函数里通过 1unittest.defaultTestLoader.discover（start_dir, pattern='test*.py', top_level_dir=None）来实现查找case并执行（一下代码基于所有的testcase放在一个名为tests的文件目录下）：1234567891011121314151617__author__ = 'kevin'import unittest,osif __name__ == "__main__": suite = unittest.defaultTestLoader.discover \(os.path.join(os.path.dirname(__file__),"test"), \ pattern='*.py',top_level_dir=os.path.dirname(__file__)) unittest.main(defaultTest = 'suite') #测试结果如下：TestB2SLogin.s----------------------------------------------------------------------Ran 2 tests in 9.888sOK (skipped=1) 扩展阅读：unittest.skip(reason)Unconditionally skip the decorated test. reason should describe why the test is being skipped. unittest.skipIf(condition, reason)Skip the decorated test if condition is true. unittest.skipUnless(condition, reason)Skip the decorated test unless condition is true. unittest.expectedFailure()Mark the test as an expected failure. If the test fails when run, the test is not counted as a failure. discover(start_dir, pattern=’test*.py’, top_level_dir=None)Find all the test modules by recursing into subdirectories from the specified start directory, and return a TestSuite object containing them. Only test files that match pattern will be loaded. (Using shell stylepattern matching.) Only module names that are importable (i.e. are valid Python identifiers) will be loaded All test modules must be importable from the top level of the project. Ifthe start directory is not the top level directory then the top level directory must be specified separately. If importing a module fails, for example due to a syntax error, then this will be recorded as a single error and discovery will continue. If a test package name (directory with init.py) matches thepattern then the package will be checked for a load_testsfunction. If this exists then it will be called with loader, tests,pattern. If load_tests exists then discovery does not recurse into the package,load_tests is responsible for loading all tests in the package. The pattern is deliberately not stored as a loader attribute so that packages can continue discovery themselves. top_level_dir is stored so load_tests does not need to pass this argument in toloader.discover(). start_dir can be a dotted module name as well as a directory.]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发系列--Flask+SAE新浪云部署微信公众号]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--Flask%2BSAE%E6%96%B0%E6%B5%AA%E4%BA%91%E9%83%A8%E7%BD%B2%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[近期，腾讯公布了2016年业绩报告，其中显示微信活跃用户数已达5.49亿， 如果你还不明白这代表什么，来看看 国内三大电信运营商的表现： 2016年6月20日, 中国移动用户总数达8.35亿， 其中4G用户达4.09亿。2016年2月， 中国联通移动用户数2.57亿，4G用户5480.2万。2016年上半年，电信移动用户数2.07亿，其中4G用户数9010万户。 三者的4G用户相加为 5.53亿上下。 也就是说，全中国每一个用4G网络的人几乎都是微信的客户！！！ 为什么要说这个，同志们，技术人员不能只低头干活，不抬头看路啊！ 加上微信近期将会推出公众号–企业应用号。什么意思呢，就是说以后我们手机里，只需要微信一个APP就可以了， 其它所有的APP都将以web App的方式嵌入到微信中，用户像关注公众号一样的使用。那么开发者怎么办？当然是做公众号开发嵌入微信了。 细思极恐啊，同志们，微信就是未来，你不懂微信你就没有未来啊！ 好的，装逼结束，我们来看如何开发公众号： 申请服务器 搭建服务 申请公众号 开发者基本配置 提供服务如果你不知道如何在本地搭建并发布你的服务， 请参考旧文&lt;利用Apache+Flask+python部署网页应用&gt; 今天我们来尝试用比较流行的新浪云来部署我们的应用，好处是有了一个外部域名，可以直接被微信服务器访问。 1.登录新浪云，进入 我的首页 ，点击 创建新应用 ，创建一个新的应用 itesting。运行环境选择 Python2.72.编辑应用代码要想让微信和新浪云通信，以下下文件不可缺少：index.wsgi123import saefrom main import appapplication = sae.create_wsgi_app(app)新浪云上的 Python 应用的入口为index.wsgi:application，也就是index.wsgi这个文件中名为application的 callable object。在 我的应用中，该 application 为一个 wsgi callable object。 config.yaml 。在目录下创建应用配置文件 config.yaml ，内容如下： name: itesting version: 1 main.py1234567891011121314151617181920212223242526272829303132333435363738from flask import Flask, request, make_responseimport hashlibimport xml.etree.ElementTree as ETapp = Flask(__name__)app.debug = True@app.route('/welcome')def hello_world(): return "Welcome to Kevin's website!"@app.route('/', methods=['GET', 'POST'])def wechat(): if request.method == 'GET': if len(request.args) &gt; 0: temparr = [] #此处为公众号里设置的token token = settings.token signature = request.args["signature"] timestamp = request.args["timestamp"] nonce = request.args["nonce"] echostr = request.args["echostr"] temparr.append(token) temparr.append(timestamp) temparr.append(nonce) temparr.sort() newstr = "".join(temparr) sha1str = hashlib.sha1(newstr) temp = sha1str.hexdigest() if signature == temp: return make_response(echostr) else: return make_response("Access denied") else: return make_response("Wrong args received") else: return make_response("Welcome to iTesting") 这里面有微信的逻辑，开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带参数如下表所示： 参数 描述 signature 微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。 timestamp 时间戳 nonce 随机数 echostr 随机字符串 开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：1）将token、timestamp、nonce三个参数进行字典序排序2）将三个参数字符串拼接成一个字符串进行sha1加密3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 3.上传到新浪云切换到项目目录，用git命令在你应用的git代码目录里，添加一个新的git远程仓库 sae。12345$ git remote add sae https://git.sinacloud.com/itesting#编辑代码并将代码部署到 `sae` 的版本1。$ git add .$ git commit -m 'Init my first app'$ git push sae master:1成功后输入 http://itesting.applinzi.com/ 测试，如果返回 “Wrong args received”， 说明配置成功。 4.进入公众号， 左侧菜单选择开发-》基本配置，配置URL为上述地址，然后其它选项填好， 保存，当显示保存成功则说明配置成功。 配置好后，所有用户发给你的消息都将通过新浪云服务器处理，你需要自己写处理的代码逻辑。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发系列--自动回复实现天气预报查询]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[上次我们讲了微信公众号的部署，今天我们来实现一个小功能，自动回复天气预报的播报。 使用方法如下： 在iTesting公众号里直接回复 “城市 天气”，将会把上海最近的天气信息返回给你， 例如输入上海 天气 ， 会返回给你上海的天气情况。 通过仔细阅读微信开发文档，我们知道： 当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。 简单来说，当你输入信息要求微信服务器返回你一个信息时，是在做一个Post请求，这个post请求是text格式的，微信收到会转给你自己的服务器，你的服务器处理好后，按照微信的要求把内容返回，然后你就可以看到回复了。原理知道了，那么如何开发？步骤如下： 首先把回复的xml准备好，放在文件里，例如 txt_message.xml. 123456&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&#123;to_user&#125;]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[&#123;from_user&#125;]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;&#123;c_time&#125;&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[&#123;content_value&#125;]]&gt;&lt;/Content&gt;&lt;/xml&gt; 调用天气预报API生成天气。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: UTF-8 -*-import sysreload(sys)sys.setdefaultencoding("utf-8")import requestsimport settingsclass GetWeather(object): headers = &#123;'apikey': settings.baidu_apikey&#125; def get_city_code(self, city): url = 'http://apis.baidu.com/apistore/weatherservice/citylist?cityname=%s'%city r = requests.get(url, headers=self.headers) j = r.json()['retData'] for i in j: if i['name_cn'] == city: return i['area_id'] def get_weather(self, city): city_code = self.get_city_code(city) url = 'http://apis.baidu.com/apistore/weatherservice/recentweathers?cityname=&#123;&#125;&amp;cityid=&#123;&#125;'.format(city, city_code) r = requests.get(url, headers=self.headers) raw_data = r.json() if raw_data.has_key("retData"): if type(raw_data['retData']) == dict: j = raw_data['retData']['today'] content = "今日&#123;city&#125;的天气情况如下：\n" \ "日期：&#123;date&#125;," \ "&#123;week&#125;, " \ "当前温度：&#123;curTemp&#125;, " \ "&#123;type&#125;, &#123;fengxiang&#125;, &#123;fengli&#125;" \ "最高气温：&#123;hightemp&#125;, " \ "最低气温：&#123;lowtemp&#125;, " \ "PM值：&#123;aqi&#125;" .format(city=city, date=j['date'], week=j['week'], curTemp=j['curTemp'],type=j['type'],\ fengxiang=j['fengxiang'], fengli=j['fengli'], hightemp=j['hightemp'],\ lowtemp=j['lowtemp'], aqi=j['aqi']) return content else: return "您输入的城市有误，请重新输入." else: return "您输入的城市有误，请重新输入."if __name__ == "__main__": w = GetWeather() print w.get_weather('上海') 把上述步骤里得到的返回值，嵌入到step1的变量里，返回给微信Server。具体做法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@app.route('/', methods=['GET', 'POST'])def wechat(): if request.method == 'GET': if len(request.args) &gt; 0: temparr = [] token = settings.token signature = request.args["signature"] timestamp = request.args["timestamp"] nonce = request.args["nonce"] echostr = request.args["echostr"] temparr.append(token) temparr.append(timestamp) temparr.append(nonce) temparr.sort() newstr = "".join(temparr) sha1str = hashlib.sha1(newstr) temp = sha1str.hexdigest() if signature == temp: return make_response(echostr) else: return make_response("Access denied") else: return make_response("Wrong args received") else: raw_data = request.stream.read() xml_raw = ET.fromstring(raw_data) msg = &#123;&#125; for child in xml_raw: msg[child.tag] = child.text msgtype = msg['MsgType'] tou = msg['ToUserName'] fromu = msg['FromUserName'] time_str = str(int(time.time())) if msgtype == "event": event_msg = xml_raw.find('Event').text print event_msg if event_msg == "subscribe": sub_content = settings.welcome_message else: sub_content = "error" xml_reader = XMLHelper().read_xml("txt_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=sub_content)) elif msgtype == "image": media_id = msg['MediaId'] xml_reader = XMLHelper().read_xml("img_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id)) elif msgtype == "voice": media_id = msg['MediaId'] xml_reader = XMLHelper().read_xml("voice_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id)) elif msgtype == 'text': # co = xml_raw.find('Content').text.strip().split(' ') # if co[len(co)-1] == '天气': # weather = GetWeather() # auto_response_content = weather.get_weather(co[:-1][0]) # else: r = RobotHelper() auto_response_content = r.get_robot(xml_raw.find('Content').text) xml_reader = XMLHelper().read_xml("txt_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=auto_response_content)) elif msgtype in ["video","shortvideo"]: title = "My video" description = "Check out my video" media_id = msg['MediaId'] xml_reader = XMLHelper().read_xml("video_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id, title=title, description=description)) else: unknown_content = u"""我不知道你在干什么,无法回复你""" xml_reader = XMLHelper().read_xml("txt_message.xml") response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=unknown_content)) response.content_type = 'application/xml' return response 这样就实现了基于文本格式的天气预报功能，是不是没有那么难？ 其实，如果你仔细研究下微信开发文档你就发现，微信开发的本质是接口测试，不过接口测试的结果被我们的服务器拿来使用，变成了一个个功能而已。 怎么理解呢？我们开发一个个功能时，实际上就是一次次对微信接口发起请求，微信通过开放给我们一个个接口，接收按照固定格式的post数据，处理后返回结果，我们收到结果后，自己写代码处理完毕，再按照微信要求的格式传给我们的服务器，服务器接收后，展示或者返回相应结果。 到现在为止，我们基本解锁了微信开发，高大上的微信开发也不过是接口测试而已。。。 我相信通过上述解释大家肯定可以实现更多好玩的功能了， 大家可以尝试下我写的自动回复机器人功能，有问题直接留言给我， 我会答疑解惑：）]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信公众号开发系列--本地调试环境搭建]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[上次我们讲了如何利用Flask + 新浪云部署微信开发，在开发的过程中我们发现如下问题： 1.程序出现问题，调试比较麻烦，log保存需要自己写代码。2.每次更改都需要发布到应用服务器，一旦有问题，立刻影响公众号正常使用。3.服务器无效代码太多，这对于有代码洁癖的完全不能忍好吗！如果能本地调试就好了，我们只发布正确的版本到应用服务器，最好调试简单，方便，log即开即看，那么有没有可能呢？ 必须有，今天我们就来介绍一款内网传透神器– ngrok. ngrok 是一个反向代理，通过在公共的端点和本地运行的Web 服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析和重放.下面以我们本地的服务器为例《利用Apache+Flask+python部署网页应用》，来介绍下如何使用：1.下载：https://ngrok.com/2.安装：下载好后cmd命令进入到解压的目录，然后运行命令如下： ngrok http 8088 –authtoken “ your token,get from ngrok.com” 当你看到如下信息说明运行成功，Forwarding里的地址就是外网能访问的地址。这里需注意，你注册号后会有一个唯一的token，用作绑定地址。Tunnel Status onlineVersion 2.0/2.0Web Interface http://127.0.0.1:4040Forwarding http://92832de0.ngrok.io -&gt; localhost:80Forwarding https://92832de0.ngrok.io -&gt; localhost:80 Connnections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 3.使用上述地址访问确应用服务器保配置正确，然后去微信-》开发-》开发者工具，里申请公众平台测试帐号，然后在配置里，填写上述url 和token。保存成功后，所有的用户消息都将通过微信转往我们的外网服务器。4.以我们的应用为例, 在浏览器输入 http://localhost:4040，等我们的程序运行，无论成功与否，所有的get， post请求都可以在这个地址看到，如果有错误你可以可以直接看到具体出错信息，因为我们用的是apache，出错后也可以直接去Apache文件夹下面的log里看error，是不是超级方便？5.那么你修改好错误后，如何生效呢？重启apache server即可。然后去往测试公众号里发送请求，就可以看到最新的反馈了。]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
        <tag>微信开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Apache+Flask+python部署网页应用]]></title>
    <url>%2F2017%2F04%2F01%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%2F%E5%88%A9%E7%94%A8Apache%2BFlask%2Bpython%E9%83%A8%E7%BD%B2%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[当你开发好一个网页程序后，除了本地浏览，你当然期望把它发布出去供大家欣赏。我们今天就来讲下如何用Apache 部署你的应用程序（注：发布后只能通过ip访问，你需注册域名才能通过域名访问）。 重要的事情说三遍：for i in range（3）:“以下所有的安装要么全部安装32bit，要么全部安装64bit，否则运行不起来。” 1.安装 Python唯一注意的是安装选项需选择应用于所有用户。 2.安装Apache:地址：https://httpd.apache.org/download.cgi 以window为例，我们选择Files for Microsoft Windows， 然后安装Apache Haus下所有的相应版本，例如：注意看, 竖排的软件为兼容的组合，如果你安装vc11，那么vc11这一列的都要安装，安装好后根据文件里的 readme进行配置，其中要注意的是主要是mod_wsgi 的安装，这个是用来和python通信的。 注意：× 根据需要配置你的SRVROOT文件路径（apache安装文件conf下的httpd.conf），这里为”C:\Apache24”.× 根据需要更改你的端口号。（可以在command line下用netstat -ao的方式看端口号有没有被占用。）× 注意需成功配置mod_wsgi, 提示：在apache安装目录下 启用 LoadModule wsgi_module modules/mod_wsgi.so 并将mod_wsgi 文件copy到modules目录。 全部安装好后，command line进入apache的bin目录，输入httpd来看安装是否正确，然后输入httpd -k install 来安装windows service，然后启动。 3.安装flask1pip install Flask 4.开发你的app 我们写一个welcome页面，需要2个文件： main.py 1234567from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return "Welcome to Kevin's website!"if __name__ == '__main__': app.run() main.wsgi （这个文件用做网关跟apache通信，记住文件名称，apache配置要用）To run your application you need a yourapplication.wsgi file. This file contains the codemod_wsgi is executing on startup to get the application object. The object calledapplication in that file is then used as application. 123import sys, ossys.path.insert(0, os.path.dirname(__file__))from main import app as application 5.配置 Apache。 在httpd.conf里，配置如下： 去掉前面的#号。Include conf/extra/httpd-vhosts.conf 在conf的extra下，配置httpd-vhosts.conf 如下： DocumentRoot D:\wechat_test\wechat ServerName localhost WSGIScriptAlias / D:\wechat_test\wechat\main.wsgi Require all granted 注意： 端口号跟httpd.conf的Listen端口一致。 wsgi目录， Directory跟你app里定义的一致。 把文件里原有的不需要的配置command out掉。 6.重启下Apache services，然后浏览器里输入http://localhost:8088看你开发的app首页有没有正确load：成功，下面你可以继续完善你的app了 ：）]]></content>
      <categories>
        <category>dev-in-test</category>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>dev-in-test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web端测试和移动端测试的区别小记]]></title>
    <url>%2F2016%2F06%2F28%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FWeb%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文摘自公众号 我是测试经理， 原作者张真真。 之前一直参与web端的测试，最近一个项目加入了移动端，本人有幸参与了移动端的测试，记录一下两端的区别： 1、报bug 对于测试来说，比较重要的一个步骤就是报bug,在web端我们发现问题之后，可以利用系统自动工具或者其他截图工具直接截图，然后将错误的地方或者比较重要的点进行标记，但是在移动端，截图相对来说就没那么简单了，因为这地方需要分为两个步骤，一是截图，二是传到电脑端（因为我们利用jira记录bug 情况，报bug是在电脑端的）。关于截图，一般的手机都会有快捷键，传到电脑端比较笨的方式就是利用数据线，或者利用豌豆荚、金山快盘等同步工具，然后，再利用画图等方式对图片进行编辑。 推荐工具：手机快捷键截图，传送图片可以借用微信/qq传送到我的电脑 通过一段时间的学习和实践，关于报bug我有以下几点感受和建议。 bug主题：尽量使用简短的语言描述具体问题，尽量做到通过主题可以知道本jira记录的是什么问题。如果有多端如wap/android/IOS或多模块、多个子系统如主站、后台等同时参与测试，最好开始就标记是哪端或哪个系统的问题。 环境及系统：移动端由于手机和版本较多，因为在bug的时候尽量做到每一个Bug都有是在什么系统什么版本下发生的，即使此问题与系统或浏览器的版本没有关系。这样做主要有以下几个好处，一是假设问题与系统和版本有关系，则方便开发快速定位问题；二是，版本较大，问题较多时，方便测试人员快速验 证。因为假如是wap端的测试，一个人一般是在几个浏览器之间交叉测试，不可避免会存在忘记问题发生在哪个版本的情况；三是，通过这段时间的测试发现，有些在测试环境发现并且已修复的问题，线上会出现（甚至是运行一段时间之后再出现），这时候假如之前bug记录的很详细，那测试人员是有”证据“说明这件事情不是我们的主要责任，当然这样做的目的并不是为了推卸责任，而是有时候这样做是必要的； 账号及数据：发现问题记录的时候，尽量提供所用的账号及商品、优惠券等数据，尤其是一些特殊的、边界值等不太容易造的数据，以方便开发人员利用现有数据重现问题，节省时间。 2、测试环境设置 web端测试的时候只需要直接修改hosts，但是移动端设置起来比较复杂，比较简单的方式是电脑端设置代理，手机端直接连接代理。注意，手机和电脑必须连接 同一个网络。 请求及响应数据的查看，也需要通过代理的方式来查看。 推荐一种设置代理的工具(Fiddler)及方法：http://www.bitscn.com/network/soft/201408/312306.html 3、测试方式——–兼容性 web端的测试一般都是主要使用一种浏览器，待系统基本稳定的时候，再去专门测试浏览器的兼容性。 但是，对移动端来说，这样的方式是行不通的，因为移动端主要分为安卓和IOS，而这两端出现的问题一般是不一致的，一致的问题主要是数据问题，这时候是需要后台处理的，所以我们测试的时候需要两端都重点测试，而不会出现先着重测试某一端的问题。 注：一般方式是在测试一端时，出现问题则立马查看另一端是否也有这个问题。 4、移动端的特性 移动端与web端相比较来说，移动端有很多自己的特性： ① 网络种类多 移动端有多种网络：无线网络、2G、3G、4G等，断网、网速较差及网络之间的切换时页面的显示等，这些对于移动端来说很重要。此外，在非wifi下，还需要注意网络使用量问题。 ② 间断问题 移动端有一个很重要的问题，一般情况下在使用软件的过程并不是长久的，这中间可能发生很多中断，如电话、短信、通知、断电等等，软件需要特殊处理这些特殊情况。 打开一个页面，或在操作的过程中（点击一个按钮后），将手机屏幕锁住，再打开时，应用能否正常处理。 ③ 屏幕的限制 图片及文字的显示；上传不同的图片尺寸显示是否正常；图片和文字一起显示时，效果如何。 操作区域；web端的应用，一般不会受到屏幕的限制，而且通过鼠标操作更加准确。但是移动端由于屏幕较小，页面及按钮会受到屏幕大小的限制，再加上用户都是通过手指进行操作，一些按钮、选择框 等是否容易点击，多个可点区域位置较近时，点击部位稍微偏移，也许就会造成不同的结果，这种情况下是否可以达到预先的效果。 ④ 软件启动运行 移动端启动、卸载、升级几个特性，这是比较常见、也很重要的，比如升级时用户的数据怎么办，卸载后用户的数据怎么处理，卸载再安装用户登录数据的显示等。 ⑤ 手势 移动端还有一大特性，就是移动端有自己比较简单的手势，用户可以通过手势进行一个操作，比如左滑删除、右滑返回上一个页面、左右滑动图片等，软件需要对这个手势进行适配。 ⑥ 分享 移动端一般会装有很多软件，用户下单或者产品有活动时，用户都会进行分享，但是分享时的权限、软件是否存在等问题，需要特殊处理测试。一般的软件或应用，都会开放一部分页面，允许用户不登录时即可访问，而有些页面是必须要求用户登录的，主要针对这两种权限不同的页面做分享，然后通过分享进入本页面，查看权 限的控制是否正常。 ⑦ web和移动端的同步 用户在web端的操作，在移动端是否可以正常的进行同步、显示；在移动端的操作，用户登录web账号，信息是否同步等。]]></content>
      <categories>
        <category>mobile-test</category>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>Mobile-Test</tag>
        <tag>Web-Test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Native-WebView-Hybird的区别]]></title>
    <url>%2F2016%2F06%2F27%2F%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97%2FNative-WebView-Hybird%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[现在手机上应用实现方式一般分为以下几种： Native APP（原生APP）：原生App是专门针对某一类移动设备而生的，位于平台层上方，基于各平台系统开发的app,向下访问和兼容的能力会比较好一些，可以支持在线或离线，消息推送或本地资源访问，摄像拨号功能的调取。但是由于设备碎片化，App的开发成本要高很多，维持多个版本的更新升级比较麻烦，用户的安装门槛也比较高。Native APP被直接安装到设备里，而用户一般也是通过网络商店或者卖场来获取例如 The App Store 与 Android Apps on Google Play . Web APP(WebView)：web应用程序的一种，主要是使用HTML5技术，如javascript、css，并能够在文本浏览器中运行。开发者们可以通过互联网或者移动互联网发布自己的web-app程序，由于发布的版本不断更新，所有用户需要了解web-app 的版本信息，以免出错。Web应用程序用于规避苹果通过其应用程序商店销售iphone提出，例如，Google Voice。web应用程序可以在线使用，也可以离线使用. Hybrid APP(混合原生APP支持下的网页APP)：部分代码以WEB技术编程，部分代码由某些Native Container承担（例如PhonGAP插件，BAE插件），介于这两者之间的app,它只有一个UI WebView，里面访问的是一个Web App，比如街旁网最开始的应用就是包了个客户端的科，其实里面是HTML5的网页，后来才推出真正的原生应用。再彻底一点的，如掌上百度和淘宝客户端Android版，走的也是Hybrid App的路线，不过掌上百度里面封装的不是WebView，而是自己的浏览内核，所以体验上更像客户端，更高效。 以下是特性对比列表：现在趋势是Hybird APP， 但具体项目采用哪种应用是由多种因素决定的， 不可一概而论。]]></content>
      <categories>
        <category>mobile-test</category>
        <category>basic-knowledge</category>
      </categories>
      <tags>
        <tag>Mobile-Test</tag>
      </tags>
  </entry>
</search>
