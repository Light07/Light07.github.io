<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>你不知道的Cypress系列（8） -- “可视化”测试你知多少？</title>
      <link href="/2021/04/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%978-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9F%A5%E5%A4%9A%E5%B0%91/"/>
      <url>/2021/04/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%978-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BD%A0%E7%9F%A5%E5%A4%9A%E5%B0%91/</url>
      
        <content type="html"><![CDATA[<p>转眼之间，你不知道的Cypress系列已经到第8篇了。在Cypress中国群内、在公众号iTesting里，我每天都能看到大量关于Cypress的使用讨论和私下问询。这让我感到无比荣幸。[<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>]。</p><p>今天是你不知道的Cypress系列（8） – “可视化”测试你知多少？<br><a id="more"></a></p><p>断言是自动化测试中比较繁琐的一个动作，特别是当你要检查的点比较多的时候。在以往的测试中，如果要检查页面元素是否符合我们期望，我们通常通过一个个的断言来进行。</p><p>这样带来一个问题，一个用例往往需要多达5、6个甚至更多的断言。假设我的需求仍处于变化中，那么每一次改动需求，我都需要重新更改断言的值。特别是当页面改变主要跟UI的变化有关时（例如button的颜色、 button的位置、button的个数， icon的大小等等），频繁更改代码会苦不堪言。</p><p>于是，“可视化”测试（Visual Testing）就出现了。</p><h4 id="（一）什么是可视化测试"><a href="#（一）什么是可视化测试" class="headerlink" title=" （一）什么是可视化测试"></a><center> （一）什么是可视化测试</center></h4><p>可视化的定义如下：</p><blockquote><p>“Visual testing evaluates the visible output of an application and compares that output against the results expected by design.”</p></blockquote><p>我就不翻译了，可视化测试就是检查“页面所见”是否符合需求预期。那么“页面所见”是什么，就是页面呈现出来的可被看见的效果。</p><p>一般情况下，可视化测试都是通过图片对比来实现的。也被称之为“图像测试”，“图片测试”等。</p><h4 id="（二）Cypress可视化测试工作原理"><a href="#（二）Cypress可视化测试工作原理" class="headerlink" title=" （二）Cypress可视化测试工作原理"></a><center> （二）Cypress可视化测试工作原理</center></h4><p>可视化测试的原理非常简单，那就是图片Diff。在你第一次运行某个测试时，Cypress Test Runner对你指定的元素进行截图并保存，并称之为Base Line。在你第2次运行这个测试时，会再次截图并将截图与BaseLine进行比较。</p><h4 id="（三）可视化测试实例"><a href="#（三）可视化测试实例" class="headerlink" title=" （三）可视化测试实例"></a><center> （三）可视化测试实例</center></h4><p>“You can you up, no can no bb”, 直接上代码吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关注公众号iTesting，跟万人测试团一起成长</span></div><div class="line">describe(<span class="string">'iTesting demo'</span>, () =&gt; &#123;</div><div class="line"></div><div class="line">    it(<span class="string">'可视化测试'</span>, () =&gt; &#123;</div><div class="line">        cy.visit(<span class="string">'https://www.baidu.com'</span>)</div><div class="line">        cy.get(<span class="string">'#kw'</span>).type(<span class="string">'iTesting'</span>)</div><div class="line">        cy.get(<span class="string">'#su'</span>).click()</div><div class="line">        <span class="comment">// 传统断言</span></div><div class="line">        cy.get(<span class="string">'.result.c-container.new-pmd'</span>).eq(<span class="number">0</span>).then(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</div><div class="line">            expect(ele.text(), <span class="string">'验证第一个结果的text里包括iTesting'</span>).to.includes(<span class="string">'iTesting软件测试知识分享'</span>)</div><div class="line">        &#125;)</div><div class="line">        <span class="comment">//可视化“断言”</span></div><div class="line">        <span class="comment">//可视化能检查的更多。</span></div><div class="line">        cy.get(<span class="string">'.result.c-container.new-pmd'</span>).eq(<span class="number">0</span>).toMatchImageSnapshot()</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>为了对比，我上面代码里，列出了传统的断言方法和可视化测试的”断言“方法。</p><p>这就完了？是的。可视化测试非常简单，下面我来解释下，以上代码做了下面这些事：</p><ol><li><p>打开百度。</p></li><li><p>输入“iTesting”。</p></li><li><p>点击回车查询。</p></li><li><p>检查出现的第一个结果。</p></li></ol><p>需要注意的是，传统方式下的断言，我们都会有预期结果，期望结果。但使用可视化测试后，不需要断言（插件在运行时帮你做了。）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关注公众号iTesting，跟万人测试团一起成长</span></div><div class="line"><span class="comment">//注意toMatchImageSnapshot这个方法</span></div><div class="line">cy.get(<span class="string">'.result.c-container.new-pmd'</span>).eq(<span class="number">0</span>).toMatchImageSnapshot()</div></pre></td></tr></table></figure><p>你仅需要使用.toMatchImageSnapshot()方法就可以完成”断言“检查。</p><p><strong>在本例中，可视化测试会获取测试中的特定元素（即第一条查询结果）的图像快照，然后将该图像与先前批准的基准图像进行比较。如果图像相同（在设置的像素公差内），则确定Web应用程序对用户看起来相同，结果为Pass。如果存在差异，则报错，结果为Fail。</strong></p><p>我们执行下测试，看一下执行结果：</p><p><img src="/2021/04/20/你不知道的Cypress系列/你不知道的Cypress系列8-可视化测试你知多少/1.png" alt=""></p><p>可以看到，运行成功了。再检查下项目目录，你会发现，在你的测试用例下，多了一个文件夹”<strong>image_snapshots</strong>“， 这里有个截图，就是插件保存下来的用作BaseLine的截图。当你每次运行测试时，实际上，Cypress就是拿这个截图跟实际的截图做比较的。（注意，这里截的图，虽然看起来不是我代码中的第一个结果的截图，但是实际上是对的，这个可能跟Baidu页面的展现方式有关。）</p><p><img src="/2021/04/20/你不知道的Cypress系列/你不知道的Cypress系列8-可视化测试你知多少/2.png" alt=""></p><p>为了验证可视化测试确实可工作，我更改可视化代码的检查如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关注公众号iTesting，跟万人测试团一起成长</span></div><div class="line"></div><div class="line">describe(<span class="string">'iTesting demo'</span>, () =&gt; &#123;</div><div class="line"></div><div class="line">    it(<span class="string">'可视化测试'</span>, () =&gt; &#123;</div><div class="line">        cy.visit(<span class="string">'https://www.baidu.com'</span>)</div><div class="line">        cy.get(<span class="string">'#kw'</span>).type(<span class="string">'iTesting'</span>)</div><div class="line">        cy.get(<span class="string">'#su'</span>).click()</div><div class="line">        <span class="comment">// 传统断言</span></div><div class="line">        cy.get(<span class="string">'.result.c-container.new-pmd'</span>).eq(<span class="number">0</span>).then(<span class="function"><span class="params">ele</span> =&gt;</span> &#123;</div><div class="line">            expect(ele.text(), <span class="string">'验证第一个结果的text里包括iTesting'</span>).to.includes(<span class="string">'iTesting软件测试知识分享'</span>)</div><div class="line">        &#125;)</div><div class="line">        <span class="comment">//可视化“断言”，我故意改错，把要验证的元素改成第7个</span></div><div class="line">        cy.get(<span class="string">'.result.c-container.new-pmd'</span>).eq(<span class="number">6</span>).toMatchImageSnapshot()</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>再次运行：</p><p><img src="/2021/04/20/你不知道的Cypress系列/你不知道的Cypress系列8-可视化测试你知多少/3.png" alt=""></p><p>从截图看错，错误原因是不匹配，说明可视化测试是有效的。</p><h4 id="（四）可视化测试好处"><a href="#（四）可视化测试好处" class="headerlink" title=" （四）可视化测试好处"></a><center> （四）可视化测试好处</center></h4><p>我知道你一定会问，直接总结吧：</p><ol><li><p>减少断言代码的编写</p></li><li><p>帮你检查了隐性改变</p></li><li><p>当需求更改后，无需更改代码，删除BaseLine图像即可。</p></li></ol><p>第1条很好理解， 第2条什么意思？ 如果代码的改变是页面元素的颜色，或者icon的大小，在我们传统的测试中，如果你没有针对这个元素颜色或者icon大小做断言，那么测试就总会成功，但实际上页面是有变化的。而使用可视化测试可以避免这一点。</p><h4 id="（五）如何启用可视化测试"><a href="#（五）如何启用可视化测试" class="headerlink" title=" （五）如何启用可视化测试"></a><center> （五）如何启用可视化测试</center></h4><p>可视化测试启用非常简单，只需要如下步骤：</p><p><img src="/2021/04/20/你不知道的Cypress系列/你不知道的Cypress系列8-可视化测试你知多少/4.png" alt=""></p><p>好了，可视化测试用起来，再也不用写断言啦~</p><p>Cypress有很多奇淫巧技， 我已经总结超过百篇， 别走开，下一篇更精彩！</p><h4 id="往期回看："><a href="#往期回看：" class="headerlink" title="往期回看："></a>往期回看：</h4><p><a href="https://helloqa.com/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/" target="_blank" rel="external">你不知道的Cypress系列（1） –鸡肋的BDD</a></p><p><a href="https://helloqa.com/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（2） –该死的PO模型​</a></p><p><a href="https://helloqa.com/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/" target="_blank" rel="external">你不知道的Cypress系列（3） – 是时候重构你的思维了</a></p><p><a href="https://helloqa.com/2021/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20--%20%E2%80%9CPO%E2%80%9D%E5%B7%B2%E6%AD%BB%EF%BC%8CApp%20Action%E5%BD%93%E7%AB%8B/" target="_blank" rel="external">你不知道的Cypress系列（4） – “PO”已死，App Action当立</a></p><p><a href="https://helloqa.com/2021/03/19/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%975%E7%9C%BC%E7%9E%8E%E7%9A%84TestRunner%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（5） – 眼瞎的TestRunner​</a></p><p><a href="https://helloqa.com/2021/03/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20--%20%E5%A4%9ATab%E7%9A%84%E5%B0%8F%E7%A7%98%E5%AF%86/" target="_blank" rel="external">你不知道的Cypress系列（6） – 多Tab的小秘密</a></p><p><a href="https://helloqa.com/2021/04/10/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%977-%E5%BD%93iFrame%E9%81%87%E8%A7%81%E5%BC%B9%E5%87%BA%E6%A1%86/" target="_blank" rel="external">你不知道的Cypress系列（7） – 当iFrame遇见弹出框</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Cypress系列（7） -- 当iFrame遇见弹出框</title>
      <link href="/2021/04/10/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%977-%E5%BD%93iFrame%E9%81%87%E8%A7%81%E5%BC%B9%E5%87%BA%E6%A1%86/"/>
      <url>/2021/04/10/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%977-%E5%BD%93iFrame%E9%81%87%E8%A7%81%E5%BC%B9%E5%87%BA%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<p>转眼之间，你不知道的Cypress系列已经到第7篇了。在Cypress中国群内、在公众号iTesting里，我每天都能看到大量关于Cypress的使用讨论和私下问询。这让我感到无比荣幸。[<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>]。</p><p>今天是你不知道的Cypress系列（7） – 当iFrame遇见弹出框<br><a id="more"></a></p><p>自从Cypress出现后，Cypress就在吊打一切Web端测试框架。虽然Cypress这么优秀，但它也有一些妥协和倔强，除了第6节的多Tab外，还包括这么一条：</p><blockquote><p>iframes not supported</p></blockquote><p>这是多么的简单直接！于是，出现了这么一幕，很多同学悄咪咪的问我：“蔡老师，Cypress不支持iframe啊，iframe都不支持，你怎么还敢推广它？”</p><p>一般这种情况我会说，不支持不代表不可以测试啊！只是使用Cypress测试iFrame不那么方便罢了。</p><h4 id="（一）什么是iFrame"><a href="#（一）什么是iFrame" class="headerlink" title=" （一）什么是iFrame"></a><center> （一）什么是iFrame</center></h4><p>iFrame是Inline Frame的缩写。百度百科说它的作用是文档中的文档，或者浮动的框架(FRAME)，iFrame元素会创建包含另外一个文档的内联框架（即行内框架）。</p><p>我相信你看了这个定义会跟我跟我一样丈二和尚摸不着头脑，我们用人话重新说一遍：</p><p>iFrame是HTML元素的组件，iFrame元素允许你在你的网站中包含来自其他网站的内容。例如，你在各种网站上看到的内嵌的视频，就是iFrame在起作用。</p><p>它的用法也很简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//关注公众号iTesting，跟万人测试团一起成长</span></div><div class="line">&lt;iframe src=<span class="string">"https://www.youu.com/embed/dXBohfjc4WA"</span> width=<span class="string">"680"</span> height=<span class="string">"480"</span> allowfullscreen&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p><p>使用iFrame的好处是它可以将你的用户尽可能的保留在你自己的网站中。但是，过多的使用iFrame会出现安全性方面的问题，并且如果iFrame内容加载缓慢，也会影响到你页面的加载速度。<br>iFrame其实是个上古的前端技术，当前的Web应用程序很少使用iFrame了（<font size="2">所以那位说自己的应用程序很多iFrame的同学，你可以考虑换工作了</font> ）。</p><h4 id="（二）iFrame较多，不建议用Cypress"><a href="#（二）iFrame较多，不建议用Cypress" class="headerlink" title=" （二）iFrame较多，不建议用Cypress"></a><center> （二）iFrame较多，不建议用Cypress</center></h4><p>原因如下：</p><ol><li><p>Cypress当前没有提供原生的命令来访问iFrame。</p></li><li><p>iFrame的快照不会显示在TestRunner里，导致使用Cypress调试包含iFrame的代码非常不方便。</p></li></ol><h4 id="（三）弹出框"><a href="#（三）弹出框" class="headerlink" title=" （三）弹出框"></a><center> （三）弹出框</center></h4><p>弹出框也是自动化测试，特别是We吧端自动化测试的一个难道， 弹出框一般包括如下几种：</p><p><img src="/2021/04/10/你不知道的Cypress系列/你不知道的Cypress系列7-当iFrame遇见弹出框/1.png" alt=""></p><h4 id="（三）我出道题，特别简单"><a href="#（三）我出道题，特别简单" class="headerlink" title=" （三）我出道题，特别简单"></a><center> （三）我出道题，特别简单</center></h4><p>好了，现在我有个需求，需要你测试下这个页面：</p><p><img src="/2021/04/10/你不知道的Cypress系列/你不知道的Cypress系列7-当iFrame遇见弹出框/2.png" alt=""></p><p>你点击下“运行代码”，然后再点击试一试，这个时候会出现一个警告框，你把警告框关掉。</p><p>先不要看解决方案，你先自己写下代码看， 网址如下（在Cypress中国群某个群里说过这个问题，结果很酸爽）：</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=js_alert" target="_blank" rel="external">https://www.w3school.com.cn/tiy/t.asp?f=js_alert</a> </p><h4 id="（四）Cypress操作iFrame和弹出框"><a href="#（四）Cypress操作iFrame和弹出框" class="headerlink" title=" （四）Cypress操作iFrame和弹出框"></a><center> （四）Cypress操作iFrame和弹出框</center></h4><p>有的同学说了，我用了Cypress后，再也不想用Selenium/Webdriver了。但是我的应用程序包含Cypress，我该怎么办？</p><p>不废话了，看Cypress如何处理这种情况：</p><p><img src="/2021/04/10/你不知道的Cypress系列/你不知道的Cypress系列7-当iFrame遇见弹出框/3.png" alt=""></p><p>注意如下代码：</p><p><img src="/2021/04/10/你不知道的Cypress系列/你不知道的Cypress系列7-当iFrame遇见弹出框/4.png" alt=""></p><p>这两个代码是关键，建议好好查查，实在不行，群里问问。</p><h4 id="（五）课后作业"><a href="#（五）课后作业" class="headerlink" title=" （五）课后作业"></a><center> （五）课后作业</center></h4><p>我知道你一定会问，所以我偷偷的给你准备了一个简单的题目，超级简单哦：</p><p>请访问如下页面，然后试着测试下这里的超链接。我相信，你一定会回来找我的：）</p><p><a href="https://www.w3school.com.cn/tiy/t.asp?f=js_confirm" target="_blank" rel="external">https://www.w3school.com.cn/tiy/t.asp?f=js_confirm</a></p><p><a href="https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_prompt" target="_blank" rel="external">https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_prompt</a></p><p>Cypress有很多奇淫巧技， 我已经总结超过百篇， 别走开，下一篇更精彩！</p><h4 id="往期回看："><a href="#往期回看：" class="headerlink" title="往期回看："></a>往期回看：</h4><p><a href="https://helloqa.com/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/" target="_blank" rel="external">你不知道的Cypress系列（1） –鸡肋的BDD</a></p><p><a href="https://helloqa.com/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（2） –该死的PO模型​</a></p><p><a href="https://helloqa.com/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/" target="_blank" rel="external">你不知道的Cypress系列（3） – 是时候重构你的思维了</a></p><p><a href="https://helloqa.com/2021/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20--%20%E2%80%9CPO%E2%80%9D%E5%B7%B2%E6%AD%BB%EF%BC%8CApp%20Action%E5%BD%93%E7%AB%8B/" target="_blank" rel="external">你不知道的Cypress系列（4） – “PO”已死，App Action当立</a></p><p><a href="https://helloqa.com/2021/03/19/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%975%E7%9C%BC%E7%9E%8E%E7%9A%84TestRunner%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（5） – 眼瞎的TestRunner​</a></p><p><a href="https://helloqa.com/2021/03/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20--%20%E5%A4%9ATab%E7%9A%84%E5%B0%8F%E7%A7%98%E5%AF%86/" target="_blank" rel="external">你不知道的Cypress系列（6） – 多Tab的小秘密</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Cypress系列（6） -- 多Tab的小秘密</title>
      <link href="/2021/03/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20--%20%E5%A4%9ATab%E7%9A%84%E5%B0%8F%E7%A7%98%E5%AF%86/"/>
      <url>/2021/03/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%886%EF%BC%89%20--%20%E5%A4%9ATab%E7%9A%84%E5%B0%8F%E7%A7%98%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>转眼之间，你不知道的Cypress系列已经到第6篇了。在Cypress中国群内、在公众号iTesting里，我每天都能看到大量关于Cypress的使用讨论和私下问询。这让我感到无比荣幸。[<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>]。</p><p>今天是你不知道的Cypress系列（6） – 多Tab的小秘密<br><a id="more"></a></p><p>自从Cypress出现后，市面上Web端自动化测试框架就只剩下了两个： 一个是吊打一切的Cypress， 另一个是其它。虽然Cypress这么优秀，但它也有一些妥协和倔强，其中就包括这么一条：</p><blockquote><p>There will never be support for multiple browser tabs.</p></blockquote><p>饶是经验丰富的测试老专家，在技术选型初次接触Cypress时，听到这个消息也不免倒吸一口凉气：<strong>“什么框架，怎么连多Tab都不支持？那还能推广吗？”</strong></p><h4 id="（一）被诱入歧途的多Tab测试"><a href="#（一）被诱入歧途的多Tab测试" class="headerlink" title=" （一）被诱入歧途的多Tab测试"></a><center> （一）被诱入歧途的多Tab测试</center></h4><p>在微信横空出世之前，你不会觉得用手机短信聊天有什么不对，你甚至很习惯，也从来没想过改变，直到微信一巴掌扇过来。同样的，多Tab测试也是如此。</p><p>我们先来看一下多Tabs测试的典型场景：</p><p>通常页面有一个超链接，它有href属性，当你点击文本的时候，会跳转。例如下面这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//"iTesting"</span></div><div class="line">&lt;a href=<span class="string">"https://www.helloqa.com"</span> target=<span class="string">"_blank"</span>&gt;关注iTesting!&lt;/a&gt;</div></pre></td></tr></table></figure><p>很显然，当你点击“关注iTesting”，浏览器就会重新打开一个页面，页面的网址是“<a href="https://www.helloqa.com”" target="_blank" rel="external">https://www.helloqa.com”</a>. </p><p>在Cypress出现之前，Selenium/WebDriver， 作为Web端自动化测试的巨无霸，是这么告诉我们的，UI自动化测试要模拟真实用户，用户怎么做，你就怎么做。<br>于是乎，你要测试这个功能，你就要点击一下“关注iTesting”这个超链接，然后等页面跳转后，你再把句柄移到这个新页面，来判断页面的URL正确性。<br>这个逻辑好像挺对的，就是代码写起来好累，而且运行时还经常出错。</p><h4 id="（二）测试多Tab需要打开多Tab吗？"><a href="#（二）测试多Tab需要打开多Tab吗？" class="headerlink" title=" （二）测试多Tab需要打开多Tab吗？"></a><center> （二）测试多Tab需要打开多Tab吗？</center></h4><p>不知道你有没有想过，你费那么老大劲写代码，是为了验证如下两个事实：</p><ol><li>点击跳转这个功能正确。</li><li>跳转的新页面能打开。</li></ol><p>真正的实力在于不战而屈人之兵。同样的，真正的测试是“不真的测试”。</p><p>我们想一下，Cypress跟其它“平（yao）平（yan）无（jian）奇（huo）框架”相比，最大的特点是什么？运行在浏览器内对吧。 能够直接操作DOM元素对吧？既然如此，操练起来吧！</p><h4 id="（三）是时候表演真正的技术了"><a href="#（三）是时候表演真正的技术了" class="headerlink" title=" （三）是时候表演真正的技术了"></a><center> （三）是时候表演真正的技术了</center></h4><p>不废话了，看Cypress如何处理这种情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//"iTesting"</span></div><div class="line">cy</div><div class="line">  .contains(<span class="string">'关注iTesting'</span>)</div><div class="line">  .should(<span class="string">'have.attr'</span>, <span class="string">'href'</span>, <span class="string">'https://www.helloqa.com'</span>)</div><div class="line">  .should(<span class="string">'have.attr'</span>, <span class="string">'target'</span>, <span class="string">'_blank'</span>)</div></pre></td></tr></table></figure><p>这就完了？是的，这就完了！</p><p>如果你学过一点HTML的皮毛就会知道，target=_blank这个属性就是用来保证一定会打开新页面的。 而验证href是我期待的网址，一定能说明点击它就可以访问到“<a href="https://www.helloqa.com”" target="_blank" rel="external">https://www.helloqa.com”</a>.</p><p>什么，你怕这个网址打不开？好说！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//"iTesting"</span></div><div class="line">cy</div><div class="line">  .contains(<span class="string">'关注iTesting'</span>)</div><div class="line">  .should(<span class="string">'have.attr'</span>, <span class="string">'href'</span>, <span class="string">'https://www.helloqa.com'</span>)</div><div class="line">  .should(<span class="string">'have.attr'</span>, <span class="string">'target'</span>, <span class="string">'_blank'</span>)</div><div class="line">  </div><div class="line">cy</div><div class="line">  .contains(<span class="string">'关注iTesting'</span>)</div><div class="line">  .then(<span class="function"><span class="params">link</span> =&gt;</span> &#123;</div><div class="line">    cy</div><div class="line">      .request(link.prop(<span class="string">'href'</span>))</div><div class="line">      .its(<span class="string">'status'</span>)</div><div class="line">      .should(<span class="string">'eq'</span>, <span class="number">200</span>)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>直接发接口请求看HTTP Code返回，就这么生猛。在Cypress里，你永远不会看到测试用例时好时坏。</p><h4 id="（四）什么？打开新页面后还有操作？"><a href="#（四）什么？打开新页面后还有操作？" class="headerlink" title=" （四）什么？打开新页面后还有操作？"></a><center> （四）什么？打开新页面后还有操作？</center></h4><p>哎，蔡老师全部满足你：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//"iTesting"</span></div><div class="line">cy</div><div class="line">  .contains(<span class="string">'关注iTesting'</span>)</div><div class="line">  .should(<span class="string">'have.attr'</span>, <span class="string">'href'</span>, <span class="string">'https://www.helloqa.com'</span>)</div><div class="line">  .should(<span class="string">'have.attr'</span>, <span class="string">'target'</span>, <span class="string">'_blank'</span>)</div><div class="line">  </div><div class="line">cy</div><div class="line">  .contains(<span class="string">'关注iTesting'</span>)</div><div class="line">  .invoke(<span class="string">'removeAttr'</span>, <span class="string">'target'</span>).click()</div><div class="line"><span class="comment">// 请继续你的操作，此动作将会在当前页面打开超链接</span></div></pre></td></tr></table></figure><h4 id="（五）秀儿？是你么"><a href="#（五）秀儿？是你么" class="headerlink" title=" （五）秀儿？是你么"></a><center> （五）秀儿？是你么</center></h4><p>Cypress永远不满足一种解决方案，来，看高阶版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//"iTesting"</span></div><div class="line"><span class="comment">//spy来了，直接监视窗口打开</span></div><div class="line">cy</div><div class="line">  .window().then(<span class="function">(<span class="params">win</span>) =&gt;</span> &#123;</div><div class="line">    cy.spy(win, <span class="string">'open'</span>).as(<span class="string">'newWindow'</span>)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">cy</div><div class="line">  .contains(<span class="string">'关注iTesting'</span>)</div><div class="line">  .click()</div><div class="line"></div><div class="line">cy</div><div class="line">  .get(<span class="string">'@newWindow'</span>)</div><div class="line">  .should(<span class="string">'be.calledWith'</span>, <span class="string">'_blank'</span>, <span class="string">'https://www.helloqa.com'</span>)</div></pre></td></tr></table></figure><p>这才是使用Cypress正确的姿势啊！使用Cypress进行自动化测试，请优先考虑走后门。毕竟，Cypress可以访问任何你的应用程序可以访问的资源，那么，不如先“监控”下window打开这件小事儿：）</p><h4 id="（六）教练，我想打篮球"><a href="#（六）教练，我想打篮球" class="headerlink" title=" （六）教练，我想打篮球"></a><center> （六）教练，我想打篮球</center></h4><p>我知道你一定会问，所以我偷偷的给你准备了一个简单的题目，超级简单哦：</p><p>请访问如下页面，然后试着测试下这里的超链接。我相信，你一定会回来找我的：）</p><p><a href="https://www.w3schools.com/tags/tryit.asp?filename=tryhtml_a_target" target="_blank" rel="external">https://www.w3schools.com/tags/tryit.asp?filename=tryhtml_a_target</a></p><p>Cypress有很多奇淫巧技， 我已经总结超过百篇， 别走开，下一篇更精彩！</p><h4 id="往期回看："><a href="#往期回看：" class="headerlink" title="往期回看："></a>往期回看：</h4><p><a href="https://helloqa.com/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/" target="_blank" rel="external">你不知道的Cypress系列（1） –鸡肋的BDD</a></p><p><a href="https://helloqa.com/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（2） –该死的PO模型​</a></p><p><a href="https://helloqa.com/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/" target="_blank" rel="external">你不知道的Cypress系列（3） – 是时候重构你的思维了</a></p><p><a href="https://helloqa.com/2021/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20--%20%E2%80%9CPO%E2%80%9D%E5%B7%B2%E6%AD%BB%EF%BC%8CApp%20Action%E5%BD%93%E7%AB%8B/" target="_blank" rel="external">你不知道的Cypress系列（4） – “PO”已死，App Action当立</a></p><p><a href="https://helloqa.com/2021/03/19/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%975%E7%9C%BC%E7%9E%8E%E7%9A%84TestRunner%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（5） – 眼瞎的TestRunner​</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Cypress系列（5） -- 眼瞎的TestRunner​</title>
      <link href="/2021/03/19/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%975%E7%9C%BC%E7%9E%8E%E7%9A%84TestRunner%E2%80%8B/"/>
      <url>/2021/03/19/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%975%E7%9C%BC%E7%9E%8E%E7%9A%84TestRunner%E2%80%8B/</url>
      
        <content type="html"><![CDATA[<p>今天是&lt;你不知道的Cypress系列&gt;的第五篇 – 眼瞎的TestRunner​（<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>）。<br><a id="more"></a></p><p>自从我的新书 <a href="https://item.jd.com/12647091.html" target="_blank" rel="external"><font color="#0099ff" size="3" face="“黑体”">前端自动化测试框架 – Cypress从入门到精通</font></a>上市以来，这本书受到了大量同学热情的追捧和讨论。在跟同学们的交流中，我也了解到， 原来除了国外优秀的公司(例如Adobe, 迪士尼，AutoDesk等等）， 国内也有很多公司在尝试使用Cypress提升测试效率。而在Cypress中国群内、在公众号iTesting里，我每天都能看到大量关于Cypress的使用讨论和私下问询。这让我感到无比荣幸。</p><h4 id="（一）PageObject是什么"><a href="#（一）PageObject是什么" class="headerlink" title=" （一）PageObject是什么"></a><center> （一）PageObject是什么</center></h4><p>关于TestRunner, 我想大家都已经非常熟悉了。在我的的书中也有其各个用法的专门介绍，这里不再赘述。</p><p><img src="/2021/03/19/你不知道的Cypress系列/你不知道的Cypress系列5眼瞎的TestRunner​/1.png" alt=""> </p><p>仅再次列下其定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//关注微信公众号iTesting，与万人测试团体共同成长。</div><div class="line">TestRunner是一个独特的测试运行器。Cypress的所有命令通过它运行。</div><div class="line">通过TestRunner你可以观测到， 在某一个时刻：</div><div class="line">1. 哪些命令在执行。</div><div class="line">2. 这些命令在执行时，你的应用程序处于什么状态。</div></pre></td></tr></table></figure></p><p>Cypress八大特性里的时间穿梭能力，和可调试性能力，其实就是通过TestRunner来实现的。</p><h4 id="（二）Test-Runner两种运行模式"><a href="#（二）Test-Runner两种运行模式" class="headerlink" title=" （二）Test Runner两种运行模式"></a><center> （二）Test Runner两种运行模式</center></h4><p>Cypress有两种运行方式，分别是交互性运行（Interaction Mode），和无头（Headless Mode）运行。</p><p>区别一个是测试运行时你可以看到浏览器启动、执行测试。另一个是没有浏览器界面，你看不到运行过程。</p><p>无论是哪种方式运行，大家记得Cypress 是通过它内置的Test Runner来运行你的测试用例的就行。</p><h4 id="（三）什么，-TestRunner也会“瞎”？！"><a href="#（三）什么，-TestRunner也会“瞎”？！" class="headerlink" title=" （三）什么， TestRunner也会“瞎”？！"></a><center> （三）什么， TestRunner也会“瞎”？！</center></h4><p>没想到吧？刚开始我也是拒绝相信的。直到我发现我的测试用例还是会出现不稳定、随机失败的现象（Flaky Test）。怪了！不是说用了Cypress之后就不会有这种问题了么？于是我就寻仙访药啊，终于，找到了原因所在。先给大家看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">describe(<span class="string">'iTesting Demo'</span>, () =&gt; &#123;</div><div class="line">  it(<span class="string">'欢迎关注iTesting'</span>, () =&gt; &#123;</div><div class="line">    cy.visit(<span class="string">'/?delay=500'</span>)</div><div class="line">    cy.get(<span class="string">'.loading'</span>).should(<span class="string">'be.visible'</span>)</div><div class="line">    cy.get(<span class="string">'.loading'</span>).should(<span class="string">'not.be.visible'</span>)</div><div class="line">    cy.get(<span class="string">'li.todo'</span>).should(<span class="string">'have.length'</span>, <span class="number">2</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这是Cypress官网的一个用例，这个测试第一次成功，再次运行失败了。特别是你把它集成到CI上的时候，你大概率会看到这种失败。</p><p><img src="/2021/03/19/你不知道的Cypress系列/你不知道的Cypress系列5眼瞎的TestRunner​/2.gif" alt=""> </p><center> <font color="red" size="2" face="“黑体”">为什么会这样呢？</font></center><center> <font color="red" size="2" face="“黑体”">Test Runner “瞎”了！</font></center><h4 id="（四）TestRunner为什么会“瞎”"><a href="#（四）TestRunner为什么会“瞎”" class="headerlink" title=" （四）TestRunner为什么会“瞎”"></a><center> （四）TestRunner为什么会“瞎”</center></h4><p>我们知道，修复一个Bug的最好手段就是稳定重现它。怎么重现呢？ 先设定一个小目标，先运行它个20次试试： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">describe(<span class="string">'iTesting Demo'</span>, () =&gt; &#123;</div><div class="line">  Cypress._.times(<span class="number">20</span>, (k) =&gt; &#123;</div><div class="line">    it(<span class="string">`欢迎关注iTesting <span class="subst">$&#123;k&#125;</span>`</span>, () =&gt; &#123;</div><div class="line">      cy.visit(<span class="string">'/?delay=500'</span>)</div><div class="line">      cy.get(<span class="string">'.loading'</span>).should(<span class="string">'be.visible'</span>)</div><div class="line">      cy.get(<span class="string">'.loading'</span>).should(<span class="string">'not.be.visible'</span>)</div><div class="line">      cy.get(<span class="string">'li.todo'</span>).should(<span class="string">'have.length'</span>, <span class="number">2</span>)</div><div class="line">    &#125;)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><center> <font color="red" size="2" face="“黑体”">多次运行能够暴露出代码中的潜在问题，我建议所有要上CI运行的测试用例在提交到代码仓库时，都这样多次运行下！</font></center><p>这世界上啊，什么事都怕你有目的。果然目标一定，出现错误的次数就增加到过5次了。</p><p>那么我们确定，代码是有问题，再一眼一眼看吧。这个时候，有条件的你可能也要看下开发的代码如何写的。例如，visit的时候发生了什么， click的时候哪些事件被触发了？ 通过了解开发逻辑可以帮助你快速定位问题。</p><p>经过一番调查啊，猜测出问题的代码在第4行和第5行。当元素（类名”.loading“）加载速度过快时候，就大概率会引发失败。</p><p>来初步验证下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">describe(<span class="string">'iTesting Demo'</span>, () =&gt; &#123;</div><div class="line">  it(<span class="string">'欢迎关注iTesting'</span>, () =&gt; &#123;</div><div class="line">    cy.visit(<span class="string">'/?delay=500'</span>)</div><div class="line">    cy.get(<span class="string">'.loading'</span>).should(<span class="string">'be.visible'</span>)</div><div class="line">    cy.wait(<span class="number">1000</span>)</div><div class="line">    cy.get(<span class="string">'.loading'</span>).should(<span class="string">'not.be.visible'</span>)</div><div class="line">    cy.get(<span class="string">'li.todo'</span>).should(<span class="string">'have.length'</span>, <span class="number">2</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>哎，加了等待就不会出这个bug了。说明问题就在这里了：</p><center> <font color="red" size="2" face="“黑体”">也就是说，元素已经完成show的操作并且马上变成disappear了，但Cypress的Test Runner还没反应过来，还在检查元素show出来没。 </font></center><h4 id="（五）结论"><a href="#（五）结论" class="headerlink" title=" （五）结论"></a><center> （五）结论</center></h4><p>然后就是各种查资料， 最后发现Cypress早有结论：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 如果一个元素出现和消失的间隔在<span class="number">21</span>ms内，那么大概率TestRunner会“瞎”。</div></pre></td></tr></table></figure></p><p>有的同学可能会想， Test Runner看不见，有没有其它办法能看见？比如Cypress不是提供视频可以录制运行中的所有情况么？我把运行过程录制下来慢慢查不就行了？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 不行！标准的视频，是每秒<span class="number">30</span>帧， 每帧的标准间隔是<span class="number">33</span>ms。</div></pre></td></tr></table></figure></p><h4 id="（六）解决之道"><a href="#（六）解决之道" class="headerlink" title=" （六）解决之道 "></a><center> （六）解决之道 </center></h4><p>既然找到了Root cause,解决起来就简单了，有如下解法：</p><ol><li><p>加Sleep time</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 强烈不推荐， 用了我大Cypress，是不可能sleep的！</span></div><div class="line">cy.wait(<span class="number">1000</span>)</div></pre></td></tr></table></figure></li><li><p>使用cy.intercept等待网络请求返回并加装完成后再执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 强烈推荐！</span></div><div class="line">cy.intercept(<span class="string">'XXX你的代码'</span>).as(<span class="string">'myRequest'</span>)</div><div class="line">cy.wait(<span class="string">'@myRequest'</span>)</div><div class="line">xxxxx   <span class="comment">//  你的后续代码</span></div></pre></td></tr></table></figure></li><li><p>直接模拟服务器延迟返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//五星好评，强烈推荐！</span></div><div class="line"> cy.intercept(<span class="string">'/todos'</span>, &#123;</div><div class="line">   <span class="attr">fixture</span>: <span class="string">'todos.json'</span>,</div><div class="line">   <span class="attr">delayMs</span>: <span class="number">1000</span>,</div><div class="line"> &#125;)</div></pre></td></tr></table></figure></li></ol><p>Cypress有很多奇淫巧技， 我已经总结超过百篇,别走开，下一篇更精彩！</p><p>往期回看：<br>        <a href="https://helloqa.com/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/" target="_blank" rel="external">你不知道的Cypress系列（1） –鸡肋的BDD</a></p><p><a href="https://helloqa.com/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（2） –该死的PO模型​</a></p><p><a href="https://helloqa.com/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/" target="_blank" rel="external">你不知道的Cypress系列（3） – 是时候重构你的思维了</a></p><p><a href="https://helloqa.com/2021/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%884%EF%BC%89%20--%20%E2%80%9CPO%E2%80%9D%E5%B7%B2%E6%AD%BB%EF%BC%8CApp%20Action%E5%BD%93%E7%AB%8B/" target="_blank" rel="external">你不知道的Cypress系列（4） – “PO”已死，App Action当立</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Cypress系列（4） -- &quot;PO&quot;已死，App Action当立</title>
      <link href="/2021/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%974-PO%E5%B7%B2%E6%AD%BBAppAction%E5%BD%93%E7%AB%8B/"/>
      <url>/2021/02/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%974-PO%E5%B7%B2%E6%AD%BBAppAction%E5%BD%93%E7%AB%8B/</url>
      
        <content type="html"><![CDATA[<p>自从我的新书 <a href="https://item.jd.com/12647091.html" target="_blank" rel="external"><font color="#0099ff" size="3" face="“黑体”">前端自动化测试框架 – Cypress从入门到精通</font></a>上市以来，这本书受到了大量同学热情的追捧和讨论。在跟同学们的交流中，我也了解到， 原来除了国外优秀的公司(例如Adobe, 迪士尼，AutoDesk等等）， 国内也有很多公司在尝试使用Cypress提升测试效率。而在Cypress中国群内、在公众号iTesting里，我每天都能看到大量关于Cypress的使用讨论和私下问询。这让我感到无比荣幸。[<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>]。</p><p>除了日常推荐大家通过阅读我的书来解决日常Cypress使用问题外，我也一直在更新着我这边的Cypress知识图谱， 不夸张的说，目前我总结和实践下来知识点多达200多篇。本着“雕琢自我，普惠他人”的原则，我决定在公众号iTesting上开设&lt;你不知道的Cypress系列&gt;专栏。此专栏目的是分享一些我自己趟过的坑，走过的弯路、以及在选型时抛弃了的实践。希望让大家在选用Cypress作为前端自动化测试框架方案时， 可以借鉴一下，避免再走我走过的弯路。</p><p>今天是&lt;你不知道的Cypress系列&gt;的第四篇 –  “PO”已死，App Action当立’！</p><a id="more"></a><h4 id="（一）PageObject是什么"><a href="#（一）PageObject是什么" class="headerlink" title=" （一）PageObject是什么"></a><center> （一）PageObject是什么</center></h4><h5 id="01-赋值不起作用"><a href="#01-赋值不起作用" class="headerlink" title="01 赋值不起作用"></a><center>01 赋值不起作用</center></h5><p>关于PageObject，我在<a href="https://helloqa.com/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/" target="_blank" rel="external">你不知道的Cypress系列（2） –该死的PO模型​</a>中有过比较清晰的描述。这里就不再赘述。</p><p>可以明确的是，<font color="red" size="4" face="“黑体”">Cypress不提倡PageObject，并不是因为PageObject模型不好</font>，而是因为由于Cypress运行原理的独特性，使用PageObject模型，一定程度上阻止了Cypress做的更好，这句话怎么理解？这就不得不说到App Action这个模型了。</p><h5 id="02-什么是App-Action"><a href="#02-什么是App-Action" class="headerlink" title="02 什么是App Action"></a><center>02 什么是App Action</center></h5><p>相信大家听了我那么多次鼓吹Cypress，早已知道，Cypress是市面上为数不多的没有使用JSON Wire Protocol（WebDriver及99%其它自动化框架的核心协议）的框架。Cypress运行在浏览器之内，并且和你的应用程序运行在同一生命周期，这意味着Cypress可以直接访问和控制应用程序本身的行为。</p><font color="red" size="4" face="“黑体”">而这种直接控制应用程序到达要测试所需状态的能力，就是“App Action”。</font><p></p><p>这句话同样不好理解，我举个例子，假设我要测试一个页面功能，这个功能是付款成功后，会随机出现一个优惠券供我下次使用。我要测试这个优惠券在付款成功后会出现，并且可以领取。自动化测试为了保证测试用例的原子性，我：</p><h6 id="提前准备好账户："><a href="#提前准备好账户：" class="headerlink" title="提前准备好账户："></a>提前准备好账户：</h6><p>要么准备一个账户，这个账户有余额， 并且这个账户永远有我要的商品在购物车，等着我付款（大家知道这不可能）。</p><h6 id="每次新建账户："><a href="#每次新建账户：" class="headerlink" title="每次新建账户："></a>每次新建账户：</h6><p>要么注册一个账户，用这个账户登录，充钱，添加商品，然后加购物车，然后付款，最后检查优惠券页面。<br>注意：我的测试要求是测试付款成功后的优惠券页面。那么这个动作抽象一下就是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//"iTesting"</span></div><div class="line"><span class="number">1.</span> 付款及其前置动作</div><div class="line"><span class="number">2.</span> 优惠券页面（真正的测试项）</div></pre></td></tr></table></figure></p><p>在我们实际测试中，我们经常会发现，可能整个测试写了100行代码。测试付款后，检查优惠券的动作只有10行代码，其它90行都是动作1，即我们花大量时间在做付款及其前置动作。<br> <strong><center>有没有觉得有点本末倒置？</center></strong></p><p> 如果有一种办法，可以让我们的应用程序直接到达优惠券页面，我的代码是不是只需要10行？是不是就避免了很多无效的操作？是不是运行速度上可以更快，而且我可以只关注我要测试的部分？</p><font color="red" size="4" face="“黑体”">这种直接控制应用程序到达要测试所需状态的能力，就是“App Action”。</font><h5 id="03-App-Action举例"><a href="#03-App-Action举例" class="headerlink" title="03 App Action举例"></a><center>03 App Action举例</center></h5><p>Cypress提供给我们一个应用程序供练习，如下图所示：</p><p><img src="/2021/02/22/你不知道的Cypress系列/你不知道的Cypress系列4-PO已死AppAction当立/0.gif" alt=""></p><p>假设我要测试登录，那么正常情况下，我的操作是下面这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//&quot;iTesting&quot;</div><div class="line">1. 打开首页。</div><div class="line">2. 点击右上角的Login。</div><div class="line">3. 在弹出的Login对话框中输入用户名，密码登录。</div></pre></td></tr></table></figure><p>我的代码是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">it(&apos;iTesting Demo&apos;, () =&gt; &#123;</div><div class="line"></div><div class="line">  cy</div><div class="line">    .visit(&apos;/&apos;);</div><div class="line"></div><div class="line">// 7到 13 行是Login的前置条件。</div><div class="line">  cy</div><div class="line">    .get(&apos;[data-cy=&quot;login-menu&quot;]&apos;)</div><div class="line">    .click();</div><div class="line"></div><div class="line">  cy</div><div class="line">    .get(&apos;[data-cy=&quot;login-module&quot;]&apos;)</div><div class="line">    .should(&apos;be.visible&apos;);</div><div class="line"></div><div class="line">//真正的Login 从这里开始</div><div class="line">  cy</div><div class="line">    .get(&apos;[data-cy=&quot;login-email&quot;]&apos;)</div><div class="line">    .type(&apos;iTesting@YouMustFollow.com&apos;);</div><div class="line"></div><div class="line">  cy</div><div class="line">    .get(&apos;[data-cy=&quot;login-password&quot;]&apos;)</div><div class="line">    .type(&apos;Password&apos;);</div><div class="line"></div><div class="line">  cy</div><div class="line">    .get(&apos;[data-cy=&quot;login&quot;]&apos;)</div><div class="line">    .click();</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>由于Cypress可以直接访问应用程序资源，并且可以控制应用程序状态，那么使用“App Action”的操作就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. 打开首页。</div><div class="line">2. Cypress直接操作应用程序打开Login界面。</div><div class="line">3. 输入用户名，密码继续测试。</div></pre></td></tr></table></figure></p><p>使用Applicaiton Action的代码就是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">it(&apos;iTesting Demo&apos;, () =&gt; &#123;</div><div class="line">  cy</div><div class="line">    .visit(&apos;/&apos;);</div><div class="line"> </div><div class="line"> // Magic! Cypress通过将应用程序窗口暴露出来，从而直接访问应用</div><div class="line"> // 程序本身的各种方法。 实现我们一会讲。  </div><div class="line">  cy</div><div class="line">    .window()</div><div class="line">    .then((&#123; app &#125;) =&gt; &#123;</div><div class="line">      app.showLoginModule = true;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    </div><div class="line"> //真正的Login，从这里开始</div><div class="line">  cy</div><div class="line">    .get(&apos;[data-cy=&quot;login-email&quot;]&apos;)</div><div class="line">    .type(&apos;iTesting@YouMustFollow.com&apos;);</div><div class="line"></div><div class="line">  cy</div><div class="line">    .get(&apos;[data-cy=&quot;login-password&quot;]&apos;)</div><div class="line">    .type(&apos;Password&apos;);</div><div class="line"></div><div class="line">  cy</div><div class="line">    .get(&apos;[data-cy=&quot;login&quot;]&apos;)</div><div class="line">    .click();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>由此可见，使用了App Action， 我们可以直接指定应用程序到达测试需要的状态，而不必再做无关的操作。</p><p>那么，这个是怎么实现的呢？</p><h4 id="04-App-Action如何实现"><a href="#04-App-Action如何实现" class="headerlink" title="04 App Action如何实现"></a><center>04 App Action如何实现</center></h4><p>我们来看下关键代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line">// Magic! Cypress通过将应用程序窗口暴露出来，从而直接访问应用</div><div class="line">// 程序本身的各种方法。实现我们一会讲。</div><div class="line">cy</div><div class="line">  .window()</div><div class="line">  .then((&#123; app &#125;) =&gt; &#123;</div><div class="line">    app.showLoginModule = true;</div><div class="line">  &#125;);</div></pre></td></tr></table></figure><p>这段代码直接把Login窗口打开了，而不是通过页面操作打开。为什么这样可以呢？</p><p>这就不得不说到应用程序源码了：<br><img src="/2021/02/22/你不知道的Cypress系列/你不知道的Cypress系列4-PO已死AppAction当立/1.gif" alt=""></p><p>从上图可以看到，这个应用程序是Vue的（React和Angular原理类似），通过Vue DevTools我们可以看出来，是属性showLoginModule控制Login窗口的出现。</p><p>而如果我们能把应用打开的窗口（及其支持的方法）暴露给浏览器的Window对象，那么我们就可以通过cy.window来获取。</p><p><strong><center>具体怎么做呢？</center></strong></p><p>在入口文件main.js里, 在初始化vue实例后，把我们的app实例暴露给window context就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const app = new Vue(&#123;</div><div class="line">  // ...</div><div class="line">&#125;).$mount(&apos;#Example-app&apos;);</div><div class="line">// 上面是正常的vue代码。</div><div class="line"></div><div class="line"> // 起作用的是，添加了如下一行。</div><div class="line">window.app = app;</div></pre></td></tr></table></figure></p><p>这样做了后，当应用程序在浏览器中打开时，你可以直接通过window.app来设置所有app支持的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.app.showLoginModule = true</div></pre></td></tr></table></figure></p><p>因为window我们已经完全拿到了，所以我们可以直接用cypress来操作Login窗口的关闭和打开。<br>所以，下面的关键代码在Cypress测试中可以直接使用！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Magic! Cypress通过将应用程序窗口暴露出来，从而直接访问应用</div><div class="line">// 程序本身的各种方法。实现我们一会讲。</div><div class="line"> cy</div><div class="line">   .window()</div><div class="line">   .then((&#123; app &#125;) =&gt; &#123;</div><div class="line">     app.showLoginModule = true;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p><p>Login 窗口可以直接被唤起，一秒直达测试状态，这个感觉只有Cypress能给你有没有？：）</p><h4 id="05-为什么App-Action流行不起来？"><a href="#05-为什么App-Action流行不起来？" class="headerlink" title="05 为什么App  Action流行不起来？"></a><center>05 为什么App  Action流行不起来？</center></h4><p>看到这里，你应该明白使用Cypress的最大好处了吧？你可以直接调用应用程序里的方法来设置你应用程序当前的状态，是不是心潮澎湃啊！这样一来，还需要什么数据准备？还需要什么前置操作，直捣黄龙有没有？</p><p>”桥逗麻袋“， 好像哪里不对？</p><p>这就对了，这就是App  Action流行不起来的原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line"></div><div class="line">1. 测试人员没有那么强的代码能力，去根据开发的代码写Cypress代码。</div><div class="line">2. 开发人员未必愿意配合你做这些。</div></pre></td></tr></table></figure></p><p>所以， 大部分测试人员只能直接从UI去操作，虽杀鸡用牛刀也是不得已。</p><h4 id="06-总结"><a href="#06-总结" class="headerlink" title="06 总结"></a><center>06 总结</center></h4><p>从自动化测试效率上来说，App Action一定是超越Page Object模型的。从测试脚本稳定性，运行时长等因素来看，App  Action也是一骑绝尘。</p><p>但是， 任何技术理论提出的太早，不一定是好事儿，受制于广大人测试人员的认知和技术水平， 虽然App  Action带来的震撼犹如哥白尼的日心说，但是“地球是宇宙的中心”，测试代码在可见的范围内，也仍然是由测试人员来写， 所以， 忘记App  Action，继续拥抱PageObject吧  :(</p><font color="red" size="4" face="“黑体”">Cypress强推的App  Action非常适合那种敏捷型“精英小分队”，即团队的每个人都是多面手，具备一定的开发能力，否则，App  Action只能是水中月，美则美矣，实操性难。<br></font><h4 id="Cypress测试你的代码，而不是你的耐心！-买了书的同学们，公众号回复你的微信，拉你到Cypress中国群"><a href="#Cypress测试你的代码，而不是你的耐心！-买了书的同学们，公众号回复你的微信，拉你到Cypress中国群" class="headerlink" title="Cypress测试你的代码，而不是你的耐心！(买了书的同学们，公众号回复你的微信，拉你到Cypress中国群)"></a>Cypress测试你的代码，而不是你的耐心！(<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>)</h4><p>往期回看：<br>        <a href="https://helloqa.com/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/" target="_blank" rel="external">你不知道的Cypress系列（1） –鸡肋的BDD</a></p><p><a href="https://helloqa.com/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（2） –该死的PO模型​</a></p><p><a href="https://helloqa.com/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/" target="_blank" rel="external">你不知道的Cypress系列（3） – 是时候重构你的思维了</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Cypress系列（3） -- 是时候重构自己的思维了</title>
      <link href="/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/"/>
      <url>/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>自从我的新书 <a href="https://item.jd.com/12647091.html" target="_blank" rel="external"><font color="#0099ff" size="3" face="“黑体”">前端自动化测试框架 – Cypress从入门到精通</font></a>上市以来，这本书受到了大量同学热情的追捧和讨论。在跟同学们的交流中，我也了解到， 原来除了国外优秀的公司(例如Adobe, 迪士尼，AutoDesk等等）， 国内也有很多公司在尝试使用Cypress提升测试效率。而在Cypress中国群内、在公众号iTesting里，我每天都能看到大量关于Cypress的使用讨论和私下问询。这让我感到无比荣幸。（<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>）。</p><p>除了日常推荐大家通过阅读我的书来解决日常Cypress使用问题外，我也一直在更新着我这边的Cypress知识图谱， 不夸张的说，目前我总结和实践下来知识点多达200多篇。本着“雕琢自我，普惠他人”的原则，我决定在公众号iTesting上开设&lt;你不知道的Cypress系列&gt;专栏。此专栏目的是分享一些我自己趟过的坑，走过的弯路、以及在选型时抛弃了的实践。希望让大家在选用Cypress作为前端自动化测试框架方案时， 可以借鉴一下，避免再走我走过的弯路。</p><p>今天是&lt;你不知道的Cypress系列&gt;的第三篇 –  是时候重构自己的思维了！</p><a id="more"></a><p>由于Selenium/WebDriver的“荼毒”， 当前在自动化过程中，很多不合理的操作，反而都变成了标准流程。<br>例如，要进行元素属性值比较，我们首先想到的就是先赋值，再比较。<br>再比如，自动化过程中，常常会陷入”条件测试（Conditional Testing）“的陷阱！ 例如，我见过太多这样的case：”如果我点击了某button，如果弹出框没有出现，我执行A操作，如果出现，我执行B操作“。<br>由于这种“荼毒”，初次使用Cypress时， 大多数同学都会认为自己掉进坑里了！</p><h4 id="（一）诡异的赋值"><a href="#（一）诡异的赋值" class="headerlink" title=" （一）诡异的赋值"></a><center> （一）诡异的赋值</center></h4><h5 id="01-赋值不起作用"><a href="#01-赋值不起作用" class="headerlink" title="01 赋值不起作用"></a><center>01 赋值不起作用</center></h5><p>赋值操作是最常见的了，赋值最常用的场景是获取元素的某个属性供以后使用。</p><p>没接触过JavaScript的同学，在第一次写Cypress脚本时，一定会遇见如下问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">describe(&apos;欢迎关注iTesting&apos;, function () &#123;</div><div class="line"></div><div class="line">    it(&apos;你以为的赋值&apos;, function () &#123;</div><div class="line">        // 定义变量那么，用来获取button的text是什么</div><div class="line">        let name</div><div class="line">        cy.visit(&apos;/login&apos;)</div><div class="line">        //关注公众号iTesting, 玩转Cypress</div><div class="line">        cy.get(&apos;button[type=&quot;submit&quot;]&apos;).then(obj =&gt; &#123;</div><div class="line">            name = obj.text()</div><div class="line">            // 第一次打印</div><div class="line">            cy.log(&apos;循环内有值&apos;, name)</div><div class="line">        &#125;)</div><div class="line">        // 第二次打印</div><div class="line">        cy.log(&apos;循环外没有值&apos;, name)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>如上述代码所示，我定义了一个变量name，并尝试把submit button的text即“Submit” 赋值给name。 上面的代码看起来没有任何毛病，但是运行时，你会发现我第一次打印时有值， 但是二次打印时name的值是null。</p><h5 id="02-赋值不起作用的原因"><a href="#02-赋值不起作用的原因" class="headerlink" title="02 赋值不起作用的原因"></a><center>02 赋值不起作用的原因</center></h5><p>写惯了Python或Java的同学往往会卡在这里觉得莫名其妙。其实也就是同步执行和异步执行的差异了。</p><h5 id="同步执行："><a href="#同步执行：" class="headerlink" title="同步执行："></a>同步执行：</h5><p>可以简单理解为，当你执行一个操作，在这个操作没有结果之前，其后续的操作不会执行。</p><h5 id="异步执行："><a href="#异步执行：" class="headerlink" title="异步执行："></a>异步执行：</h5><p>可以简单理解为，当你执行一个操作后，其后续的操作可以立即执行， 当这个操作有结果后，再通过状态，通知或者回调来通知这个操作的调用方。<br>这个解释相当之不准确，不过也足够我们继续下面的内容了。   你如果感兴趣， 可以搜索同步、异步、阻塞、非阻塞来了解更多进程通信和系统调用的知识。<br>正常情况下，Python代码，Java代码就是同步执行的，JavaScript代码就是异步执行的。<br>了解了这一点，你就明白了，当执行到第13行时，name的值还没有被返回，所以打印不出来。</p><h5 id="03-99-的情况都无须赋值"><a href="#03-99-的情况都无须赋值" class="headerlink" title="03 99%的情况都无须赋值"></a><center>03 99%的情况都无须赋值</center></h5><p>使用Selenium/WebDriver比较熟悉的同学，初次转到Cypress后，很容易就自无劝退：”Cypress好难用， 我还是用回Selenium/WebDriver“吧。 </p><p>拿对元素属性值进行断言为例，大家很容易就沿用Selenium/WebDriver时代的旧思维，认为，必须先拿出元素的属性值赋给一个变量，然后在用这个变量跟给定的期望结果对比。实际上，根本无需如此！</p><p>在Cypress中，99%的操作都无须赋值！</p><p>下面分别举例：</p><h5 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium/WebDriver"></a>Selenium/WebDriver</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//获取元素的属性值,并比较</div><div class="line">value = driver.find_element_by_id(&apos;kw&apos;).get_attribute(&apos;innerHTML&apos;)</div><div class="line">assert value == &quot;iTesting&quot;</div></pre></td></tr></table></figure><h5 id="Cypress："><a href="#Cypress：" class="headerlink" title="Cypress："></a>Cypress：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取元素的属性值，并比较</div><div class="line">cy.get(&apos;#kw&apos;).should(&apos;have.text&apos;, &apos;iTesting&apos;)</div></pre></td></tr></table></figure><p>就这么简单！</p><h5 id="（二）Cypress命令是如何运行的？"><a href="#（二）Cypress命令是如何运行的？" class="headerlink" title="（二）Cypress命令是如何运行的？"></a><center>（二）Cypress命令是如何运行的？</center></h5><h4 id="01"><a href="#01" class="headerlink" title="01"></a><center>01</center></h4><p>先来看一个大家常常会犯的错误：</p><p>假设我们定义了一个自定义方法login，最后返回登录后的凭证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line">// cypress/support/index.ts</div><div class="line">Cypress.Commands.add(&apos;login&apos;, (username， password) =&gt; &#123;</div><div class="line">  //各种代码实现登录</div><div class="line">  // 后返回登录凭证</div><div class="line">  return auth</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>然后在测试用例里，经常看到这样的使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const auth = cy.login(&quot;iTesting&quot;, &quot;iTesting&quot;)</div></pre></td></tr></table></figure></p><p>最后会发现auth的值是undefined，很多人百撕不得骑姐。</p><h5 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h5><font color="red" size="4" face="“黑体”">这是因为Cypress命令在它们被调用时不会执行任何操作。它们会自我排队（“enqueue themselves”），最后在统一运行。</font><p>来看下官方的解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line"></div><div class="line">it(&apos;iTesting邀你看Cypres如何运行&apos;, () =&gt; &#123;</div><div class="line">  cy.visit(&apos;/my/resource/path&apos;) // 啥也不干</div><div class="line"></div><div class="line">  // 关注iTesting，玩转Cypress</div><div class="line">  cy.get(&apos;.awesome-selector&apos;)   // 还是啥也不干</div><div class="line">    .click()                    // 必须啥也不干</div><div class="line"></div><div class="line">  cy.url()                      // 别想了，就是不干</div><div class="line">    .should(&apos;include&apos;, &apos;/hello&apos;) // 就在此刻，干！</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 好了，运行完了， 哦， 你真是一个快枪手。</div><div class="line">// 事实上，所有的Cypress命令会被queue起来，直到所有命令被chain完毕。</div><div class="line">// 然后Cypress开始按它们被queue的顺序开始运行。</div></pre></td></tr></table></figure></p><p>这个就是Cypress的魔力。这就是为什么JavaScript是异步执行的，但是Cypress命令却能按照你的代码“顺序“执行的原因！</p><h4 id="01-1"><a href="#01-1" class="headerlink" title="01"></a><center>01</center></h4><p>那么，知道了Cypress命令是如何运行的，再来看上面的登录例子，你就知道了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const auth = cy.login(&quot;iTesting&quot;, &quot;iTesting&quot;)</div></pre></td></tr></table></figure></p><p>cy.login没有被执行，当然auth里就没有值了。</p><p>那么，如何才能确保cy.login被执行呢？</p><p>为了让你能够访问到Cypress命令执行的结果，Cypress提供了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.then()</div></pre></td></tr></table></figure></p><p>.then是闭包的一个典型应用。（如果想深入理解，可以查下Promise）</p><p>所以，这下，我们知道要访问cy.login的返回值，我们应该这样用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cy.login(&quot;iTesting&quot;, &quot;iTesting&quot;).then( auth =&gt; &#123;</div><div class="line">const secret = auth</div><div class="line">//剩余用到auth的代码。</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这下，你就能愉快的使用Cypress命令的返回值了，不过也带来一个问题，就是代码层次比较深。。。</p><h4 id="（三）拒绝条件测试"><a href="#（三）拒绝条件测试" class="headerlink" title="（三）拒绝条件测试"></a><center>（三）拒绝条件测试</center></h4><h4 id="01-2"><a href="#01-2" class="headerlink" title="01"></a><center>01</center></h4><p>前面我提到了条件测试（Conditional Testing），实际上，条件测试常见常景如下：</p><ol><li>我想在元素存在或者不存在时，执行不同的操作。</li><li>我的应用程序有A/B Testing，我需要测试到不同的分支。<br>为了实现这个功能，在Selenium/WebDriver编程中，我们大量使用if…else，我们以为我们Cover住这种情况了，结果我们就发现我们的测试会薛定谔成功：有时候执行能成功，有时候执行不成功， 在你不执行的时候你永远不知道到底执行能不能成功。</li></ol><p>我们来看一个例子：<br>假设你的应用程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 你的应用程序代码</div><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line"></div><div class="line">// 定义一个随机时间</div><div class="line">const random = Math.random() * 100</div><div class="line"></div><div class="line">// 创建一个 &lt;button&gt; 元素</div><div class="line">const btn = document.createElement(&apos;button&apos;)</div><div class="line"></div><div class="line">//关注iTesting，玩转Cypress</div><div class="line">// attach 这个元素到body上</div><div class="line">document.body.appendChild(btn)</div><div class="line"></div><div class="line">setTimeout(() =&gt; &#123;</div><div class="line">  // 在random的时间内，给btn一个类属性。</div><div class="line">  btn.setAttribute(&apos;class&apos;, &apos;active&apos;)</div><div class="line">&#125;, random)</div></pre></td></tr></table></figure></p><p>你的测试代码就会如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line"></div><div class="line">it(&apos;薛定谔的测试&apos;, () =&gt; &#123;</div><div class="line"> // 多执行几遍，你发现，有时候btn的属性是active，有时候不是active。</div><div class="line">  cy.get(&apos;button&apos;).then(($btn) =&gt; &#123;</div><div class="line">    if ($btn.hasClass(&apos;active&apos;)) &#123;</div><div class="line">      //  active时的代码</div><div class="line">    &#125; else &#123;</div><div class="line">      // 非active的代码</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这也是Selenium/WebDriver被诟病的原因之一，不稳定！</p><h4 id="02"><a href="#02" class="headerlink" title="02"></a><center>02</center></h4><p>为了避免这个情况，Cypress告诉你， 不要去做条件测试（Conditional Testing）！</p><p>Cypress说，既然你在测试，那么你就应该知道你的每一步下去，其结果是什么。如果你不能确定你的操作下去结果是什么，那么你就不是在测试！（没毛病吧）</p><p>相应的，你就要调整你的测试策略，尽量避免让自己的代码处于条件测试（Conditional Testing）下， 具体来说就一句话：</p><h4 id="事先做一些操作，确保你的某个操作一定只有一个结果！"><a href="#事先做一些操作，确保你的某个操作一定只有一个结果！" class="headerlink" title="事先做一些操作，确保你的某个操作一定只有一个结果！"></a>事先做一些操作，确保你的某个操作一定只有一个结果！</h4><p>如何做到呢？别忘记，Cypress是运行在浏览器之内的，是跟你的应用程序运行在同一个生命周期的，你对你的应用程序有完全的控制权！</p><p>听起来很好，不过很可惜。这句话主要是对开发说的，对我们QA来说，用处不大（因为我们QA还是不知道改哪行代码啊！）。 </p><p>不过，这里还是有一些原则， 比如：</p><ol><li>A/B Testing， 可以根据AB的策略，构造出一定会走A逻辑的测试数据。</li><li>判断元素在不在，一定可以根据业务知道你的什么操作，它一定会在。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><center>总结</center></h4><p>当你初次使用Cypress时，特别是当你是从Selenium/WebDrvier转到Cypress来时，你一定会感觉到不习惯。这是必然的。<br>当你遇见问题时，不妨尝试转换下思维，把老的思维模式抛弃掉，转入到Cypress的思维中来，毕竟，我们做测试是为了：</p><h4 id="测试你的代码，而不是你的耐心！-买了书的同学们，公众号回复你的微信，拉你到Cypress中国群"><a href="#测试你的代码，而不是你的耐心！-买了书的同学们，公众号回复你的微信，拉你到Cypress中国群" class="headerlink" title="测试你的代码，而不是你的耐心！(买了书的同学们，公众号回复你的微信，拉你到Cypress中国群)"></a>测试你的代码，而不是你的耐心！(<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>)</h4><p>往期回看：<br>        <a href="https://helloqa.com/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/" target="_blank" rel="external">你不知道的Cypress系列（1） –鸡肋的BDD</a></p><p><a href="https://helloqa.com/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（2） –该死的PO模型​</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Cypress系列（2） -- 该死的PO模型​</title>
      <link href="/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/"/>
      <url>/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/</url>
      
        <content type="html"><![CDATA[<p>自从我的新书 <a href="https://item.jd.com/12647091.html" target="_blank" rel="external"><font color="#0099ff" size="3" face="“黑体”">前端自动化测试框架 – Cypress从入门到精通</font></a>上市以来，这本书受到了大量同学热情的追捧和讨论。在跟同学们的交流中，我也了解到， 原来除了国外优秀的公司(例如Adobe, 迪士尼，AutoDesk等等）， 国内也有很多公司在尝试使用Cypress提升测试效率。而在Cypress中国群内、在公众号iTesting里，我每天都能看到大量关于Cypress的使用讨论和私下问询。这让我感到无比荣幸。（<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>）。</p><p>除了日常推荐大家通过阅读我的书来解决日常Cypress使用问题外，我也一直在更新着我这边的Cypress知识图谱， 不夸张的说，目前我总结和实践下来知识点多达200多篇。本着“雕琢自我，普惠他人”的原则，我决定在公众号iTesting上开设&lt;你不知道的Cypress系列&gt;专栏。此专栏目的是分享一些我自己趟过的坑，走过的弯路、以及在选型时抛弃了的实践。希望让大家在选用Cypress作为前端自动化测试框架方案时， 可以借鉴一下，避免再走我走过的弯路。</p><p>今天是&lt;你不知道的Cypress系列&gt;的第二篇 –  绝知此事要躬行，别被Cypress官方忽悠瘸了！</p><p>为了让大家看到标题就知道我再说什么，我把标题更改为：</p><p>你不知道的Cypress系列（2） – ”该死”的PO模型</p><a id="more"></a><h4 id="01-PO模型是什么"><a href="#01-PO模型是什么" class="headerlink" title="01 PO模型是什么"></a><center>01 PO模型是什么</center></h4><p>无论你基于何种自动化测试框架开发你的测试脚本，PO模型绝对是你绕不过的坎儿。</p><p>PO模型（Page Object Module）算得上自动化测试的最佳实践之一，其中心思想如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">把物理上的页面或者逻辑上的功能组合当成一个Page 类处理。</div><div class="line"></div><div class="line">针对每一个Page类，将此Page上所属的元素、此Page类上元素动作的组合分别封装成Object， 以及Class Methods。</div><div class="line"></div><div class="line">所有针对此页面的操作以Page 类的实例引用。</div></pre></td></tr></table></figure></p><p>从代码实现上来看，元素、元素操作、 Page类、Page类对应的测试类就是PO。</p><p>实现PO模型后，测试用例的操作细节会被隐藏，转而以面向对象，或者说，以业务角度展示操作步骤，我们直接看一个PO封装后的测试用例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import LoginPage from &quot;../pages/login&quot;</div><div class="line">import mainPage from &quot;../pages/main&quot;</div><div class="line"></div><div class="line"></div><div class="line">describe(&apos;PageObject模式之登录测试&apos;, function () &#123;</div><div class="line">// 关注公众号iTesting，玩转Cypress</div><div class="line">const username = &apos;iTesting&apos;</div><div class="line">const password = &apos;password123&apos;</div><div class="line"></div><div class="line">    it(&apos;登录成功&apos;, function () &#123;</div><div class="line">const loginInstance = new LoginPage()</div><div class="line">        loginInstance.visitPage()</div><div class="line">          .isTargetPage()</div><div class="line">          .login(username, password)</div><div class="line"></div><div class="line">const mainInstance = new mainPage()</div><div class="line">        mainInstance.isTargetPage()</div><div class="line">          .welComeText.should(&apos;contain&apos;, &apos;iTesting&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>从业务角度看，PO模型非常直观：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">初始化LoginPage实例</div><div class="line">访问LoginPage</div><div class="line">判断LoginPage可访问</div><div class="line">登录</div><div class="line"></div><div class="line">接着访问mainPage（登录后会跳转的页面）</div><div class="line">判断mainPage可访问</div><div class="line">在mainPage上断言</div></pre></td></tr></table></figure></p><h4 id="02-PO模型的好处"><a href="#02-PO模型的好处" class="headerlink" title="02 PO模型的好处"></a><center>02 PO模型的好处</center></h4><p>由上文可以看到， PO模型的目的，主要是为了重用元素，做到每个元素定位、每个元素、甚至每个类方法，在整个项目中，有且仅有一处定义，其它都是调用。通过这样的方式，PO模型做到了即使在复杂项目中，也不会增加维护成本。</p><p>除此之外，在当前微服务开发模式下，动辄十几个、几十个微服务会同步进行开发。那么，过去那种一个测试工程师搞定所有自动化测试的机会不再有了。当前大多数公司的实践是将测试框架收归专门团队负责，而将自动化脚本的编写下放到各微服务团队。对应的， 各个团队下的业务测试工程师要具体负责其微服务的自动化测试。</p><p>PO模型天然带来一个好处，即，Page类天然隔离了模块和团队。例如我是团队A的测试工程师，除去公用Page外，我只需要关注我这个微服务下的所有Page类及类方法即可。而不必关心其它团队所own的页面。</p><p>如果我对其它组的服务有依赖，这些通常会构建专门的函数并成为Common Page的一部分。</p><p>如果有新人进来，他的学习成本只是我们团队负责的页面 + 公用Page，相对来说比较友好。</p><h4 id="03-Cypress怎么看PO模型"><a href="#03-Cypress怎么看PO模型" class="headerlink" title="03 Cypress怎么看PO模型"></a><center>03 Cypress怎么看PO模型</center></h4><p>正如Cypress官方所宣扬的一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// The page object pattern isn’t actually anything “special”.</div></pre></td></tr></table></figure></p><p>换句话说， Page Object只是方便重用而已，没什么大不了。</p><p>Cypress官方觉得Page Object模型里的大量Page类及其对应的测试类的使用，会加重调用链条，隐藏各个操作之间的动作细节，加重使用者的负担， 具体来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">       1. 使用PO模型人为的在测试中引入了其他状态，这些状态是你（测试脚本创建者）自己定义的，而不是应用程序内部拥有的， 它增加了debug成本。</div><div class="line"></div><div class="line">// 这个假设是成立的，因为程序内部并没有Page，更遑论Page里的方法。</div><div class="line">// 那么当你运行失败时发现，Page.addWallet失败了，你无法直接知道哪里出错</div><div class="line">// 你必须找到addWallet的定义，再去查看其实现，才能知道哪里错。</div><div class="line">       2. 使用PO模型使得测试速度变慢。</div><div class="line"></div><div class="line">// 这也是事实。</div><div class="line">// 毕竟你每次操作都要先initial Page实例，然后再寻找类方法，最后才是执行。</div><div class="line">       3.   使用PO模型使代码陷入“Conditional Testing”的怪圈。</div><div class="line"></div><div class="line">// 比如你的方法里存在如下判断：</div><div class="line">// 如果页面发生AAA， 你会进行BBB操作， 如果发生CCC，你会进行DDD操作。</div><div class="line">// 这在Cypress看来是反模式。因为Cypress跟你的应用程序运行在同一个生命周期。</div><div class="line">// Cypress可以捕获应用程序里发生的一切。</div><div class="line">// 所以，你理应知道你的操作引发的结果到底是AAA还是CCC。</div></pre></td></tr></table></figure></p><p>这3条， 条条剑指PO模型的七寸。</p><p>Cypress官方又说，好既然PO不好用， 而且它存在只是为了方便重用，那么我给你更好的办法：</p><p>于是Custom Commands出炉了。Custom Commands你可以看成是PO模型里的Common Page。所有在Custom Commands里定义的方法，天生可以被任何测试之间调用。相当于你生成了自己的全局命令.</p><p>来看一个Custom Commands的具体例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Cypress.Commands.add(&apos;login&apos;, (username, password) =&gt; &#123;</div><div class="line">    Cypress.log(&#123;</div><div class="line">        name: &apos;login&apos;,</div><div class="line">        message: `$&#123;username&#125; | $&#123;password&#125;`,</div><div class="line">    &#125;)</div><div class="line">    // 关注公众号iTesting，精通Cypress使用</div><div class="line">return cy.request(&#123;</div><div class="line">        method: &apos;POST&apos;,</div><div class="line">        url: &apos;/login&apos;,</div><div class="line">        form: true,</div><div class="line">        body: &#123;</div><div class="line">            username,</div><div class="line">            password,</div><div class="line">        &#125;,</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这样，在使用上，你也不需要管什么Login Page类，Login测试类了。你在任何代码里直接写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cy.login（&quot;关注iTesting，玩转Cypress&quot;）</div></pre></td></tr></table></figure></p><p>它自然帮你登录成功， Page是什么？顿时不香了好吗！</p><p>Custom Commands的具体用法我的新书&lt;前端自动化测试框架 – Cypress从入门到精通&gt;里讲的还算通透，这里就不多说。</p><p>另外，在JavaScript世界里， 很讲究一个链式调用（Chainable）， Custom COmmands + 链式调用，Cypress认为它完全可以取代PO模型。</p><p>通过chainable把你的所有操作“可视化”。于是，一个Cypress推崇的测试用例就变成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/// &lt;reference types=&quot;cypress&quot; /&gt;</div><div class="line"></div><div class="line">describe(&apos;Custom Commands模式之登录测试&apos;, function () &#123;</div><div class="line">// 关注公众号iTesting，玩转Cypress</div><div class="line"></div><div class="line">    it(&apos;登录成功&apos;, function () &#123;</div><div class="line">          cy.login(username, password)</div><div class="line">            .verifyLoginSuccess()</div><div class="line">            .verifyWelcomeTxt()</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>从cypress角度，你看到的是login成功后直接去验证welcome的文本在不在。</p><p>这样感觉代码量是不是更少，代码更直观了？</p><h4 id="04-我怎么看PO和Custom-Commands"><a href="#04-我怎么看PO和Custom-Commands" class="headerlink" title="04 我怎么看PO和Custom Commands? "></a><center>04 我怎么看PO和Custom Commands? </center></h4><p>这里我也谈下我对PO和Custom Commands的看法。</p><p>首先要谨记：Cypress的出现是为Developer服务的，它对Developer的友好程度要高于Tester。</p><p>基于此，我们再来看登录成功这个用例， 你看到的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cy.xxx()</div><div class="line">   .yyy()</div><div class="line">   .zzz()</div></pre></td></tr></table></figure></p><p>这样的模式调用链清晰，从层次上来是，也比PO模型少了一层。出错后的调试，也更方便。</p><h4 id="但是！"><a href="#但是！" class="headerlink" title="但是！"></a><center>但是！</center></h4><p>你的测试用例都是cy这样，cy那样，当然对于Cypress官方来说，很成功，Visibility非常高，简直是Cypress的活广告，美滋滋啊！</p><h4 id="可是，你的“业务”呢？"><a href="#可是，你的“业务”呢？" class="headerlink" title="可是，你的“业务”呢？"></a><center>可是，你的“业务”呢？</center></h4><p>不错！你的业务以及业务细节被隐藏了！</p><p>虽然从Cypress的Custom Commands方式让测试写起代码来更爽，但是别忘记，在国内，我们还存在大量的测试人员，测试开发水平不足！（此时应该有广告，我的拉勾专栏&lt;测试开发入门与实战&gt;开栏24小时内售卖超10000+, 破了测试专栏的记录，值得你去拉勾上搜一下 ：））</p><p>而且，从习惯上来说，国内的同学们更习惯从业务角度去理解测试。并且Custom Commands把所有的公用功能都写在一个文件里，对测试人员来说不友好，当我的测试用例超过10000条时，Custom Commands里的公用方法，恐怕也有几百个了。总不能我来一个新人，让他花上几周时间去熟悉所有的方法吧！况且，都微服务了，他以后基本也只负责其中一些测试，那么我让他学那么多跟他没关系的方法干嘛呢？</p><p>虽然Custom Commands也可以做到按照微服务组织，然后在每个微服务Folder下实现一个Custom Commands的子域。但是，这样做，你使用时候由要跟PO模型一样先引入再使用， 那么它跟PO模型又有什么区别呢？！！</p><h4 id="05-PO和Custom-Commands我都要"><a href="#05-PO和Custom-Commands我都要" class="headerlink" title="05 PO和Custom Commands我都要"></a><center>05 PO和Custom Commands我都要</center></h4><h5 id="纸上得来终觉浅！"><a href="#纸上得来终觉浅！" class="headerlink" title="纸上得来终觉浅！"></a><center>纸上得来终觉浅！</center></h5><h5 id="纸上得来终觉浅！-1"><a href="#纸上得来终觉浅！-1" class="headerlink" title="纸上得来终觉浅！"></a><center>纸上得来终觉浅！</center></h5><h5 id="纸上得来终觉浅！-2"><a href="#纸上得来终觉浅！-2" class="headerlink" title="纸上得来终觉浅！"></a><center>纸上得来终觉浅！</center></h5><p>不能迷信权威！我刚开始搭建公司的前端框架时， 我就完全按照Cypress官方建议做，结果，当我的测试用例到达几千条时，我傻了，Custom Commands里的方法几百个，即使是我自己写的，但我自己也闹不清楚哪个做哪个用处，因为没有了Page做参考，时间一长，我很难从函数命名上看出这个方法应该在那个页面下使用， 更别说对框架不熟悉的新人了。</p><p>结果没办法，我重新返工了一遍，把特别核心的公用功能放到Custom Commands里，把跟业务有关的，还是以Page Object方式组织。放到微服务下，放到Page下，这样， 再来新人，我告诉他，你只要看这个commands这个文件还有你的微服务folder就好了。</p><p>所以， PO + Custom Commands + chainable是我的最佳实践， 以后我的测试用例就变成这样了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/// &lt;reference types=&quot;cypress&quot; /&gt;</div><div class="line"></div><div class="line">import mainPage from &quot;../pages/main&quot;</div><div class="line">describe(&apos;PageObject模式之登录测试&apos;, function () &#123;</div><div class="line">// 关注公众号iTesting，玩转Cypress</div><div class="line">const username = &apos;iTesting&apos;</div><div class="line">const password = &apos;password123&apos;</div><div class="line"></div><div class="line">    it(&apos;登录成功&apos;, function () &#123;</div><div class="line">        cy.login(username, password)</div><div class="line">const mainInstance = new mainPage()</div><div class="line">        mainInstance.isTargetPage()</div><div class="line">          .welComeText.should(&apos;contain&apos;, &apos;iTesting&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这下终于清静了！是么？</p><p>Cypress又提出了一个模型，App Actions， 同学，你想去尝尝鲜吗？<br>（<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>）。</p><p>往期回看：<br>        <a href="https://helloqa.com/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/" target="_blank" rel="external">你不知道的Cypress系列（1） –鸡肋的BDD</a><br>下期预告：<br>        <a href="https://helloqa.com/2020/12/31/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%883%EF%BC%89%20--%20%E6%98%AF%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BA%86/" target="_blank" rel="external">你不知道的Cypress系列（3） – 是时候重构自己的思维了！</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Cypress系列（1） --鸡肋的BDD</title>
      <link href="/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/"/>
      <url>/2020/12/29/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89%20--%E9%B8%A1%E8%82%8B%E7%9A%84BDD/</url>
      
        <content type="html"><![CDATA[<p>自从我的新书 <a href="https://item.jd.com/12647091.html" target="_blank" rel="external"><font color="#0099ff" size="3" face="“黑体”">前端自动化测试框架 – Cypress从入门到精通</font></a>上市以来，这本书受到了大量同学热情的追捧和讨论。在跟同学们的交流中，我也了解到， 原来除了国外优秀的公司(例如Adobe, 迪士尼，AutoDesk等等）， 国内也有很多公司在尝试使用Cypress提升测试效率。而在Cypress中国群内、在公众号iTesting里，我每天都能看到大量关于Cypress的使用讨论和私下问询。这让我感到无比荣幸。（<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>）。</p><p>除了日常推荐大家通过阅读我的书来解决日常Cypress使用问题外，我也一直在更新着我这边的Cypress知识图谱， 不夸张的说，目前我总结和实践下来知识点多达200多篇。本着“雕琢自我，普惠他人”的原则，我决定在公众号iTesting上开设&lt;你不知道的Cypress系列&gt;专栏。此专栏目的是分享一些我自己趟过的坑，走过的弯路、以及在选型时抛弃了的实践。希望让大家在选用Cypress作为前端自动化测试框架方案时， 可以借鉴一下，避免再走我走过的弯路。</p><p>经常有同学问我，为什么不在自动化测试中使用BDD？</p><blockquote><p>进退两难之际，夏侯惇入帐，禀请夜间口号。曹操随口曰：“鸡肋!鸡肋!”</p></blockquote><a id="more"></a><h4 id="01-什么是BDD？"><a href="#01-什么是BDD？" class="headerlink" title="01 什么是BDD？"></a><center>01 什么是BDD？</center></h4><p>Behavioural Driven Development (BDD)是从TDD发展来的（什么，TDD你都不知道？！），它通过自然语言定义系统行为，以功能使用者的角度，编写需求场景，且这些行为描述可以直接形成需求文档，同时也是测试标准。</p><p>这个概念太绕了，我不准备详细展开。你只要记住，BDD的背后是Gherkin， 而Gherkin的最佳体现是Cucumber框架，所以当你看到有人的测试用例/脚本是下面这个样子时，它就是BDD了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Given XXX</div><div class="line">When XXX</div><div class="line">Then XXX</div></pre></td></tr></table></figure></p><h4 id="02-BDD为什么是鸡肋？"><a href="#02-BDD为什么是鸡肋？" class="headerlink" title="02 BDD为什么是鸡肋？"></a><center>02 BDD为什么是鸡肋？</center></h4><p>本着测试工程师的优良传统 “You Can You Up， No Can No BB”， 我们直接用代码说话：<br>假设我有一个网站，它如下面这个样子：<br><img src="/2020/12/29/你不知道的Cypress系列/你不知道的Cypress系列（1） --鸡肋的BDD/1.webp" alt=""><br>它非常简单，当你输入正确的用户名和密码，我就允许你登录。假设我们要测试这个登录功能，那么我们先来看下，该如何测试。</p><h4 id="不使用BDD"><a href="#不使用BDD" class="headerlink" title="不使用BDD"></a>不使用BDD</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//login.js</div><div class="line">describe(&apos;HTML form submission&apos;, function () &#123;</div><div class="line">    beforeEach(function () &#123;</div><div class="line">        cy.visit(&apos;/login&apos;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    const username = &quot;kevin.cai&quot;</div><div class="line">    const password = &quot;password123&quot;</div><div class="line"></div><div class="line">    //关注公众号iTesting，跟测试万人团一起成长</div><div class="line">    it(&apos;验证登录成功&apos;, function () &#123;</div><div class="line">        //登录</div><div class="line">        cy.get(&apos;input[name=username]&apos;).type(username)</div><div class="line">        cy.get(&apos;input[name=password]&apos;).type(password)</div><div class="line">        cy.get(&apos;form&apos;).submit()</div><div class="line"></div><div class="line">        // 登录后验证</div><div class="line">        cy.url().should(&apos;include&apos;, &apos;/dashboard&apos;)</div><div class="line">        cy.get(&apos;h1&apos;).should(&apos;contain&apos;, &apos;kevin.cai&apos;)</div><div class="line">        cy.getCookie(&apos;cypress-session-cookie&apos;).should(&apos;exist&apos;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>可以看到，这个代码非常的Stright Forword。</p><p>为了简单起见，在这里我没有用任何的设计模式，实际工作中代码要比这个复杂的多，但是这一点不影响我们的比较，因为即使你用了PO， 用了Custom Commands， 也无非是代码结构更清晰一点，全部放在这里的代码无非分开放到公用Page里，放到Commands.js里。</p><h4 id="再来看下，BDD的用法"><a href="#再来看下，BDD的用法" class="headerlink" title="再来看下，BDD的用法"></a>再来看下，BDD的用法</h4><p>要使用BDD， 它的文件结构会如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line"></div><div class="line">|--iTesting（你的项目）</div><div class="line">    |--integration</div><div class="line">        |--login.feature(你的feature文件)</div><div class="line">        |--login</div><div class="line">            |--login.js(你的Step Definitons)</div><div class="line">    |--plugins</div><div class="line">         |--index.js</div><div class="line">    |--support</div><div class="line">         |--commands.js</div><div class="line">         |--index.js</div></pre></td></tr></table></figure></p><p>其中，login.feature文件的代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line"></div><div class="line">Feature: Login</div><div class="line"></div><div class="line">iTesting want to login</div><div class="line"></div><div class="line">Scenario: iTeting Demo</div><div class="line">    Given I am on the home page</div><div class="line">    When I login with</div><div class="line">        | username | password |</div><div class="line">        | kevin.cai | password123 |</div><div class="line">    Then the url is</div><div class="line">        | url |</div><div class="line">        | /dashboard |</div><div class="line">    And iTesting logged</div></pre></td></tr></table></figure></p><p>BDD宣称的最大好处就在这里了：<font color="#0099ff" size="3" face="“黑体”">用自然语言描述一个测试，并把它当成测试用例使用。</font></p><p>真的是这样的吗？经验告诉我们，华丽的外袍下面，一定是千疮百孔。来跟我一起解密，这些所谓的”自然语言“是如何起作用的吧。</p><p>再来看下Step Definiton， login.js的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line"></div><div class="line">import &#123; Given, When, Then &#125; from &apos;cypress-cucumber-preprocessor/steps&apos;</div><div class="line"></div><div class="line">Given(/^I am on the home page$/, () =&gt; &#123;</div><div class="line">    cy.visit(&quot;http://localhost:7077/login&quot;)</div><div class="line">&#125;)</div><div class="line">When(/^I login with$/, (dataTable) =&gt; &#123;</div><div class="line">    dataTable.hashes().forEach(auth =&gt; &#123;</div><div class="line">        cy.get(&apos;input[name=username]&apos;).type(auth.username)</div><div class="line">        cy.get(&apos;input[name=password]&apos;).type(auth.password)</div><div class="line">        cy.get(&apos;form&apos;).submit()</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Then(/^the url is$/, (dataTable) =&gt; &#123;</div><div class="line">    dataTable.hashes().forEach(dashbord =&gt; &#123;</div><div class="line">    cy.log(dashbord.url)</div><div class="line">    cy.url()</div><div class="line">        .should(&apos;eq&apos;, `$&#123;Cypress.config().baseUrl&#125;$&#123;dashbord.url&#125;`)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">And(/^iTesting logged$/, () =&gt; &#123;</div><div class="line">    cy.getCookie(&apos;cypress-session-cookie&apos;).should(&apos;exist&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>看到这里，你心里是不是跟我一样，就这？？（黑人问号脸）， 这难道不是另一种形式的函数吗？或者再高大上一点， 关键字？怎么你就敢这么秀？竟然开宗立派叫自己BDD， 要我说，BDD， 你应该叫“别BB，你就是DD！”</p><p>我们再来看运行时表现：</p><p>用了BDD后，你的测试用例里只能看到定义的feature文件（华丽的外袍给你看，内里就不好意思拿出来喽~）。<br><img src="/2020/12/29/你不知道的Cypress系列/你不知道的Cypress系列（1） --鸡肋的BDD/2.webp" alt=""></p><p>运行一下：</p><p><img src="/2020/12/29/你不知道的Cypress系列/你不知道的Cypress系列（1） --鸡肋的BDD/3.webp" alt=""></p><p>我再次笑了， 除了把我写的描述高亮出来，有什么区别吗？？</p><p>BDD唯一让我觉得不是一无是处的地方在于，可以给feature文件加标签，支持按标签运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//关注公众号iTesting，跟测试万人团一起成长</div><div class="line"></div><div class="line">Feature: Login</div><div class="line"></div><div class="line">iTesting want to login</div><div class="line"></div><div class="line">@smoke</div><div class="line">Scenario: iTeting Demo</div><div class="line">    Given I am on the home page</div><div class="line">    When I login with</div><div class="line">        | username | password |</div><div class="line">        | kevin.cai | password123 |</div><div class="line">    Then the url is</div><div class="line">        | url |</div><div class="line">        | /dashboard |</div><div class="line">    And iTesting logged</div></pre></td></tr></table></figure></p><p>然后命令行中运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn cypress-tags run -e Tags=&apos;@smoke&apos;</div></pre></td></tr></table></figure></p><p>这样能起到一个挑选测试用例运行的目的。</p><h4 id="03-总结"><a href="#03-总结" class="headerlink" title="03 总结"></a><center>03 总结</center></h4><p>我一贯是讨厌BDD的，在初次定义Cypress框架规范时，也有同学建议我用BDD，我都是一票否决的。原因无它，BDD使用下来的唯一感受就是（相信我，我开发基于Python的测试框架时也鄙视过BDD），会写代码的同学不想用BDD，觉得BDD是脱裤子放屁，隔靴搔痒多此一举。不会写代码的同学用不好BDD， 不是说自然语言描述吗？为什么我描述的框架都不认 ：）。</p><p>BDD除了给我们增加点工作量和Debug负担后，没有带来任何测试效率提升。</p><p>正所谓：“进退维谷，曹阿瞒不想吃鸡， 幸灾乐祸，老蔡笑骂BDD”。 </p><p>（<font color="red" size="2" face="“黑体”">买了书的同学们，公众号回复你的微信，拉你到Cypress中国群</font>）。</p><p>下次预告：<br><a href="https://helloqa.com/2020/12/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Cypress%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89%20--%20%E8%AF%A5%E6%AD%BB%E7%9A%84PO%E6%A8%A1%E5%9E%8B%E2%80%8B/" target="_blank" rel="external">你不知道的Cypress系列（2） – 绝知此事要躬行，别被Cypress官方忽悠瘸了！</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试开发入门与实践，你值得拥有！</title>
      <link href="/2020/09/10/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%8C%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89/"/>
      <url>/2020/09/10/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%8C%E4%BD%A0%E5%80%BC%E5%BE%97%E6%8B%A5%E6%9C%89/</url>
      
        <content type="html"><![CDATA[<p>热烈庆祝我在拉勾教育上的大课《测试开发入门与实践》24小时内订阅数超10000+！ 撒花！！<br><a id="more"></a></p><p>同为测试人，据说90%的人都会经历以下场景：</p><ul><li>每次发版时间相当紧张，上线前几天总是要肝个通宵</li><li>开发改动核心代码，留给测试完成全量回归测试时间非常短，出问题就要背锅。</li><li>手工执行用例、多浏览器重复验证同个功能、单个功能多个测试环境一遍遍点过去，像个机器人</li><li>每天重复“点点点”的机械工作，也不知道之后的几年还能干点啥。</li></ul><p>怎么样？细节是不是拿捏的死死的？但这些都不算啥，无非是工作比较难罢了，更难的是跳槽、涨薪非常困难。</p><p>几天前，我有个做了 3 年测试的朋友去面试，因为不懂测试开发，被定级为“初级测试”。他觉得自己受到了侮辱，但他没意识到：很多公司都已经停止招聘只会功能测试的人员了。</p><p>因为最近这几年，高度自动化的测试成为业界追求的目标，要实现自动化，离不开测试开发来开发各种框架，支撑测试工作高效率运行。1 个测试开发的效率远大于 3 个普通测试。</p><p>毫不夸张地说，功能测试人员如果不转型测试开发，基本上得告别软件测试生涯了。</p><p>想成为测试开发有那么难么？其实跟着测试大牛，从入门到上手实战都不会占用你太长时间。<br>拉勾教育「测试开发入门与实战」的专栏，只用27 讲就把测试开发的必学知识和实战技巧都讲得相当明白，非常适合想要入门测试开发的朋友学习。</p><center><font face="黑体" size="36"> 专栏讲什么？ </font></center><p>本专栏分为五大模块，共27讲。从测试框架的概念、开发方法以及设计思想入手，通过实战案例和测试框架的代码实现，带你全面掌握测试框架的开发，完成从功能测试向测试开发的华丽转身。</p><p>第一模块 <font face="黑体" size="5"> 打牢基础 </font>, 从框架概念到代码实践。专栏将从概念、组成、设计原则带你全方位认识自动化测试框架，并从工作场景出发，为你讲解开发测试框架所需要的Python知识，Git技巧，打牢测试开发基础。 </p><p>第二模块 <font face="黑体" size="5"> 项目实战 </font>，搭建自动化测试框架。专栏将带你从零开始，搭建你的第一个Web测试框架和API测试框架。在搭建测试框架的过程中，专栏将讲解 Python 的两个经典 Library：unittest 和 pytest，带你了解这两个框架的经典实现原理以及如何通过调整部分代码来优化你的测试框架。</p><p>第三模块 <font face="黑体" size="5"> 能力修炼 </font>，全面掌握多项技能。 专栏将带你探索自动化测试框架开发中的经典实践，带你拓展测试开发进阶所需技能，比如 API 和 UI 自动化测试融合的技巧，PO 模型，DB 链接，数据驱动，以及数据操作的新方式 — Pandas。通过本模块的学习，你将能够比较自如地应用市面上的测试框架，并将之改造以适应你的项目，真正做到知其然知其所以然。</p><p>第四模块 <font face="黑体" size="5"> 深入自动化测试框架开发原理 </font>.通过前面的学习，你已经对自动化框架的各个模块了然于胸，比如测试框架命令行参数，测试环境动态切换，测试用例动态挑选等。本模块将为你剖析这些经典模块的实现原理，了解这些原理之后，你将学会如何编码将这些功能实现。此外，本模块还会与你分享实战中的常见问题时和解决思路。</p><p><font face="黑体" size="5"> 加餐 本职之内，技术之外 </font>。专栏将结合高薪测试的成长路线，为你讲解技术之外，测试人同样需要关注的几个方面：如何在团队中保持技术影响力？如何成为技术骨干/技术管理？这些也是你成长过程中必须要面对的问题。</p><p>这是目录，也是测试开发必须的知识图谱，劝你对照着学，绝对会有收获：</p><p><img src="/2020/09/10/测试感悟/测试开发入门与实践，你值得拥有/1.png" alt=""></p><p>测试开发转型之路，你不容错过！立刻扫码开启你的测试开发转型之路！</p><p><img src="/2020/09/10/测试感悟/测试开发入门与实践，你值得拥有/2.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分库分表小结－论ＱＡ的自我修养</title>
      <link href="/2020/09/05/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B0%8F%E7%BB%93%EF%BC%8D%E8%AE%BA%EF%BC%B1%EF%BC%A1%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
      <url>/2020/09/05/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B0%8F%E7%BB%93%EF%BC%8D%E8%AE%BA%EF%BC%B1%EF%BC%A1%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<p>前几天有小伙伴在微信群里吐槽说，自己面试碰见面试官不问测试技术，一直关注代码和工具的底层实现，甚至问到了分库分表的实现原理，面试的结果呢当然是“今天的面试到此结束，如果合适的话后续会有通知”。　本着“有什么不开心的事说出来，让大家开心开心的原则”，　群里的小伙伴们纷纷出言献策，ＹＹ着要是自己面试会怎么回答。<br><a id="more"></a></p><p>随着互联网技术的演进，可以说，软件测试行业也进入了深水区，整个行业对ＱＡ的要求也越来越高，去ＱＥ的趋势特别明显，代码实现逻辑，设计模式这些以往问开发的问题也越来越常规的出现在ＱＡ的面试里，作为一名ＱＡ，靠”点点点“捣糨糊混江湖的日子一去不复返了，就我自己来说，面试中也越来越看重候选人对技术的深入是停留于表面还是锲而不舍的追宗溯源。　</p><p>在日常的测试里，ＱＡ免不了跟数据库打交道，那么知道分库分表的原理并以此来设计你的测试用例，必然对你的测试结果有增效作用。</p><p>本着ＱＡ的自我修养精神，我总结了分库分表的知识点，供大家参考。</p><h4 id="１-为什么要分库分表？"><a href="#１-为什么要分库分表？" class="headerlink" title="１.　为什么要分库分表？"></a>１.　为什么要分库分表？</h4><p>因为服务器承受不住了啊。</p><p>随着业务的发展到一定程度，如果数据库没有采用分库分表，那么必然出现单位时间内的访问海量增加，导致的后果是同样的ＳＱＬ语句返回结果变慢，性能变差，出现甚至无响应的情况，接着ＣＰＵ或者ＩＯ出现瓶颈。如果不想线上出事故导致今年白干一年，分库分表就变成了必要操作。</p><p>需要注意的是，分库和分表是业务发展到一定阶段才会面临的问题。　</p><p>分库和分表是两个操作，可以只分库不分表，也可以只分表不分库，还可以分库又分表。　</p><h4 id="２-分库分表的方式？"><a href="#２-分库分表的方式？" class="headerlink" title="２.　分库分表的方式？"></a>２.　分库分表的方式？</h4><p>目前业界的方式有两种：水平划分和垂直划分。</p><p><strong>水平切分</strong></p><p>把一个表的数据分散到多个表里去，达到的效果：</p><ul><li><p>每个表的结构都一样；</p></li><li><p>每个表的数据都不一样，没有交集；</p></li><li><p>所有表的并集是全量数据；</p></li></ul><p><strong>水平切分的优点：</strong></p><ul><li><p>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</p></li><li><p>应用端改造较小，不需要拆分业务模块</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>跨分片的事务一致性难以保证</p></li><li><p>跨库的join关联查询性能较差</p></li><li><p>数据多次扩展难度和维护量极大</p></li></ul><p>水平切分的具体实现方法：</p><p><strong>1、根据数值范围</strong></p><p>按照时间区间或ID区间来切分。</p><p>这样的优点在于：</p><ul><li><p>单表大小可控</p></li><li><p>天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</p></li><li><p>使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</p></li></ul><p>缺点：</p><ul><li>热点数据成为性能瓶颈。</li><li>连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询。</li></ul><p><strong>2、根据数值取模</strong></p><p>一般采用hash取模mod的切分方式，例如：余数为0的放到第一个库，余数为1的放到第二个库，以此类推。这样同一个用户的数据会分散到同一个库中。</p><p><strong>优点</strong>：</p><p>数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈</p><p><strong>缺点：</strong></p><p>后期分片集群扩容时，需要迁移旧的数据（使用一致性hash算法能较好的避免这个问题）</p><p>容易面临跨分片查询的复杂问题。<br>比如上例中，如果频繁用到的查询条件中不带cusno时，将会导致无法定位数据库，从而需要同时向4个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</p><p><strong>垂直切分</strong></p><p>垂直分库：基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。</p><p>垂直分表：</p><p>“大表拆小表”，每个表的结构都不一样；</p><p>每个表的数据也不一样，一般来说，每个表的字段至少有一列交集，一般是主键，用于关联数据；</p><p>所有表的并集是全量数据</p><p><strong>垂直切分的优点</strong>：</p><p>解决业务系统层面的耦合，业务清晰</p><p>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</p><p>高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</p><p><strong>缺点：</strong></p><p>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</p><p>分布式事务处理复杂</p><p>依然存在单表数据量过大的问题（需要水平切分）</p><h4 id="３-分库分表的工具？"><a href="#３-分库分表的工具？" class="headerlink" title="３.　分库分表的工具？"></a>３.　分库分表的工具？</h4><ul><li><p>cobar</p></li><li><p>TDDL</p></li><li><p>atlas</p></li><li><p>sharding-jdbc</p></li><li><p>mycat</p></li></ul><p><strong>参考资料：</strong></p><p>《数据库架构：分库分表-垂直？水平？》，公号：搜云库技术团队。</p><p>《数据库分库分表思路》，　公号：后端技术精选。</p><p>其余有价值参考资料（直接搜）：<br>《数据库分库分表，何时分？怎样分？》，方志朋。<br>《分库分表的几种常见形式以及可能遇到的难题》，InfoQ。</p><hr><h6 id="关注公众号iTesting，回复-进群，-跟万人测试团一起提升自己。"><a href="#关注公众号iTesting，回复-进群，-跟万人测试团一起提升自己。" class="headerlink" title="关注公众号iTesting，回复 进群， 跟万人测试团一起提升自己。"></a>关注公众号iTesting，回复 进群， 跟万人测试团一起提升自己。</h6>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试人员弯道超车指南</title>
      <link href="/2020/05/14/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%BC%AF%E9%81%93%E8%B6%85%E8%BD%A6%E6%8C%87%E5%8D%97/"/>
      <url>/2020/05/14/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E5%BC%AF%E9%81%93%E8%B6%85%E8%BD%A6%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>“如果04年你在QTP如日中天时学了Selenium，05到09年你大概率躺赢互联网圈；如果你在09年恰好看了Appium，等到10年开始淘宝 all in 无线，你今天大概率财务自由了”。<br><a id="more"></a><br>“<br>Cypress是端到端的一站式测试解决方案，它可以测试任何基于web的应用。</p><p>Cypres可以快速提高测试效率， 直接提升软件产品交付速度。</p><p>Cypress天然支持UI自动化，接口自动化的无缝融合，并且自带Mock Server，它拥有独特的测试流水线实现方式并且支持并行测试。</p><p>Cypress是广大测试同学在技术上弯道超车的唯一机会。<br>”</p><p>风起于青萍之末，浪成于微澜之间，当趋势来临时，当局者往往不自知，生活如此，技术也如此！</p><p>01</p><p>—</p><p>一本代表着新技术发展趋势的IT专业技术图书的出版，常常都会有很多圈子里的同行们前来祝贺、推荐和评价。&lt;前端自动化测试框架Cypress从入门到精通&gt;这本书的作者蔡超老师，已经在IT技术领域摸爬滚打十几年，曾先后服务于惠普，英孚教育亚太研发中心等多家国际知名企业，是一位资深但是却低调的测试架构师。<br><img src="/2020/05/14/前端自动化测试/软件测试人员弯道超车指南/1.jpg" alt=""></p><p>他的这本书，有两个突出的特点，第一，技术方案特别先进。Cypress作为紧密贴合前端开发技术趋势，底层技术却又很成熟的前端自动化解决方案，已风靡海外技术社区，但在本书之前，国内市面上却没有一本详细介绍其技术原理，使用指南，二次开发实践的书籍，这本书通过大量案例和实践代码详尽的阐述了如何使用Cypress来高效实施前端自动化测试，是毫无疑问的市场第一书。</p><p>第二，这本书技术新颖，方案独到，完善的解决了前端自动化实施过程中的诸多痛点，也因此吸引了很多业界著名的图书作者，企业创始人，一线开发经理前来推荐并不吝赞美。这本书是我所编图书中推荐者最多的一本书。</p><p>02</p><p>—</p><p>为什么大家如此关注Cypress？Cypress 作为提升企业交付速度，提高测试效率的抓手，一站式解决了企业和技术人员面临的问题。</p><p>一方面，在微服务，DevOps, 敏捷开发大行其道的今天，企业需要高频，快速的高质量交付产品，因此对能够实现测试流水线，搭建Mock Server，编写普适于UI自动化，接口自动化测试框架的测试专家趋之若鹜。</p><p>但业界这样的人才远远不够多，而且通常比较贵。</p><p>另一方面，个人往往需要数年的辛勤努力,不断实践才能掌握这些”核心”技术。</p><p>Cypress 的出现彻底改变了这一点。</p><p>Cypress天然支持UI自动化，接口自动化的无缝融合，并且自带Mock Server，拥有独特的测试流水线实现方式，且上手简单，搭配本书提供的脚手架框架代码，个人可以轻易搭建起企业级的前端自动化测试框架，使得企业可以轻松的，高质量，快速的交付产品。</p><p>03</p><p>—</p><p>人生的选择往往奇妙，毫无规律却又暗藏玄机，差别仅仅是一霎那，一念间。</p><p>想转行做自动化测试的朋友们，想追求新技术助力公司成长的朋友们，未来5年弯道超车的机会，也许就在今天！<br><img src="/2020/05/14/前端自动化测试/软件测试人员弯道超车指南/2.jpg" alt=""></p><p>04</p><p>—</p><p>本书京东首发，两次断货，当当上班一周即冲上科技品类新书第三名。全网可购买。<br><img src="/2020/05/14/前端自动化测试/软件测试人员弯道超车指南/3.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cypress </tag>
            
            <tag> 前端自动化测试 </tag>
            
            <tag> 自动化测试框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端自动化测试框架Cypress从入门到精通</title>
      <link href="/2020/04/30/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95Cypress%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
      <url>/2020/04/30/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E5%89%8D%E7%AB%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95Cypress%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<p>我曾经不只一次问自己，如果时间能倒流，你最想回到哪个时间？你最想做哪件事儿？你最想和谁在一起？<br><a id="more"></a></p><p>我的新书《前端自动化测试框架Cypress从入门到精通》出版了，此文是好友测试和敏捷界的双料大咖–云层老师所写。<br>以下是正文：</p><p>我渴望过无数种可能，也常常YY到飞起，但如果有且仅有一次机会让我选择，我会毫不犹豫的选择回到高三，回到我那个堆满了各种试卷的课桌上，回到我曾经发誓再也不想见的英语老师的课堂上，伴着声声婵鸣，不理会同桌凑过来的那张贱兮兮的脸，对那个满脸大汗奋笔疾书的自己说:”拜托，请你再努力一点儿，再多那么一点点”。</p><p>我曾无数次被这个梦叫醒，然而我听见的或是一句又做梦了？我看到的或是被社会教育过的自己，可是，我曾经最讨厌的粉笔头却再也没砸向过我。</p><p>“小X啊，你长大了”，我对着镜子里的自己说。心里却想着，成长，是多么残忍的一件事情啊。</p><p>摸爬滚打多年，我和社会各有胜负，它曾按着我的脸在地上摩擦，我也曾盆满钵满意气风发， 然而，心中却有那么一丝丝遗憾， 我们这一代年轻人，真正见证了中国互联网的奇迹，但是少有人能抓住， 所谓风起于青萍之末 浪成于微澜之间，当趋势来临时，当局者往往不自知，生活如此，技术也如此！</p><p>如果04年你在QTP如日中天时学了Selenium, 05到09年你大概率躺赢互联网圈; 如果你在09年恰好看了Appium,等到10年开始淘宝All in 无线，你今天大概率财务自由了；人生的选择往往奇妙，毫无规律却又暗藏玄机，差别仅仅是一霎那，一念间。</p><p>时至今日，随着敏捷开发， DevOps在软件行业的深入实践， 前端端到端测试越来越受到重视，大家都在寻找/开发能覆盖Web前端UI自动化，Server端接口自动化，并且能把两者有效融合的工具。</p><p>有没有嗅到一丝丝前端测试未来的味道？未来5年弯道超车的机会，也许就在今天！</p><p>云层给大家推荐一个早已风靡海外技术社区，也逐渐被国内先进的有追求的技术社区认可的框架， 它就是 Cypress， 而且顺带推荐一本我的好友蔡超的新书 《前端自动化测试框架Cypress从入门到精通》。<br><img src="/2020/04/30/测试框架/前端自动化测试Cypress从入门到精通/jd.jpg" alt=""></p><p>那为什么我要推荐这本书？<br><img src="/2020/04/30/测试框架/前端自动化测试Cypress从入门到精通/Cypress页.jpg" alt=""><br><a href="https://pan.baidu.com/s/1HIbefnEx4ScKk2pG2Asxqg" target="_blank" rel="external">提取码wi6z</a></p><p>Cypress天然支持UI自动化，接口自动化的无缝融合，并且自带Mock Server，拥有独特的测试流水线实现方式，且上手简单，搭配书中提供的脚手架框架代码，个人可以轻易搭建起企业级的前端自动化测试框架，使得企业可以轻松的，高质量，快速的交付产品，也使得个人可以很快构建起分层的自动化测试框架，轻松实现测试流水线，实现个人价值的提升。</p><p>Cypress现在是升职加薪的利器，以后必然是测试入门的必备知识。如果你想学习Cypress，想在未来的职业生涯中更具备竞争力，那么就跟我一起， 打开京东， 搜 “前端自动化测试 ” 吧！<br><img src="/2020/04/30/测试框架/前端自动化测试Cypress从入门到精通/宣传页1.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想进BAT？60道面试题助你一臂之力</title>
      <link href="/2020/03/13/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E6%83%B3%E8%BF%9BBAT%EF%BC%9F60%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/"/>
      <url>/2020/03/13/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E6%83%B3%E8%BF%9BBAT%EF%BC%9F60%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>还记得之前我的文章《想进BAT？这些面试题助你一臂之力》吗？ 时隔2年过去了，关于软件测试的技术发生了不少变化，市场上对QA的要求也有了提高和调整，故我们需要掌握的知识也需要升级。<br>下面就对这两年，提问比较多的面试问题总一个总结，希望能帮助到大家。<br><a id="more"></a></p><p>还是跟以前一样，题目是来自网络，我的回答是红色标注。</p><p>1.在上家公司的工作时间？对加班的看法？</p><font color="red">说实话，现在不加班的公司真是越来越少了。都在修福报。如果实在不接受就直说。不要进公司里再后悔</font><br>2.介绍一下XXX框架？它的原理（画图）？<br><font color="red">通常问的是简历上写的部分，一定要把自己在用的框架搞明白，特别是做过测试开发的，不仅要画出架构图，还应该对为什么要这么<br>构架有自己的看法</font><br>3.使用以上框架如何进行参数的提取，引用？如何断言？如何做到断言内容灵活变更？如何做到参数灵活变更？如何做到异步？如何请求http？<br><font color="red"><br>1. 参数的提取和引用，主要考察：<br>关于测试用例的数据驱动原理（比如ddt的实现原理）。</font><br><font color="red"><br>2. 通用的断言（参数化）：<br>把断言的期望结果和实际结果做封装，一个断言函数接受expected 和actual两个参数，内部判断即可。</font><br><font color="red"><br>3. 异步主要看实现方式，框架支持异步与否。有些框架比如Mocha就可以直接对异步接口进行测试和断言。<br></font><br><font color="red"><br>4. HTTP的请求无非是使用第三方库， python里的requests，java里的HTTPClient，还有javascript里的axios。<br></font><p>4.使用以上框架如何做到只调用一次登录接口后面所有用例都不需要再登录？</p><font color="red"><br>这部分本质就是个鉴权，说到底是个HTTP的状态如何保持有状态这个问题。<br>对于接口来说，可以看鉴权方式是哪个？ 现在比较流行JWT，只要登录一次后取到JWT就好了。然后一般还有个refresh token，可以写个函数，第一次取到JWT后保存下来（可是全局变量，也可存文件），后续调用时如果失败，通过refreshToken重新拿一次JWT，然后再次使用这个新生成的JWT即可。<br><br>如果用的cookies，可以在第一次登陆时拿到所有的cookies，然后inject到你当前的session里。<br></font><p>5.完整的接口自动化流程？</p><p>6.完整的性能测试流程？<br>7.性能测试中需要关注什么指标？</p><p>8.公司技术栈？<br>9.黑盒测试有哪些测试方法？分别简单介绍一下这些测试方法。<br>10.如果在工作中，开发拒绝更改bug该怎么处理？<br>11.个人的职业规划？<br>12.软件测试按项目流程来分可以分成几种？<br>13.个人的缺点？<br>14.平时会通过哪些途径提升自己？<br>15.做ui自动化中遇到的问题？<br>16.介绍一下appium的架构？atx的架构？<br>17.Chrome与ChromeDriver.exe的区别？<br>18.介绍一下selenium的原理？<br>19.测试用例包括什么要素？<br>20.公司项目迭代的流程？<br>21.数据库索引的作用？<br>22.表中的数据如何保持唯一性？<br>23.介绍一下数据库事务？<br>24.如何防止程序并发时，数据库数据出错？<br>25.什么是orm？<br>26.tcp/ip协议中tcp四次挥手各代表什么意思？为什么第二次第三次连续挥手？<br>27.在linux系统中如何查看nginx进程？如何查看端口号？如何查看内存使用情况？<br>28.java项目如何部署？<br>29.性能测试中tps上不去可能有哪些原因？<br>30.接口测试中，登录接口需要验证码，该如何取到验证码？<br>31.http状态码有哪些？各代表什么意思<br>？<br>32.有100ml的酱油和100ml的醋，从酱油中舀10ml到醋中，再从醋中舀10ml到酱油中，问酱油中的醋多还是醋中的酱油多？<br>33.心算2的61次方的个位数是多少？<br>34.以前工作中做的最好的成果？<br>35.用代码输出下题所有可能性：两个队伍，甲队有ABC三人，乙队XYZ三人，他们要进行一对一对战，抽签决定。已知X不是对C，Z不是对A,B<br>36.mysql的连表查询？<br>37.对支付宝转账流程写测试点？<br>38.对于测试开发的理解？<br>39.对于测试架构师的理解？<br>40.最近在学习的技术？<br>41.python如何进行爬虫？<br>42.如何测试dubbo接口？<br>43.使用什么前端、后端框架进行的测试系统开发？<br>44.性能测试中，服务器的cpu占用率高好还是低好？为什么？<br>45.内存溢出和内存泄露的区别？<br>46.作为一个测试leader，手下有组员，该如何指导组员开展自动化测试工作？<br>47.在上家公司的薪资水平？<br>48.从输入域名到展示页面发生了什么？<br>49.介绍一下产品业务流程调用的服务的链路？<br>50.测试用例编写的策略（包括哪些种类的测试）？<br>51.在项目迭代过程中是否有和开发沟通代码架构，设计逻辑？<br>52.测试计划包含什么内容？<br>53.数据库事务的概念？事务的四个特性？<br>54.数据库索引的念？他们的区别？<br>56.敏捷迭代和瀑布流迭代的种类？索引的优缺点？一个表最多几个索引？为什么索引可以加快检索速度？<br>55.乐观锁的概念？悲观锁的概区别？敏捷迭代中的两个清单三个角色四个仪式分别指什么？<br>57.docker的概念？<br>58.给到一个登陆框，需要进行哪些测试，并设计测试用例？<br>59.在性能测试中发现cpu占用过高应该如何进行分析？<br>60.压力测试和负载测试的区别？</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[直播]软件测试职业提升之道</title>
      <link href="/2020/02/15/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%81%8C%E4%B8%9A%E6%8F%90%E5%8D%87%E4%B9%8B%E9%81%93/"/>
      <url>/2020/02/15/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%81%8C%E4%B8%9A%E6%8F%90%E5%8D%87%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<p>文字脱水分享版:</p><p>云测学院的朋友大家晚上好，今天是2020年2月15日，这是我第二次直播，上一次直播是将近两年前，我分享了5个主题。分别是<br><strong> 论测试的核心竞争力。</strong><br><strong> 自动化测试入门与进阶 </strong><br><strong> 接口测试入门与进阶 </strong><br><strong> 测试框架入门与进阶 </strong><br><strong> 测试如何进一步转型测试开发暨测试人员发展之路。</strong><br>（如上直播，均可以进入公众号中回复直播领取）</p><p>这5个主题，收听人次累计已经近<em>10000</em>人。</p><a id="more"></a><p>（视频及PPT请进入公众号回复520）：<br>快2年了，不知道大家过的怎么样？还记得不记得我？今天的直播间里，有多少人当初听过我的直播的，麻烦call个666，让我看看。<br>哇，没想到还有这么多人记得我，感谢大家的厚爱。这些同学一会记得加我微信，我发红包给你们。<br>这两年多里，我除了持续研究测试框架和自动化测试以外，也一直致力于软件测试人员的职业提升，除了在我公众号里不停的发技术文章外，也开始慢慢的写一些自己对行业，对这份职业的看法。</p><p><a href="https://helloqa.com/2017/11/22/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%B5%8B%E8%AF%95%E5%BE%80%E4%BD%95%E5%A4%84%E5%8E%BB/" target="_blank" rel="external"><font color="ForestGreen">测试往何处去</font></a><br><a href="https://helloqa.com/2019/09/16/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%88%E9%99%84%E5%8E%9F%E7%89%88%E4%B9%A6%E7%B1%8D%E4%B8%8B%E8%BD%BD%EF%BC%89/" target="_blank" rel="external"><font color="ForestGreen">阿里巴巴《不止代码》读后感（附原版书籍下载）</font></a></p><p>想的多了，难免就会总结下，了解我的都知道，我这个人比较喜欢分享，刚好品清找我，我也就义不容辞。我预计4，5月份我还将联合云测出一个硬核技术系列分享，关于测试框架的，纯技术分享。具体内容及频次我呢就暂时先保密，大家应该很快就能从各个渠道听到，希望到时候能跟大家带来一个小惊喜。<br>今天呢，我就以一个马上就要被长江后浪拍死在沙滩上的“测试小化石”的身份，跟大家分享下软件测试的职业提升之道。今天我会讲到很多测试需要学的技术，也会讲到很多职场竞争及晋级的体会，希望大家听了除了哈哈一笑外，也能有点自己的感悟。</p><p>今天我会分如下几个方面来讲：<br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/1.png" alt=""></p><h5 id="1-软件测试的“困境”"><a href="#1-软件测试的“困境”" class="headerlink" title="1.软件测试的“困境”"></a><font color="ForestGreen">1.软件测试的“困境”</font></h5><p><img src="/2020/02/15/测试感悟/软件测试职业提升之道/2.png" alt=""><br>最近这两年，无论在微信群里，还是在行业会议里，都能听到这样的声音，软件测试low啊，阿猫阿狗都能进来做，软件测试不就是点点点吗，能有什么前途？？你乍一听，以为软件测试马上就消亡了呢。</p><p>再从工作机会上来看，一边有大量的测试人员抱怨找不到工作，一边有大量的企业重金求子，不对，重金求才！<br>为什么啊？大家好像都进入了一个怪圈，一边觉得测试没什么技术，一边却又满足不了雇主的需求。为什么会陷入到这个“困境”啊？<br>个人理解，是大家对测试这个工种的本质，还没有去深入了解。 下面谈谈我对测试的看法</p><h5 id="2-“歪解”测试"><a href="#2-“歪解”测试" class="headerlink" title="2.“歪解”测试"></a><font color="ForestGreen">2.“歪解”测试</font></h5><p>本着用事实说话的原则，我给大家看两个JD，<br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/3.png" alt=""></p><p>大家看看，左边和右边的技术要求，那个比较高啊？肯定是左边对吧，我再问大家，左边和右边的工资，大家觉得那个高啊？</p><ul><li>肯定是左边嘛，因为左边的要求高，对不对？</li><li>不对，这就是问题所在了。</li></ul><p>这两个职位都是alibaba的职位，分别对应的是开发架构师和测试专家。 工资范围都是30k到50k。怎么回事？不是测试比较Low吗？为什么跟开发的工资一样。这里就是一个误区了，工资高低跟技术难易度有必然关系吗？ 在回答这个问题前，我先尝试说下我对测试的理解。<br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/4.png" alt=""></p><p>中国互联网的起源，都离不开中关村的那一块广告牌。“中国离信息高速公路有多远？”。 这个广告牌年轻人可能没听过，但它在当时社会的影响力不亚于改革开发排头兵深圳（其实是蛇口）打出的口号“时间就是金钱,效率就是生命”。25年过去了，<br>这个广告牌早已不在，中国互联网可是一骑绝尘，“快上车，带你上高速”就是这块广告牌投射在年轻人心中的最佳写照。<br>我为什么要说这个，因为这个广告牌树起来3到5年后，BAT才诞生。而在BAT诞生后的5年内，都还软件测试什么事儿。那时候，瀑布开发模式就是流程和美的最直观表现。那时候你去百度， 关于软件测试最热门的讨论是 “什么是软件测试？“。</p><p>那么什么是软件测试，软件测试是怎么产生的？实际上就是用软件/网络的人越来越多了，软件质量导致的一些列问题让金主们由默默忍受变成破口大骂了，于是就出现了这个局面，金主们一边骂一边甩钱说”TMD，你们质量烂死了，这个软件再给我来20套“。 就是这么魔幻而又现实，熟话说好钢用在刀刃上， 能写bug的开发们都是刀刃，怎么办？咱再找个客服，帮我们解决这个问题吧，得懂点儿软件，不然客户的问题都回答不了。 Bingo， 软件测试行业诞生了！</p><p>什么是软件测试，这就是软件测试！  百度百科说软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。但实际上，软件测试行业就是就是为了节约宝贵的开发时间而产生的。<br>大家要记住这一点啊，这是血统，这也是很多人诟病软件测试low的根本原因。一句老话说的好，士别三日，咱洗浴中心见。朱元璋当皇上之前还要过饭呢。测试怎么就不能雄起呢？</p><p>事实上，随着互联网逐步变成现实中的水电煤，整个行业都在为提高效率头疼，公司一人节约一片手纸，一天下来省的量，就够单身狗撸一年了，对吧，大家这么着环顾一周下来，才发现原来制造业才是减少浪费的鼻祖。就这么着，高大上的互联网精英Kevin一夜醒来变成了流水线上的二狗子。<br>说起流水线，大家做测试这两年听的是不是特别多，其实它还有个B名（逼格名），Pipeline。搞pipeline的这一套的家伙（理论），我们都知道叫DevOps，DevOPs也有个本名，叫操作工（建立，监控，维护流水线的工人）。</p><p>这样一来都通了吧。拿起电脑你是测试专家，把电脑换成肥皂，你就是那个不得不弯腰的二狗子。</p><p>前面说了，士别三日，洗浴中心见，都君子坦蛋蛋了，就一切都明了了，要认清现实：</p><font color="red">“在流水线上，谁重要不重要，不看别的，主要看谁会掉链子”</font>. 这么一来大家知道，前面那个测试专家为什么值6w一个月了吧？有了这个专家，公司就能每个人省一片手纸！<br><br>既然流水线能一眼看出来谁在拉底效率，那么作为发你工资的老板，他会不会想不停的换掉那个使流程最慢的人啊？肯定会，对吧，这就是行业35岁缘由的根本原因。老板想法也简单，谁慢我就换谁，几轮下来，我这流水线就成永动机了。<br><br>这个老板有点天真，对吧。但你是不是比他更成熟一点呢？前段时间刷屏的测试三问：<br> - <font color="red">1.为什么这个bug都测不出来</font>.<br> - <font color="red">2.测试怎么测的,到底会不会测试?</font>.<br> - <font color="red">3.测试快点啊,为啥总是测试脱后腿,最后才测试出BUG?</font>.<br><br>测试三问，其实就是从流水线监工的角度，发出的真实责问。为什么人家会有这三问而你没有？也就是真正有价值的人，根本不在流水线上！<br><br>听了是不是有点沮丧，你天天视若珍宝的东西，自动化，测试框架，性能测试，测试左移，右移胡乱移（Chaos Testing），其实一点也不重要！<br>你必须从流水线上跳出来，你才能看清楚，到底要把精力放到哪里，也许这个时候你发现，测试设计或许比前面所有的测试活动都重要。对吧？<br><br>那么怎么能从流水线上跳出来呢？<br><br>先问自己三个问题：<br> - <font color="red">1.我属于哪段流水线？</font>.<br> - <font color="red">2.我在流水线上负责什么? </font>.<br> - <font color="red">3.我阻挡流水线了吗?</font>.<br><br>第一个问题，我属于哪段流水线？ 是认清自己的工作对公司对业务的价值。<br>第二个问题，我在流水线上负责什么? 是说我的工作对本部门，本职位的价值。<br>第三个问题，我阻挡流水线了吗? 是说我的能力能支撑我走多远。<br><br>我认为这3个问题也可以用来回答测试三问，你只有把自己跟理顺了，整明白了，你才有机会跳出这个流水线。<br>怎么把自己整明白呢？这就是软件测试人员能力成熟度模型了。&gt;<br><br><font color="ForestGreen"></font><h5 id="3-测试软件测试人员能力成熟度模型"><a href="#3-测试软件测试人员能力成熟度模型" class="headerlink" title="3.测试软件测试人员能力成熟度模型"></a><font color="ForestGreen">3.测试软件测试人员能力成熟度模型</font></h5><p><img src="/2020/02/15/测试感悟/软件测试职业提升之道/5.png" alt=""><br>软件测试人员能力成熟度模型，这里头的内容，属于质量体系建设的一个小节。对于这个模型，每个公司，可能制定的方式不一样，一般都会分等级。<br>我在这里就不列出具体哪一个级别需要具备具体哪样的能力，我仅仅列出我们需要掌握的技术知识。剩下的，各位可以根据自己公司情况酌情更改。<br>你看到的这张图，每个画红线的地方，后面都有无数个技能要学习和掌握。<br>我们来一个个分析。</p><ul><li><p><font color="red">1.专业技能胜任度</font>.<br>专业技能胜任度，就是我们常说的测试看家本领，测试硬技能了。你们可以看见，我的脑图一屏幕都放不完。没关系，公众号回复520领取。</p><p>放几张图你们感受下：<br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/6.png" alt=""><br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/7.png" alt=""><br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/8.png" alt=""><br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/9.png" alt=""><br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/10.png" alt=""></p></li><li><p><font color="red">2.领导力胜任度</font>.<br>领导力胜任度，主要关注有你，项目和团队带来的改变。</p></li><li><p><font color="red">3.沟通协作胜任度</font>.<br>沟通协作胜任度，主要考虑：</p><ul><li>对外，找决策人/关键干系人。<br>只有找对了人，才能办明白事。</li><li>对内，指定负责人。<br>人人负责就是人人都不负责</li></ul></li><li><font color="red">4.正向影响力</font>.<br>作为团队领导，不要事必躬亲，你心向大海，只要向团队成员描述大海的美好就可以了。剩下的交给他们。</li></ul><p>好了。有了以上这4个能力， 你基本就可以站在更高一个维度看问题了，接下来我们讨论下职业发展之”殇“。</p><h5 id="4-职业发展之“殇”"><a href="#4-职业发展之“殇”" class="headerlink" title="4.职业发展之“殇”"></a><font color="ForestGreen">4.职业发展之“殇”</font></h5><p>职业发展这个事，最诡异的地方就是，不是你掌握了核心科技，你就能成功，实际上你可能是个卖空调的，对吧？<br>那么，软件测试这个职业，怎么才叫做成功了呢？</p><p>什么叫成功？</p><p>王朔说成功就是赚俩个臭钱，让傻逼知道。</p><p>我认为，职场上的成功只有一个评判标准：</p><ul><li><font color="red">助力你的老板成功</font>.<br>有的人一听就炸了，老板那么傻逼，我为什么还要助他成功。旁友，接受现实哈。老板傻逼都能当你老板，说明你比老板还傻逼。<br>任何人，在职场上成功，做对的第一点，永远是助力了自己的老板成功。这个大家好好琢磨琢磨，不多展开。</li></ul><p>但是老板成功了，你就能成功吗？ 不一定，老板成功是你成功的必要条件，不是充分条件。</p><p>你的成功还需要那么一点运气，那么一点机会，什么是机会，就是先有机，然后你还得会。要会哪些呢？就是上节测试能力成熟度模型里的技术。</p><p><img src="/2020/02/15/测试感悟/软件测试职业提升之道/11.png" alt=""></p><p>你抓住机会了，你从一个技术专家变成一个领导者了，你要做哪些转变呢？</p><ul><li><font color="red">1.关注点从事到人</font>. <pre><code>- 有了事找人做，是刚入门的管理，找好了人，让他们做自己擅长的事才是合格的管理。</code></pre></li><li><font color="red">2.角色从演员到导演</font>. <pre><code>- 事必躬亲的后果就是你累死，手下闲死，然后你被骂死，最后被领导打死。</code></pre></li><li><font color="red">3.知识范畴从点到面</font>. <pre><code>- 做管理后，任何时候都不应该再秀自己的专业能力了，你要把你的爱从业务这一颗树上抽离出来，放到项目这个森林里去。</code></pre></li><li><font color="red">4.思考方式从非黑即白到多元的</font>. <pre><code>- 是时候放弃你编译器报错般的直爽了，除触犯底线外，遇事多考虑他人做决定的背后原因，试着理解，并最终走向双赢。</code></pre></li></ul><p>你转型成功了，你管理起来了，你又遇见了另外一个问题，团队戳一戳，动一动，什么八浅二深，循序渐进，没有的事儿，怎么办？如何激发大家积极性呢？<br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/12.png" alt=""></p><p>针对35岁现象，职业发展建议，持续优秀的特质这3个部分，看这个图。<br><img src="/2020/02/15/测试感悟/软件测试职业提升之道/13.png" alt=""></p><blockquote><p>”在我年轻的时候，曾以为金钱是世界上最重要的东西，</p></blockquote><p>现在我老了，才知道，的确如此！“</p><p>直播的最后，衷心祝愿大家在2020年，升职加薪，有更好的表现！</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试感悟 </tag>
            
            <tag> 直播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴《不止代码》读后感（附原版书籍下载）</title>
      <link href="/2019/09/16/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%88%E9%99%84%E5%8E%9F%E7%89%88%E4%B9%A6%E7%B1%8D%E4%B8%8B%E8%BD%BD%EF%BC%89/"/>
      <url>/2019/09/16/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E3%80%8A%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%EF%BC%88%E9%99%84%E5%8E%9F%E7%89%88%E4%B9%A6%E7%B1%8D%E4%B8%8B%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>今天忽然很多人在微信群求阿里巴巴《不止代码》技术精选集，没有想到时隔一年，这本电子书竟然再次引起了大家的关注，在赞叹阿里强大影响力的同时，也觉得是该写篇总结文了，毕竟大家工作非常忙，也不太可能花费数个小时一篇一篇看，正好我去年记过笔记。也罢，今晚不睡了，我们来一起掰扯掰扯这本110页的电子书，谁让我对你们比你们男/女朋友对你们还好呢？<br>关注微信公众号iTesting索取书籍。<br><a id="more"></a></p><p>我们先来看看原版目录：<br><img src="/2019/09/16/测试感悟/阿里巴巴《不止代码》读后感（附原版书籍下载）/1.webp.jpg" alt=""></p><p>一共一十三篇，可谓用心良苦，阿里巴巴技术团队就像凯撒的第13兵团一样，帝国的眼睛望到哪里，隔天哪里的墙上就会有帝国的标语：“ I came, I saw, I conquered。”霸气的阔以。（也可能是实在凑不出更多的数目了）<br>对于不想仔细看的同学来说，你只需要记住几个关键点就行，整本书在我看来包含以下三方面：</p><p><strong><font color="#8B0000">技术深度</font></strong><br><strong><font color="#8B0000">职业发展</font></strong><br><strong><font color="#8B0000">自我提升</font></strong></p><p>好了，看到这里，你可以关闭本文去群里吹水了，“从技术深度上来讲，，，对自我提升来说，，，以职业发展的角度来说，，，”， ，像不像各大会议上侃侃而言的大佬们。</p><p>“哈哈哈，熟归熟，你这样乱讲我一样会告你诽谤”</p><p>好了不开玩笑了，下面我将拆解这三个部分。<br><strong><font color="#8B0000">技术深度</font></strong><br>“阿里没有不努力的人，阿里也没有不勤奋的人”。那么， 将你和我区分开来的，一定是技术的深度。说起技术的深度，很多同学习惯性的认为是一杆到底，直通最最底层的0和1。其实完全不是这样。</p><p>判断一个人技术有没有深度，其实很简单，抛给他一个点，也就是随随便便一个小问题，看他回答的是不是一个面，而你从这个面的任何一个角度再追问，立马他就丢给你一张立体的网。还不明白的话，请参考我的旧文《Cookie, Session, Token，WebStorage你懂多少?》。<br>到底如何培养技术深度呢？我“恶意的揣度”（跪舔）了一番阿里的“调性”（伟大之处），也总结了几点。<br><strong>1. 求人不若求己</strong><br>不可否认，阿里是当今国内互联网最讲愿景的公司之一，但即使是这么理想化的公司，也啪啪打脸了如下招聘福利 “大牛多多，跟大牛快速提升自己”， 文章都说了，要成为大牛要靠自己。<br><strong>2. 打好基础，努力搬砖</strong><br>什么意思呢？你只有把业务代码这个点玩出花来，才有机会接触到系统这个面。业务代码都写不好，你就洗洗睡吧。<br>对于测试来说，你测试用例/功能测试都做不来，就别折腾自动化测试开发了，同样是尼古拉斯，人家是凯奇，你充其量只能是佩奇。<br><strong>3. 勤学苦练，把梦想照进现实.</strong><br>不管业务代码，还是技术架构，你看再多遍书，不如实操一遍，实操完，不如再给大家讲一遍，分享是最深入的学习。<br><strong>4. 站到讲台上往下看。</strong><br>上学时候你坐在座位上，总以为老师看不见你语文书下套着的数学书，数学书下套着的语文书。你偷偷拉前面同学的长发，用笔捅的左边同学哈哈，你总以为老师看不见，可当你有一天站住讲台上，你就会明白什么是一览无余。（关注iTesting，跟万人测试团一起成长）<br>做技术也一样。不要仅仅纠缠技术细节不自拔，一定要跳出来，从整个系统，业务，痛点，甚至行业生态的讲台上往下看，你才能看清楚代码里的弯弯绕，也更清楚为什么系统顶层设计要这么做。<br><strong><font color="#8B0000">职业发展</font></strong></p><p>文中其实说了很多，短期发展靠技术，长期发展靠团队。其实总结起来就两个字：</p><p>“赋能”。<br>什么意思呢？窃以为阿里巴巴看起来是一个技术驱动的公司，实际上还是一个业务驱动的公司。作为个人贡献者，假设自己的技术能够随时匹配业务的爆发，那么职业发展不在话下。但是作为团队管理者，要寻求突破，使得整个团队的技术能够引导，甚至产生新的业务（典型如阿里云），技术赋能，这样才能p891015一路飞天。</p><p>话说回来，我认为不同公司有不同的路径，大家千万不要盲目跟随，一定要看公司的导向是什么，有的放矢。不能公司要求跑量，业务为先，你非要说为什么接口测试只测试主流程啊？公司要内建质量，你非要说手工测测不就好了，上什么CICD？</p><p>怎么定义职业发展的好？我有一点心得，老板的成功就是你的成功，只有老板成功了，你才能有机会成功。</p><p>不明白的同学好好理解理解，不过多解释。<br><strong><font color="#8B0000">自我提升</font></strong><br>我把自我提升和职业发展拆开出来了，为什么？因为职业发展永远是对公司而言的，你在A公司，业务好就能发展，可你去B公司，技术不好别想晋级。公司导向不同，职业发展的抓手就不一样。但是自我提升是长期的，是不以公司导向为前提的。短期来看，自我提升了，职业不一定发展的好，长期来看，自我提升的副作用一定是职业生涯突飞猛进，是的，我用了副作用。正作用是你会发现你竟然不知道你竟然是如此的优秀。</p><p>自我提升，要分清楚，不是大而全，也不是深而窄，它不是鸠摩智的小无相功，而是张三丰的融会贯通，文章里说了好多，你要从一个点，撒出一个面，然后结成一张网，最终创造出一个模型，自我提升是你的代码世界观，是你思想的代码体现。</p><p>如何自我提升？首先，你得知道你想要什么，其次，难得知道怎么才能得到你要的。举个很恰当的例子，你想当县长夫人，那么你就甭管谁是县长，明白嘛？还不明白再看一遍让子弹飞去。</p><p>以上就是我不止代码这边书的读后感。林林总总牢骚了这么多，你是不是更想看看原书了？没问题，公众号回复 不止代码，马上看起来，同时欢迎你和我一起探讨本书的读后感。</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是如何面试的</title>
      <link href="/2019/09/01/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E9%9D%A2%E8%AF%95%E7%9A%84/"/>
      <url>/2019/09/01/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E9%9D%A2%E8%AF%95%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>最近遇见一个好玩的bug, 现象是页面刷新白屏,RootCause是Header里放的cookie太多了, 大小超出了4kb的限制．<br><a id="more"></a><br>解决方法很简单，拆出一部分放到LocalStorage．问题解决了，但是个人觉得很有意思，平常司空见惯的，觉得＂假大空不接地气＂的概念，其实都真真切切的在项目中体现了，只不过我们熟生轻视，看不见而已．遂记录本文．</p><p>面试的时候经常喜欢问一个问题，HTTP协议是有状态的还是无状态的？很多同学都不知道，或者简单背一个答案，曰无状态．再问，那么HTTP协议如何保持状态？只有一小部分同学能答出来要用cookie和session.再问,有了cookie为什么还要session？更少一部分人能答出来安全。再问，不要cookie行不行？能答出URL重写的已经不错了。对于高级的测试，再继续深入，session保存在服务器内存中，随着用户的增多，服务器撑不住了怎么办？假设我使用了集群服务怎么办？这个时候聪明点的就会答sesion sticky， 或者使用Memcached集中所有session id了。但这也带来另外一个问题，session 服务器挂了怎么办？再弄个集群，有点傻吧，自然的，Token就被带出来了。然后再问Token一般怎么生成的啊？服务器生成，把user id+时间+私密签名用Base64加密生成，自己保存一份（不放内存放DB， 也可以不保存，那么收到客户端id就用加密算法再算一次生成token来对比）， 发给客户端一份。能回答到这里的已经可以了。接着再顺便问一句，token里能不能保存敏感信息啊？为什么？（Base64是加密吗？），什么是JWTtoken啊？token组成里的私密签名，是用什么加密的啊，顺便就把公钥私钥给理清楚了。对称算法，非对称算法也给考察了。如果有人答到这里，你还对他不放心的话，再问一句你听过iTesting吗？回答听过的你就收了吧，看我公号的人技术都不会太差：）。HTTP和HTTPS的核心区别是什么？能答出TCP请求并说出区别是SSL协议的你就收了吧。像什么get和post的区别，生成一个TCP请求包还是2个就不必要再纠结了， 能研究到这里的，测试肯定也能干好。<br>上面说了一堆，看出来了吗？一个问题考察多个层面并且都有联系，平常没点积累是不行的，我的文章要常常看啊。<br>下面是一些总结：<br><strong>cookie 和session的区别</strong></p><ol><li>cookie放在客户端的浏览器上，session放服务器上。</li><li>Session生成的Session id是在cookie里保存的，cookie被禁止后可以通过URL重写来继续使用session</li><li>cookie不是安全，存放在本地的COOKIE可能被获取并进行COOKIE欺骗。</li><li>session会给服务器带来压力，考虑到服务器性能，应当使用COOKIE。</li><li>cookie只能保存字符串类型，以文本的方式。session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie， Session大小没限制。</li></ol><p><strong>Token 和Session区别</strong></p><ol><li>Token放客户端， Session在服务端。</li><li>Session是空间换时间， Token是时间换空间。</li><li>Token解决了集群时候跨节点访问问题。</li></ol><p>Cookie有限制，每次请求服务端必须带上，还有大小不能超过4kb，如果想突破这个限制怎么办？</p><p><strong>WebStorage</strong><br>为克服由cookie所带来的一些限制，当数据无需发回服务器时使用。<br>WebStorage两个主要目标：</p><ol><li>提供一种在cookie之外存储会话数据的路径。</li><li>提供一种存储大量可以跨会话存在的数据的机制。</li></ol><p>HTML5的WebStorage提供了两种API：<br><strong>localStorage（本地存储）</strong><br><strong>sessionStorage（会话存储）</strong></p><p>这两种区别在哪里？<br>1、生命周期：<br>localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。微信公众号关注iTesting，跟万人测试团一起成长。<br>sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。<br>2、存储大小：<br>localStorage和sessionStorage的存储数据大小一般都是：5MB<br>3、存储位置：<br>localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。<br>4、存储内容类型：<br>localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理。<br>5、应用场景：<br>localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；</p><p><strong>Web Storage带来的好处：</strong><br>1、减少网络流量：<br>一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要的来回传递 。<br>2、快速显示数据：<br>性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示 。<br>3、临时存储：<br>很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端测试框架Cypress从入门到精通（预告）</title>
      <link href="/2019/05/26/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Cypress%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
      <url>/2019/05/26/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Cypress%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<p>自动化过程中，Selenium作为主流测试工具虽然仍占据比较重要地位，但已经不再适应当前日新月异的技术架构了，特别作为UI自动化测试， 业界已经有了很多好的实践，在本文里， 我将带领大家领略前端测试框架Cypress的强大之处。<br><a id="more"></a><br>这两天周末，天气不是很好，所以待在家里，因为身体不能出去浪，干脆让心灵爽一爽，在我重温了人性的黑暗，<br><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/1.png" alt=""></p><p>体验了信仰的震撼后，</p><p><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/2.png" alt=""></p><p>我感觉自己也是这么的无敌和寂寞，于是我忍不住证明了一把自己</p><p><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/3.png" alt=""></p><p>忽然我就感觉有点惆怅， 莫名其妙我就理解了建安某年，也是在这样的一个狂风大雨适合小酌的日子，大耳贼酒饱饭足后的空虚与无奈<br><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/4.png" alt=""></p><p>回首我刚刚毕业时，</p><p><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/5.png" alt=""></p><p>没想到已是沧海桑田。<br><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/6.png" alt=""></p><hr><p>好长时间没有写过系列了，熟悉我的朋友们都知道，我是一个很守信用的人，之前一直跟大家说要分享前端测试框架，结果一直没（想）时（偷）间（懒）。 </p><p>今天先放个大致的架子出来，后面我再慢慢补充，具体的形式我还没有想好，也许还是直播，也许是别的，无论是哪种形式，你们都将等得到我</p><p>前端测试框架Cypress从入门到精通</p><p><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/1.webp.jpg" alt=""><br><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/2.webp.jpg" alt=""><br><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/3.webp.jpg" alt=""><br><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/4.webp.jpg" alt=""></p><p>因为内容比较多，并且我想针对每一个内容，不仅讲解怎么用，还要拿例子说明，估计会花费很长时间的准备，敬请期待<br>如果你觉得我的文章好，请赞赏我杯咖啡 ：）<br><img src="/2019/05/26/自动化测试系列/前端测试框架Cypress从入门到精通/7.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴测试左移和开发赋能分享（内附下载）</title>
      <link href="/2019/04/02/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%B5%8B%E8%AF%95%E5%B7%A6%E7%A7%BB%E5%92%8C%E5%BC%80%E5%8F%91%E8%B5%8B%E8%83%BD%E5%88%86%E4%BA%AB/"/>
      <url>/2019/04/02/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%B5%8B%E8%AF%95%E5%B7%A6%E7%A7%BB%E5%92%8C%E5%BC%80%E5%8F%91%E8%B5%8B%E8%83%BD%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>之前我写过测试工程师的出路问题  <strong> <a href="https://helloqa.com/2017/11/22/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%B5%8B%E8%AF%95%E5%BE%80%E4%BD%95%E5%A4%84%E5%8E%BB/" target="_blank" rel="external">测试往何处去 – 新时期测试如何面对挑战</a> </strong>, 今天看到同事发的这篇文章，感觉写的非常好，特转载如下：</p><a id="more"></a><p>微信关注公众号iTesting， 获取&lt;阿里巴巴开发赋能分享&gt;下载链接。</p><p>从事测试开发很长一段时间，一直不知道怎么去评价和衡量这个职业的目标是什么，超高的自动化测试覆盖率？或者超稳定超包容的自动化测试框架？</p><p>怎么才算得上是一个优秀的测试开发人员？上2周有机会去听了阿里2天的公开课，好像明白了一些，拿来跟大家分享一下。</p><p><center><font face="黑体" size="5"> 内建质量 </font></center><br>在微软有一句名言：“质量是设计出来，而不是测出来的。” 当然，这是理想情况，如果产品经理都这么优秀，这个世界早就和平了。</p><p>今天我们不说产品经理，我们从测试和开发的角度看，怎么内建质量。</p><p>让测试内建质量<br>为了内建质量，测试同学就要尽可能早地干预开发写bug，让bug死在摇篮里。换句话说就是让开发不要写出可以避免的bug：</p><p>•产品，开发，测试应该同时参与需求评审会议，澄清需求，达成共识<br>•将关键测试点作为需求的一部分，让开发同学交付需求时完成自测</p><p>让开发内建质量<br>从开发的角度看，要提高代码的质量可以有很多种方式：</p><p>•提高自测意识，借助单元测试或者质量分析工具<br>•真正理解需求和技术架构，进行Code Review或者结对编程<br>•评估代码质量或者bug数量，跟绩效挂钩</p><p>排除开发的自身能力问题，80%的bug都是需求理解不准确的问题，如果开发不愿背这个锅，那就甩给产品经理吧。</p><p>由此可见，如果测试不想看见这些bug，那么你就要帮产品表达需求，帮开发理解需求。</p><p><center><font face="黑体" size="5"> 测试左移 </font></center><br>上面我们说内建质量其实已经涉及到了测试左移，例如让QA在参与需求研讨时提出问题，列出测试点其实已经开始在进行测试了。</p><p>为什么我们要测试左移呢？因为发现问题的时间越晚，修复的成本就越高。</p><p><img src="/2019/04/02/测试感悟/测试左移和开发赋能分享/1.webp.jpg" alt=""></p><p>图中橙色线条代表了传统测试发现缺陷的时间，大多数bug都是在功能测试和集成测试时发现的，最后导致的结果就是发布前加班加点，祈祷不要有bug漏到生产环境。</p><p>如果我们能把测试活动向左移动，那么就意味着修复成本大幅下降。<br><img src="/2019/04/02/测试感悟/测试左移和开发赋能分享/2.gif" alt=""></p><p>但是谈何容易？想要把大部分测试点放在单元测试环境完成，非常依赖成熟的开发环境和极其资深的开发人员。</p><p>在阿里是这样实践的，让测试给开发赋能。</p><p><center><font face="黑体" size="5"> 开发赋能 </font></center><br>从字面上解释就是，测试同学给开发赋于一定的能力，让他们有能力去完成测试，比如：</p><p>•降低测试门槛<br>•使用测试工具（自动化）<br>•获取测试数据<br>•培养测试意识</p><p>举个例子，开发同学在完成需求代码后，可以点击一个按钮得到测试数据，再点击一个按钮验证测试覆盖点，喝杯咖啡后就可以看到测试报告。</p><p>从上面这个例子看，开发同学其实他并不需要懂测试数据的设计，自动化测试的开发，测试报告的编排，但是他依然可以快速完成需求测试（门槛低），只要他养成习惯（培养意识）。</p><p>那么你就会说，这对测试的同学要求是不是很高啊？对啊，回到开篇的问题，如何评判一个测试人员的能力？在我看来就是评判他给开发和团队赋能的能力。在阿里是这样，在微软和谷歌也是这样。</p><p>一个优秀的测试人员将测试左移时，并不会将负担转移给开发。相反地，而是帮开发写出更高质量的代码，更高效率地交付需求。</p><p>那么测试能左移到什么程度呢？比如让开发在Coding时就发现问题，或者还没Coding就发现问题，那应该是极好的。</p><p><img src="/2019/04/02/测试感悟/测试左移和开发赋能分享/3.gif" alt=""></p><p>怎么做到呢？刚才已经说过了，测试即需求，把bug扼杀在摇篮里。</p><p>实践方法<br>想实践测试左移可以有很多种方法，每个组织需要根据实践情况进行裁剪和调整。</p><p>•参与需求评审，帮助开发理解需求<br>•参与架构、设计分析，提早预防问题<br>•践行BDD，TDD<br>•单元测试提案，接口测试提案<br>•提供模拟数据能力，测试工具<br>•制定提测标准，拒绝低质量代码<br>•回归测试自动化<br>•静态代码分析，单元测试覆盖率</p><p>测试左移的概念给整个测试角色带来了巨大的转变。软件测试不仅仅是“发现bug”，而是致力于“尽可能早的检测和预防bug”.</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一小时学会接口测试</title>
      <link href="/2018/12/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E4%B8%80%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9A%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/12/30/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E4%B8%80%E5%B0%8F%E6%97%B6%E5%AD%A6%E4%BC%9A%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>接口测试最近几年越来越流行了，特别是随着微服务的兴起，系统和系统之间，甚至系统内部模块之间的互相调用都开始大量使用接口了（一般采用RESTFUL风格的http调用），这就给我们的质量保证工作带来的新的机遇，在业务测试之前验证接口的正确性，将使得我们在更早的阶段发现问题，提升效率。<br><a id="more"></a></p><p>如果你从来没接触过接口测试，请查看：<br><a href="https://helloqa.com/categories/api-test/" target="_blank" rel="external">接口测试系列</a></p><p>接口测试如何做呢？一般已经上线接口都会自动化掉，关于接口自动化，可以使用现成的接口框架，也可以移步我之前关于测试框架的文章，<br><a href="https://helloqa.com/2018/07/31/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6Pytest%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">pytest测试框架</a><br><a href="https://helloqa.com/2018/12/29/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E8%87%AA%E7%A0%94%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Ktest%E4%BB%8B%E7%BB%8D/" target="_blank" rel="external">自研测试框架ktst</a></p><p>对于正在开发或还未达到上线条件的接口，手工测试就必不可少。对于这部分测试，相信大家都有自己的心得，简单的接口，可以通过fiddler或者Charles模拟请求，也可以在接口请求发送前或服务器结果返回前加入断点，更改请求内容或返回内容。<br>但对于复杂的接口，或者需要多次定时运行，甚至接口间有先后调用顺序的接口，或者团队成员需要轮换测试不同的接口时，Postman就是唯一一个选择了。</p><p>我将分以下几个方面介绍：</p><h5 id="1-介绍-amp-安装"><a href="#1-介绍-amp-安装" class="headerlink" title="1. 介绍 &amp; 安装"></a>1. 介绍 &amp; 安装</h5><h5 id="2-常见请求："><a href="#2-常见请求：" class="headerlink" title="2. 常见请求："></a>2. 常见请求：</h5><h5 id="3-变量定义，重用-环境变量。"><a href="#3-变量定义，重用-环境变量。" class="headerlink" title="3. 变量定义，重用, 环境变量。"></a>3. 变量定义，重用, 环境变量。</h5><h5 id="4-Collection"><a href="#4-Collection" class="headerlink" title="4. Collection"></a>4. Collection</h5><h5 id="5-Conditional-Workflows"><a href="#5-Conditional-Workflows" class="headerlink" title="5. Conditional Workflows"></a>5. Conditional Workflows</h5><h5 id="6-Newman"><a href="#6-Newman" class="headerlink" title="6. Newman"></a>6. Newman</h5><h5 id="7-跟Jenkins集成"><a href="#7-跟Jenkins集成" class="headerlink" title="7. 跟Jenkins集成"></a>7. 跟Jenkins集成</h5><h5 id="8-Moniter-amp-Mock-Server-amp-API-Documentation"><a href="#8-Moniter-amp-Mock-Server-amp-API-Documentation" class="headerlink" title="8. Moniter &amp; Mock Server &amp; API Documentation"></a>8. Moniter &amp; Mock Server &amp; API Documentation</h5><p>总结起来就一句话，看完本篇，让你玩转“手工”接口测试。</p><h4 id="1-介绍-amp-安装-1"><a href="#1-介绍-amp-安装-1" class="headerlink" title="1. 介绍 &amp; 安装"></a>1. 介绍 &amp; 安装</h4><p>什么是postman？ </p><blockquote><p>Postman Makes API Development Simple, so does the API testing. </p></blockquote><p>自己去官网下载后安装，你可以创建一个用户，或者关闭注册窗口继续使用， 我用的企业版，直接登录后使用，你会看到如下图。<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman1.png" alt=""></p><h4 id="2-常见请求：-1"><a href="#2-常见请求：-1" class="headerlink" title="2. 常见请求："></a>2. 常见请求：</h4><p>界面左上角 “+New” -&gt; “Request”，或者根据上图选第一个Request，创建你的第一个request：<br><strong> GET: </strong><br>URL里填写， 点击send request<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman2.png" alt=""></p><p>注意， get请求的参数实际上就是我们在url里看到的？后面的一串，如果有多个参数你可以在Params里添加。 </p><p><strong> POST：</strong><br>对于POST类型的请求， 填写好body内容， Headers内容<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman3.png" alt=""><br>一般的POST方法都需要authentication，那么你可以在Authorization里添加相应的类型（现在用Bearer Toeken较多)，实际情况用什么认证需问开发。<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman4.png" alt=""></p><p>这部分非常基础， 不展开。</p><h4 id="3-变量定义，重用-环境变量-和Scripts。"><a href="#3-变量定义，重用-环境变量-和Scripts。" class="headerlink" title="3. 变量定义，重用, 环境变量 和Scripts。"></a>3. 变量定义，重用, 环境变量 和Scripts。</h4><p>一个请求常常需要用不同数据在不同测试环境测试多次，那么参数化就必不可少。<br>Postman里变量用</p><p><img src="/2018/12/30/接口测试/一小时学会接口测试/postman150.png" alt=""></p><p>来表示。variables里面就是你的变量。Postman看到双括号就知道里面的是变量。</p><p>环境变量的定义在这里：<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman5.png" alt=""><br>以上图的例子来说，我定义个变量名为url，<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman6.png" alt=""><br>定义好后，使用上只要用如下表述就可以了。</p><p><img src="/2018/12/30/接口测试/一小时学会接口测试/postman151.png" alt=""></p><p>环境变量可以导出供其它用户使用，注意环境变量是全局的，即定义好后，任何请求都可以重用。<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman7.png" alt=""></p><p>本地变量和全局变量在pre-scripts和Tests里的定义：<br> <strong> 设置：</strong><br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman8.png" alt=""></p><p><strong> 获得(我新建了一个请求)：</strong><br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman9.png" alt=""></p><p>注意定义的local variables不能在其他请求里使用，但是global变量可以，定义的环境变量也是全局的，同时定义好后它可以在Environment里可以看到。</p><p>在接口测试里，我们经常需要发送一个接口后进行检查，postman给我们提供了一些通用的检查模板，在Tests里编写代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// example using pm.response.to.have</div><div class="line">pm.test(<span class="string">"response is ok"</span>, function () &#123;</div><div class="line">    pm.response.to.have.status(<span class="number">200</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// example using pm.expect()</div><div class="line">pm.test(<span class="string">"environment to be production"</span>, function () &#123; </div><div class="line">    pm.expect(pm.environment.get(<span class="string">"env"</span>)).to.equal(<span class="string">"production"</span>); </div><div class="line">&#125;);</div><div class="line"></div><div class="line">// example using response assertions</div><div class="line">pm.test(<span class="string">"response should be okay to process"</span>, function () &#123; </div><div class="line">    pm.response.to.<span class="keyword">not</span>.be.error; </div><div class="line">    pm.response.to.have.jsonBody(<span class="string">""</span>); </div><div class="line">// 关注iTesting，跟万人测试团一起成长</div><div class="line">    pm.response.to.<span class="keyword">not</span>.have.jsonBody(<span class="string">"error"</span>); </div><div class="line">&#125;);</div><div class="line"></div><div class="line">// example using pm.response.to.be*</div><div class="line">pm.test(<span class="string">"response must be valid and have a body"</span>, function () &#123;</div><div class="line">     // <span class="keyword">assert</span> that the status code <span class="keyword">is</span> <span class="number">200</span></div><div class="line">     pm.response.to.be.ok; // info, success, redirection, clientError,  serverError, are other variants</div><div class="line">     // <span class="keyword">assert</span> that the response has a valid JSON body</div><div class="line">     pm.response.to.be.withBody;</div><div class="line">     pm.response.to.be.json; // this assertion also checks <span class="keyword">if</span> a body  exists, so the above check <span class="keyword">is</span> <span class="keyword">not</span> needed</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>有时候某些接口入参需要一些随机数，postman也贴心的提供了如下方案：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> : Adds a v4 style guid</div><div class="line">: Adds the current timestamp</div><div class="line">: Adds a random integer between <span class="number">0</span> <span class="keyword">and</span> <span class="number">1000</span></div><div class="line"><span class="comment">#需要注意的是这些参数只能在request URL / headers / body里使用。</span></div></pre></td></tr></table></figure></p><h4 id="4-Collection-1"><a href="#4-Collection-1" class="headerlink" title="4. Collection"></a>4. Collection</h4><p>什么是Collection？</p><blockquote><p>A Postman Collection lets you group individual requests together. You can organize these requests into folders.</p></blockquote><p>测试时候需要根据一个个用户scenario来，collection是最好的方式<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman10.png" alt=""></p><h4 id="5-Conditional-Workflows-1"><a href="#5-Conditional-Workflows-1" class="headerlink" title="5. Conditional Workflows"></a>5. Conditional Workflows</h4><p>创建好Collection，你可以把一个个接口请求放入Collection里，方便以后测试：<br>我们知道，测试的时候接口之间往往要有调用顺序的要求，如此我们只要在第一个接口请求的Tests里加入即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">postman.setNextRequest(<span class="string">'get-example'</span>);</div><div class="line"><span class="comment">#注意事项：</span></div><div class="line"><span class="number">0.</span> 如果没有设置setNextRequest，Collection的各个请求是顺序运行的。</div><div class="line"><span class="number">1.</span> 设置了setNextRequest后，最好设置工作流停止条件在最后一条请求的Tests里，设置方法： postman.setNextRequest(null);  否则可能会导致无限循环。</div></pre></td></tr></table></figure><br>Runner里设置，运行环境， Iteration次数， 及使用数据文件。<br>之前我讲过数据驱动，同一个接口，需要不同数据来验证，Postman允许使用datefile。我们先来看一个请求：<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman11.png" alt=""><br>我们定义了两个参数 path 和value，在Tests里写我们的验证点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var jsonData = JSON.parse(responseBody);</div><div class="line">tests[<span class="string">'Response has data value'</span>] = jsonData.form.foo === data.value</div><div class="line">//打印出foo的值</div><div class="line">console.log(jsonData.form.foo)</div></pre></td></tr></table></figure></p><p>我们再定义一个datafile, 格式可以是json，csv。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.json</span></div><div class="line">[&#123;</div><div class="line">  <span class="string">"path"</span>: <span class="string">"post"</span>,</div><div class="line">  <span class="string">"value"</span>: <span class="string">"1"</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="string">"path"</span>: <span class="string">"post"</span>,</div><div class="line">  <span class="string">"value"</span>: <span class="string">"2"</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="string">"path"</span>: <span class="string">"post"</span>,</div><div class="line">  <span class="string">"value"</span>: <span class="string">"3"</span></div><div class="line">&#125;, &#123;</div><div class="line">  <span class="string">"path"</span>: <span class="string">"post"</span>,</div><div class="line">  <span class="string">"value"</span>: <span class="string">"4"</span></div><div class="line">&#125;]</div></pre></td></tr></table></figure></p><p>datafile也可以用csv的格式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1.json</span></div><div class="line">path， value</div><div class="line">post，<span class="number">1</span></div><div class="line">post，<span class="number">2</span></div><div class="line">post，<span class="number">3</span></div><div class="line">post，<span class="number">4</span></div></pre></td></tr></table></figure><br>我们来运行下，点击菜单栏上的Runner：<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman11.png" alt=""><br>配置如下，然后点击”Run with data files”：<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman13.png" alt=""><br>运行好后来看结果：<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman14.png" alt=""><br>注意，Iteration需要跟datafile的一致，如果超出会用最后一个data。<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman15.png" alt=""></p><h4 id="6-Newman-1"><a href="#6-Newman-1" class="headerlink" title="6. Newman"></a>6. Newman</h4><p>什么是Newman：</p><blockquote><p>Newman is a command line Collection Runner for Postman. It allows you to run and test a Postman Collection directly from the command line.<br>安装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g newman</div></pre></td></tr></table></figure></p></blockquote><p>最简单使用：<br>导出Collection（mycollection.json）<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman16.png" alt=""><br>command line里切换目录到你的mycollection所在文件夹：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#直接运行导出的collection：</span></div><div class="line">newman run mycollection.json</div><div class="line"><span class="comment">#如果你的collection用到了environment的变量，你需要将它导出(本例是env.json)，</span></div><div class="line"><span class="comment">#并在运行时加参数 -e</span></div><div class="line">newman run mycollection.json -e env.json</div><div class="line"></div><div class="line"><span class="comment">#newman 命令行有很多参数，其中常用的是如下：</span></div><div class="line"><span class="comment">#--folder [folderName]           Specify a single folder to run from a collection.</span></div><div class="line"><span class="comment">#-e, --environment [file|URL]    Specify a Postman environment as a JSON [file]</span></div><div class="line"><span class="comment">#-d, --data [file]               Specify a data file to use either json or csv</span></div><div class="line"><span class="comment">#-g, --globals [file]            Specify a Postman globals file as JSON [file]</span></div><div class="line"><span class="comment">#-n, --iteration-count [number]  Define the number of iterations to run</span></div><div class="line"><span class="comment">#更多命令，以 newman run -h 查看。</span></div><div class="line"></div><div class="line"><span class="comment"># newman还支持把运行结果导出以方便后续分析。</span></div><div class="line"><span class="comment">#json格式</span></div><div class="line">newman run mycollection.json -e env.json --reporters cli,json --reporter-json-export outputfile.json</div><div class="line"></div><div class="line"><span class="comment">#junit格式</span></div><div class="line">newman run mycollection.json -e env.json --reporters cli,json,junit --reporter-junit-export  outputfile.xml</div><div class="line"></div><div class="line"><span class="comment">#html格式，首先要安装：</span></div><div class="line">npm install -g newman-reporter-html</div><div class="line"><span class="comment">#然后执行命令</span></div><div class="line">newman run mycollection.json -e env.json --reporters html --reporter-html-export outputfile.html</div></pre></td></tr></table></figure></p><h4 id="7-跟Jenkins集成-1"><a href="#7-跟Jenkins集成-1" class="headerlink" title="7. 跟Jenkins集成"></a>7. 跟Jenkins集成</h4><p>newman命令知道了，跟Jenkins集成就非常简单了，建立一个自由风格的项目，然后在Build选择Execute Shell即可<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman17.png" alt=""><br>命令就填写我们在6里的命令即可：<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman18.png" alt=""><br>注意：<br>1.需要在Jenkins服务器本地安装newman程序。<br>2.如果你设置了junit类型的报告给Jenkins用，记得在Jenkins的Post Action里选择Publish JUnit test result report，把生成的报告路径填对。<br>3.Jenkins其它参数配置例如定时运行请自行了解。</p><h4 id="8-Moniter-amp-Mock-Server-amp-API-Documentation-1"><a href="#8-Moniter-amp-Mock-Server-amp-API-Documentation-1" class="headerlink" title="8. Moniter &amp; Mock Server &amp; API Documentation"></a>8. Moniter &amp; Mock Server &amp; API Documentation</h4><p>这都是企业版的功能，也非常强大，设置来说都是三步，可以针对一个请求或者一个Collection来操作。<br>拿Moniter举例， New-&gt;Moniter, 我设置一个Moniter来定时运行一个Collection，也可以选择时区。<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman19.png" alt=""><br>设置好后，会看到一个webdashboard，<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman20.png" alt=""><br>点击进去看看，里面会显示这个moniter的情况，可以手工运行也可以让它自己运行，运行成功后你的邮箱将会收到结果文件（企业版可以用邮箱登陆），这个其实就是替换jenkins的。<br><img src="/2018/12/30/接口测试/一小时学会接口测试/postman21.png" alt=""><br>Mocker Server就是可以对某一个请求或一个Colection做mock，直接返回结果。<br>API Documentation 可以为一个请求或者一个collection生成API文档，postman也会提供你一个网址访问。<br>因为绝多数朋友不会用专业版，这里我就不详细介绍了。</p><p>再很长的一段时间内，手工测试绝对不会消失，那么如何高效的开展手工测试，提高个人生产率，从而对业界平均生产率产生价值差，就是我们不懈的追求了。<br>希望大家花个一个小时左右通读本篇，彻底玩转手工接口测试。<br>还有几分钟马上2019年了，我预祝大家生活有追求，技术不落伍，祝大家新年快乐！<br>（新的一年，请继续关注iTesting，多点赞多转发，帮助更多的人提升自己。）</p>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api-test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自研测试框架Ktest介绍</title>
      <link href="/2018/12/29/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E8%87%AA%E7%A0%94%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Ktest%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/12/29/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E8%87%AA%E7%A0%94%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Ktest%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>之前分享过很多优秀的测试框架，总觉得意犹未尽，干脆自己撸起袖子写一个。 添加微信公众号iTesting 查看原文。</p><a id="more"></a><p>在自动化测试的过程中，测试框架是我们绕不过去的一个工具，无论你是不需要写代码直接改动数据生成脚本，还是你需要检查测试结果甚至持续集成，测试框架都在发挥它的作用。<br>不同编程语言的实现出来的框架也不尽相同，但是思想总是相通的，比如尽量使框架使用者只关注自己的业务，框架帮助处理错误截图，保存错误log，出错重试甚至跟jenkins持续集成等。</p><p>可以说，一个还算合格的测试框架，可以大大提升测试效率；一个优秀的测试框架，说它能把测试人员从繁缛复杂的跟业务无关但又不得不做的工作中解脱出来也不为过。既然框架的作用这么明显，那么有哪些优秀的测试框架可以给我们用呢？</p><p>大家都知道， java里有TestNG， python里有unittest，pytest等优秀的“官方”框架， 我对python比较熟悉，之前也介绍过很多这方面的文章，相信大家也多少看过一两篇。<br>可以说，能把这些经过百万人检验的“官方”测试框架工具用好用顺，拿下本职工作根本不在话下，更不用说你还能用好围绕着这些工具的生态库了，那简直是如入无人之地。</p><p>那么，为什么还要自己写一个框架呢？</p><p>相信常做自动化的都有自己的感悟， 比如自己业务没那么复杂，官方框架显得太重了；比如官方框架依赖很多的第三方库，每个要单独安装，更新，而且每个都有自己的用法，学习成本高；<br>再比如说，鞋子合脚不合脚，有的人要穿7年才能知道（对，那谁）。</p><h4 id="痛点："><a href="#痛点：" class="headerlink" title="痛点："></a>痛点：</h4><p>对于常用python写自动化的来说，unittest本身很优秀，但是不支持并发，而且测试报告支持的也不好，也不支持数据驱动。<br>pytest那里都好，就是吃了酒香不怕巷子深的亏，那个docouments真要心非常静才能读下去， 另外什么功能都需要额外安装一个库，你想并发？好，装一个pytest-parallel，你想报告html展示？好，装个pytest-html， 你想要错误的测试用例自动重跑一遍？好，装个pytest-rerunfailures。 强大是强大，感觉有点过于繁琐了。</p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>基于上述痛点，大部分同学选择在原有开源框架上二次开发，比如unittest集合多线程threading.Thread实现并发，加入HTMLTestRunner实现报告展示，引入ddt实现数据驱动，然后美其名曰，我写了个框架，我每次听到都是先很崇拜，然后晚上暗搓搓拉下代码一看，MD，这不是就是搭了个积木取名要你命3000吗？你还不能说人家说自己写了一个框架不对，何况这个框架通常也很好用。<br>用pytest就不更用说了，连并发都有两个库，一个xdist，一个pytest-parallel，每次都患选择恐惧症。</p><p>再有，开源的框架，毕竟普适多于贴合，跟自己的业务有时候就不那么紧密，为了使用某个具体功能还得引入很大一个包，也不是非常方便，另外最关键的一点是，我总觉得自己还行，想站起来试试 ：）</p><h4 id="框架是什么？我是怎么考虑框架的？"><a href="#框架是什么？我是怎么考虑框架的？" class="headerlink" title="框架是什么？我是怎么考虑框架的？"></a>框架是什么？我是怎么考虑框架的？</h4><p>之前分享过几篇文章，<br><a href="https://helloqa.com/2017/04/04/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%88%91%E8%A7%81/" target="_blank" rel="external">测试框架之我见</a><br><a href="https://helloqa.com/2017/04/04/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/Web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/" target="_blank" rel="external">web自动化框架实践指南</a><br><a href="https://helloqa.com/2018/07/30/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/Python%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/" target="_blank" rel="external">Python接口测试框架实践</a><br><a href="https://helloqa.com/2018/07/31/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6Pytest%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">pytest框架从入门到精通</a><br>《测试框架之我见》， 《web自动化框架实践指南》， 《接口测试框架实践》， 《pytest框架从入门到精通》。 这些都是我工作的一些感悟，和对框架的一些思考，可以看到思想也是循序渐进的。你也可以看到不是“官方”框架，就是二次开发的“官方”框架。 当然也可以说我是常怀觊觎之心，不停研究的目的就是我个人非常想有一套完全自己实现的框架。</p><h4 id="什么是ktest？"><a href="#什么是ktest？" class="headerlink" title="什么是ktest？"></a>什么是ktest？</h4><p>一句话：</p><blockquote><p>ktest is a common test framework support for Both UI and API test with run in parallel ability。<br>跟其它的框架有什么不同？<br>除标准库之外，原则上不引入任何第3方库，所有的一切都自己实现。比如并发就老老实实自己设计规则多线程并发，不用xdist或者pytst-parallel了，比如错误重跑，HTML报告都是自己实现了。</p></blockquote><h4 id="参考了谁？"><a href="#参考了谁？" class="headerlink" title="参考了谁？"></a>参考了谁？</h4><p>我当然不是闭门造车，参考了unittest，pytest，ddt，还有自己公司的官方框架， 读了部分源码，研究了下部分功能实现原理。</p><h4 id="实现的功能："><a href="#实现的功能：" class="headerlink" title="实现的功能："></a>实现的功能：</h4><p>1.多线程并发。（整套框架代码没出现任何哪怕一句threading，实现了并发，神奇不，嘿嘿）<br>2.分布式并发。（借助selenium-grid）<br>3.数据驱动。（一条用例两条数据会被当成两个用例，并展示在最终报告里）<br>4.同个测试类数据共享，每个测试用例数据独立。setUpClass， tearDownClass， setUp， tearDown（一看就是unittest的概念，只不过我自己实现了）。<br>4.动态生成，挑选，运行测试用例。（大量借助装饰器）<br>5.Web UI自动化测试每条用例错误自动截屏，记录log信息，自动重跑机制。<br>6.HTML报告。<br>7.XML格式for Jenkins。（马上完成，姑且算完成吧）<br>现在还是第一版，我个人想把它写成一个通用的测试框架，即可服务于web UI自动化测试，又可服务于API测试。当然还有很长的路要走。</p><h4 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h4><p>先不介绍技术细节， 先把自己放在一个业务测试，或者刚接触自动化脚本的测试角色上，我拿到了一个测试框架，我最先想到的是什么？ 如何用对吧？ 用这个框架，我原有的测试用例需要做哪些改变？这个框架有哪些方便？你对框架的期待有哪些？<br>1.使用简单，介绍详细。<br>2.能让我方便的查找， 生成， 运行， 清理测试用例及测试数据。<br>3.对业务的侵袭小，我迁移成本低。<br>4.功能强大，报告美观。<br>5.稳定，bug少。</p><p>下面就详细介绍：</p><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#目前部署在自己公司的pypi库上，后期会上传到pypi。</span></div><div class="line">pip install ktest --index-url http://jenkin.xxxx.com:<span class="number">8081</span>/pypi --trusted-host jenkins.xxxx.com</div><div class="line"><span class="comment">#安装好后，你可以在 Python安装目录下的如下文件找到安装的包\Lib\site-packages</span></div></pre></td></tr></table></figure><h4 id="你的项目应该包括哪些："><a href="#你的项目应该包括哪些：" class="headerlink" title="你的项目应该包括哪些："></a>你的项目应该包括哪些：</h4><p>在讲用法前，我们先来直观看下，你的项目目应该是什么样子的<br><img src="/2018/12/29/测试框架/自研测试框架Ktest介绍/project_summary.JPG" alt=""><br>你的项目中应该包含：<br>1.pages package， 这里面放你所有待测试页面，每个页面作为一个page object来保存。<br>2.tests package， 这个文件夹下面放所有的测试用例，包括你的数据驱动，断言都在这里。<br>3.settings package， 这个里面放了一些框架里会用到的参数，当然也可以放你自己的配置。 如果你不知道框架用到哪些变量，你可以暂时不建立它，运行时框架会帮你自动生成。</p><p>可以看到，你只需要把精力放在你本身的业务上就好了。</p><h4 id="ktest框架组成"><a href="#ktest框架组成" class="headerlink" title="ktest框架组成"></a>ktest框架组成</h4><p>package建立好了，我的测试用例，及我的待测页面要如何组织才能接入框架呢？ 别急，我们先来看看框架本身长什么样子。<br><img src="/2018/12/29/测试框架/自研测试框架Ktest介绍/ktest_summary.JPG" alt=""></p><h4 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h4><p>看用红框标记起来的部分：<br>Common – 框架精华<br>1.欢迎关注公众号iTesting，跟万人测试团一起成长。<br>2.abstract_base_page.py 这个文件有是为了你自己项目的pages准备的，你的每一个待测页面或者功能都应该继承自这个文件中的类，并重写一些特定的函数。<br>3.api_base_case.py 创建了为api测试而用的基类。<br>4.enumeration.py 一些枚举变量，比如测试类的setup 和tearDown等，主要为了防止代码里写错及方便修改。<br>5.get_platform_info.py 判断运行的系统环境是windows，还是linux， 框架开始前会清理执行环境。<br>6.get_project_info.py 用于拿到你的项目文件的根目录。<br>7.html_reporter.py 用于生成HTML报告。<br>8.klogger.py 用于全局logger或者每个case独立logger。<br>9.selenium_helper.py 基于selenium封装的一些toolkit， 比如打开浏览器，使用chrome headless模式，关闭浏览器等。方便你快速开展工作。<br>10.test_case_finder.py 用于测试用例的查找和组织。 根据你的用户输入来进行，默认从tests 这个package下找所有被标记为@TestClass， @Test并且enable的用例。<br>11.test_decorator.py 用于标记测试类，测试用例，并且赋予每个测试类和测试用例独特的属性，方便test_case_finder查找。<br>12.test_filter.py 所有测试用例查找到后，根据用户的输入进行filter，最终保留出当次运行需要的测试类，测试函数及测试数据的组合。<br>13.ui_base_page.py UI的公用页，所有的UI Case 都继承自此。<br>14.user_options.py 接受用户参数并分析，最终为框架所用，包括要哪些用例运行，这些用例比如属于哪个组，那个测试类， 多线程还是单线程。 都在这里设置。</p><p>utiilites – 拿来即用测试套件<br>这里面放一些半成品，比如连接数据库脚本，比如用excel做数据驱动，对excel进行读写的脚本。 用户不需要操心连接的建立，销毁等。</p><p>main.py 用来运行框架，并发运行控制也是在这里。并发我“舍弃”了threading.Thread， 代码量下降一半以上，且不用操心锁。</p><p>setup.py 用来把框架打包。</p><h4 id="集成你的项目"><a href="#集成你的项目" class="headerlink" title="集成你的项目"></a>集成你的项目</h4><p>框架也看了，我的项目也建了， 我们的测试类和测试方法应该怎么写？<br>还拿我一直用的baidu来举例，你的项目pages package下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#bai_du.py</span></div><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line">__author__ = <span class="string">'iTesting'</span></div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> common.abstract_base_page <span class="keyword">import</span> AbstractBasePage</div><div class="line"><span class="keyword">from</span> page_objects <span class="keyword">import</span> page_element</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BAI_DU</span><span class="params">(AbstractBasePage)</span>:</span></div><div class="line">    BAI_DU_HOME = <span class="string">"http://www.baidu.com"</span></div><div class="line">    SEARCH_DIALOG_ID = <span class="string">"kw"</span></div><div class="line">    SEARCH_ICON_ID = <span class="string">"su"</span></div><div class="line">    MEMBER_COUNT_XPATH = <span class="string">"//option[@value='10']"</span></div><div class="line">    SAVE_XPATH = <span class="string">".//*[@id='save']"</span></div><div class="line">    search_input_dialog = page_element(id_=SEARCH_DIALOG_ID)</div><div class="line">    search_icon = page_element(id_=SEARCH_ICON_ID)</div><div class="line">    member_count = page_element(xpath=MEMBER_COUNT_XPATH)</div><div class="line">    save_button = page_element(xpath=SAVE_XPATH)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, browser)</span>:</span></div><div class="line">        self.browser = browser</div><div class="line">        AbstractBasePage.__init__(self, browser)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_target_page</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser.get(self.BAI_DU_HOME)</div><div class="line">        print(self.is_element_displayed_on_page(self.search_icon))</div><div class="line">        <span class="keyword">return</span> self.is_element_displayed_on_page(self.search_icon)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, search_string)</span>:</span></div><div class="line">        self.search_input_dialog.send_keys(search_string)</div><div class="line">        self.search_icon.click()</div><div class="line">        time.sleep(<span class="number">5</span>)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preferences</span><span class="params">(self)</span>:</span></div><div class="line">        browser = self.browser</div><div class="line">        browser.get(self.BAI_DU_HOME + <span class="string">"/gaoji/preferences.html"</span>)</div><div class="line">        self.member_count.click()</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        self.save_button.click()</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        browser.switch_to_alert().accept()</div></pre></td></tr></table></figure><br>每一个你的测试类（待测页面）你需要：<br>1.测试类继承AbstractBasePage， 然后page_object模式就可以使用了。<br>2.测试类要实现is_target_page函数，返回值是True或者False， 运行中如果返回值False，会Raise Error并停止本测试类后续运行。<br>3.如果你不用page objectmm模式，你无需遵守上述规定。</p><p>你的tests package下测试用例定义<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># test_baidu.py</span></div><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">from</span> common.selenium_helper <span class="keyword">import</span> SeleniumHelper</div><div class="line"><span class="keyword">from</span> common.test_case_finder <span class="keyword">import</span> data_provider</div><div class="line"><span class="keyword">from</span> common.test_decorator <span class="keyword">import</span> TestClass, SetUpClass, Test, TearDownClass</div><div class="line"><span class="keyword">from</span> pages.baidu <span class="keyword">import</span> BAI_DU</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@TestClass(group='smoke', enabled=True)</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBaidu</span>:</span></div><div class="line">    test_case_id = <span class="string">'3'</span></div><div class="line"><span class="meta">    @SetUpClass()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser = SeleniumHelper.open_browser(<span class="string">'firefox'</span>)</div><div class="line">        self.baidu = BAI_DU(self.browser)</div><div class="line"><span class="meta">    @data_provider([('baidu',), ('google',)])</span></div><div class="line"><span class="meta">    @Test()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_baidu_search</span><span class="params">(self, x)</span>:</span></div><div class="line">        self.tag= <span class="string">'tt'</span></div><div class="line">        <span class="string">"""Test search"""</span></div><div class="line">        self.baidu.search(x)</div><div class="line">        <span class="keyword">assert</span> <span class="number">1</span>== <span class="number">1</span></div><div class="line"><span class="meta">    @Test()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_baidu_set</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Test set preference"""</span></div><div class="line">        print(<span class="string">'NONONO'</span>)</div><div class="line">        self.baidu.preferences()</div><div class="line">        <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser.delete_all_cookies()</div><div class="line">        self.browser.close()</div><div class="line"><span class="meta">    @TearDownClass()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>我来仔细解释下：<br>1.test_case_id： 是测试报告里要显示的test_case_id, 一般跟你testcenter里的test_id相同，如果你一个测试类共用一个id， 你定义为类属性就可以。 如果你每个测试用例不同id，你在每个测试函数里，重写它就可以。 框架会为你替换。<br>2.tags: 是每个用例的tag，定义在类属性里，test_finder查找时会解析这个tags，可以是str或者list或者tuple，或者是3者的嵌套。 框架最终会解析成一个list。<br>比如你定义 tags=[‘smoke’,’bvt’] 和你定义 ‘smoke, bvt’是一样的效果。 当用户指定了要跑的tag属性时候，test_finder会根据它的值来做filter。<br>3.@SetUpClass()， @TearDownClass() 测试类装饰器，无输入参数。 每个测试类，不管它有多少个测试用例，这两个装饰器装饰的函数只会被执行一次。 一般用作测试类公用的数据的初始化，比如说，连接db查找某些值。 请注意， 并发运行，不要在这个函数里初始化你的browser，会有共享问题。<br>4.@TestClass（）， 测试类的装饰类， 函数接受两个个参数一个是group，就是测试类所属的group，一个是enabled，默认值True。 值为False时， test_finder会把这个测试类略过。<br>5.@Test（）， 测试装饰类， 函数接受一个参数enabled，默认值True。 值为False时， test_finder会把这个测试函数略过。<br>6.@data_provider（）， 数据驱动装饰器。 接受一个参数，且此参数必须要iterable. 因为是数据驱动，不太可能只有一个数据，所以这个iterable，我通常我会定义成一个tuple，如果 有多个就是多个tuple， 例如[(1,2,3),(4,5,6)]这种，（1，2，3）会被解析成一条测试数据， （4，5，6）会被解析成另外一条。 这个概念来自ddt，我之前也介绍过相关框架。<br>7.@setUP（）， @tearDown().两个函数，每个测试类必须定义，否则运行时框架会报错。 用作每个测试类的测试函数即每一条测试用例的运行前初始化和运行后的清理。<br>定义一次， 由它装饰的函数会在每个测试用例运行前后调用。 一般在里面初始化web browser和 API的 session。</p><p>测试函数，就是以@Test（）装饰的函数，一般是你的业务代码，你需要自己实现业务流程的操作和断言。如果用到setUpClass或者setUp里的方法属性，你只需要在这些属性前加self.<br>它不像pytest或者unittest，此函数名不必以test开头或结尾。</p><p>以上基本参照了pytest和unittest的用法，主要初衷也是为了减少迁移成本。</p><p>好，我测试类，测试函数都写好了，如何跑呢？</p><h4 id="可用参数"><a href="#可用参数" class="headerlink" title="可用参数"></a>可用参数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#最简单在命令行里输入ktest 即可， 框架会自动查询所有你项目文件下tests文件夹的测试用例。</div><div class="line">#ktest还支持如下参数：</div><div class="line">usage: ktest [-h]</div><div class="line">             [-t test     targets, should be either folder or .py file, this should be the root folder of your test cases or .py file of your test classes.]</div><div class="line">             [-i user provided tags,     string only, separate by comma without an spacing among all tags. if any user provided     tags are defined in test class, the test class will be considered to run. | -ai user provided tags,    string only, separate by comma without an spacing among all tags.    only all of user provided tags are defined in test class, the test class will be considered to run.]</div><div class="line">             [-e user provided tags,     string only, separate by comma without an spacing among all tags,if any user provided     tags are defined in test class, the test class will be Excluded. | -ae user provided tags,    string only, separate by comma without an spacing among all tags.    all the provided tags must defined in test class as well.]</div><div class="line">             [-I include groups,     string only, separated by comma for each tag.    if any user provided groups are defined in decorator on top of test class, the test class will be considered to run. | -AI exclude groups,     string only, separated by comma for each tag.    all user provided groups are defined in decorator on top of test class, the test class which match will be excluded to run.]</div><div class="line">             [-E exclude groups,    defined in decorator on top of test class, string only, separated by comma for each tag.     If any user provided groups are defined in decorator on top of test class, the test class will be Excluded to run | -AE exclude groups,    defined in decorator on top of test class, string only, separated by comma for each tag.     All user provided groups must defined in decorator on top of test class. the test class which matched will be Excluded to run]</div><div class="line">             [-n int number] [-r dir]</div></pre></td></tr></table></figure><p>其中：<br>-t 是你要运行的测试目标的根目录，默认是项目下的tests文件夹。<br>-i 是测试类里定义的tags。 tags会被解析成list，用户指定的任何tag只要包含在这个lists里，并且这个测试函数所属的TestClass（）是enabled和这个测试函数的enabled是True，就表示这个测试类的这个测试函数会被test_filder找到。<br>-I 是装饰测试类的@TestClass（）定义的group，包含两个参数， 符合用户指定的group并enabled， 那么它装饰的类会被当作一个测试类被test_finder找到。<br>-e 是测试类里定义的tags。 tags会被解析成list。 用户指定的任何tags包含在list里，这个测试函数就会被test_finder忽略。<br>-E 是测试类里定义的tags。 tags会被解析成list。 用户指定的任何tags包含在list里，这个测试函数就会被test_finder忽略。<br>-n 并发执行的个数，默认是cpu_count。<br>-r 错误重跑， 默认是True。重跑再错误，所有跟case相关的log和screenshot会被记录。</p><p>Note：<br>1.这种默认下，测试用例（测试类）的tags解析出来的的任意子集，如果用户指定的group或者tag是包含它，那么他会被test_finder找到。 比如-test就跑包括了test这个tag的用例。 比如你有两个测试类，一个测试类的tag是test，另外一个测试类的tags是regression，  用户给了-i test,regression. 那么这两个测试类所属的测试用例都会被扫描到并且添加进待测list里。<br>2.所有的用户输入只支持str。 tag本身不必要加引号，除非它在测试类里也加了引号。 且多个tag直接用逗号隔开即可，不必加空格。<br>有的同学会问了，我希望跑同时包括test和regression在内这两个tags的用例呢？ 谁提出的这个需求？我真想指着你的鼻子说：<br>没有问题，统统实现！<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"># 定义了tag和group的更加严格版。只有用户输入的参数全部包含在测试用例定义的tags里，这个测试用例才会被test_finder扫描到。</div><div class="line">  -ai user provided tags,    string only, separate by comma without an spacing among all tags.    only all of user provided tags are defined in test class, the test class will be considered to run.</div><div class="line">                        Select test cases to run by tags, separated by comma,</div><div class="line">                        no blank space among tag values. all user provided</div><div class="line">                        tags must defined in test class as well. tags are</div><div class="line">                        defined in test class with name &lt;tags&gt;. eg: tags =</div><div class="line">                        ['smoke', 'regression']. tags value in test class can</div><div class="line">                        be string, tuple or list.</div><div class="line"> </div><div class="line">  -ae user provided tags,    string only, separate by comma without an spacing among all tags.    all the provided tags must defined in test class as well.</div><div class="line">                        Exclude test cases by tags, separated by comma, no</div><div class="line">                        blank space among tag values. all of the tags user</div><div class="line">                        provided must in test class as well. tags are defined</div><div class="line">                        in test class with name &lt;tags&gt;. eg: tags = ['smoke',</div><div class="line">                        'regression']. tags value in test class can be string,</div><div class="line">                        tuple or list.</div><div class="line"></div><div class="line">  -AI exclude groups,     string only, separated by comma for each tag.    all user provided groups are defined in decorator on top of test class, the test class which match will be excluded to run.</div><div class="line">                        Select test cases belong to groups, separated by</div><div class="line">                        comma, no blank space among group values. All user</div><div class="line">                        provided group must defined in decorator on top of</div><div class="line">                        test class, the test class which match will be</div><div class="line">                        collected. groups are defined in decorator on top of</div><div class="line">                        test class. eg: group= 'UI'.</div><div class="line"> </div><div class="line">  -AE exclude groups,    defined in decorator on top of test class, string only, separated by comma for each tag.     All user provided groups must defined in decorator on top of test class. the test class which matched will be Excluded to run</div><div class="line">                        Exclude test cases belong to groups, separated by</div><div class="line">                        comma, no blank space among group values. All of</div><div class="line">                        groups user provided must defined in decorator on top</div><div class="line">                        of test class as well. groups are defined in decorator</div><div class="line">                        on top of test class. eg: group= 'UI'.</div><div class="line">#事实上， 为避免用法繁琐及方便用户， -i 和-ai， -e和-ae, -I和-AI, -E和-AE 是两两互斥的， 你只能指定其中的一个。</div></pre></td></tr></table></figure></p><h4 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h4><p>下面我们看下一个运行实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ktest -I group -n <span class="number">10</span> -r <span class="keyword">True</span></div></pre></td></tr></table></figure><br>执行中console的输出：<br><img src="/2018/12/29/测试框架/自研测试框架Ktest介绍/run_console.JPG" alt=""></p><h4 id="执行成功后报告的展示："><a href="#执行成功后报告的展示：" class="headerlink" title="执行成功后报告的展示："></a>执行成功后报告的展示：</h4><p>report会自动生成在你项目根目录下，以运行时时间戳为文件夹，每个测试用例一个子文件夹<br><img src="/2018/12/29/测试框架/自研测试框架Ktest介绍/html_report_folder.JPG" alt=""></p><p>测试报告加入了run pass， run fail， run error的图表。 run fail代表真正的fail， run error代表代码有问题或者环境问题导致的错误。<br>同样报告直接按照测试类filter。<br><img src="/2018/12/29/测试框架/自研测试框架Ktest介绍/html_report.JPG" alt=""></p><h4 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h4><p>到此为止，ktest基本成型，也能根据需求完成web UI自动化和API自动化的工作了，不同无非是你在setUP初始化你的driver时候初始化的是你的browser还是request.session. 如果你想实现分布式并发，也可以在setUP initial selenium Grid， 前提是配置好selenium-server。</p><h4 id="还是有一些感悟："><a href="#还是有一些感悟：" class="headerlink" title="还是有一些感悟："></a>还是有一些感悟：</h4><p>1.框架真不是一蹴而就的，是逐渐演化的。 最后成型的这一版跟我初始的规划还是有很大差距，有些代码甚至是不得已的妥协，比如我要出html报告，就要很多测试函数无关的数据收集，那么这些数据势必会侵入我的代码，结果就是我返回的测试函数数据结构很不简洁。<br>2.我最得意的是没有用大家都推崇的多线程threading.Thread，整个框架没有一行threading.Threadd 代码而实现了多线程并发，可阅读性增加了，而且我的代码量也因此少了三分之一， 虽然踩了不少坑，但也证明条条大路通罗马，只要理论通了，怎么实现，完全看个人喜欢。实际上threading.Thread实现太过繁琐，我几乎是一开始就否定了它。<br>3.你完全不需要搭积木， 一砖一瓦也能创建出漂亮的房子。</p><h4 id="彩蛋："><a href="#彩蛋：" class="headerlink" title="彩蛋："></a>彩蛋：</h4><p>放部分代码段：<br><img src="/2018/12/29/测试框架/自研测试框架Ktest介绍/set_up_class_decorator.JPG" alt=""><br><img src="/2018/12/29/测试框架/自研测试框架Ktest介绍/test_finder.JPG" alt=""><br>关于更多技术实现细节，我会重新写一篇文章介绍。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试框架实践--实现TestFixture</title>
      <link href="/2018/11/24/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%AE%9E%E7%8E%B0TestFixture/"/>
      <url>/2018/11/24/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%AE%9E%E7%8E%B0TestFixture/</url>
      
        <content type="html"><![CDATA[<p>前面几期分享我实现了一个可以并发运行的”框架“， 其实只能叫半成品， 但好歹可以并发运行， 测试用例动态挑选了。那么还少了什么呢？<br>一个测试类，通常有多个测试方法，有时候一个或多个测试方法都需要某些共用的”数据“， 比如说都要访问某个数据库的某张表，比如说都需要起浏览器，都需要调用post方法等。 这个时候每个测试用例单独写就显得很多余，TestFixture就应运而生。<br><a id="more"></a><br>我们先来看下Test Fixture的定义：</p><blockquote><p>A test fixture represents the preparation needed to perform one or more tests, and any associate cleanup actions. This may involve, for example, creating temporary or proxy databases, directories, or starting a server process.</p></blockquote><p>由此可见，Test Fixture用在测试方法前，或者测试方法后，主要功能是提供一些测试需要用的装置，这些装置可以是数据，可以是环境配置也可以是一个运行前状态。<br>Fixture有下面两种：</p><blockquote><p>setup(), teardown（）的方式，分别在每个测试方法执行前后执行。<br>setUpClass（）， tearDownClass（）的方式，分别在每个测试类执行前后执行, setUpClass（）和tearDownClass（）只会执行一次，即使这个测试类有多个测试函数。<br>我们在实现这个之前，先看下上次我们实现并发时，真正执行一个测试函数的代码块， 它的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(case)</span>:</span></div><div class="line">    name, func, value = case</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">if</span> value:</div><div class="line">            func.__call__(name, *value)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            func.__call__(name)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="comment"># traceback.print_exc()</span></div><div class="line">        cases_run_fail.append(name)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        cases_run_success.append(name)</div><div class="line">    <span class="keyword">return</span> cases_run_fail, cases_run_success</div></pre></td></tr></table></figure><br>这个代码块是针对每一个测试函数的，那么我们多线程运行时，每个测试函数都会执行这段代码，这样就好办了，直接把setup和teardown加进来就能实现每个测试函数都执行setup和teardown方法了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(case)</span>:</span></div><div class="line">    cls， name, func, value = case</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">    <span class="comment"># Run setUP method for each test method.</span></div><div class="line"><span class="comment">#看这里</span></div><div class="line">        getattr(cls, <span class="string">"setUp"</span>).__call__(cls) </div><div class="line"></div><div class="line">        <span class="keyword">if</span> value:</div><div class="line">            func.__call__(name, *value)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            func.__call__(name)</div><div class="line"></div><div class="line"><span class="comment">#看这里</span></div><div class="line"><span class="comment"># Run tearDown method for each test method.</span></div><div class="line">        getattr(cls, <span class="string">"tearDown"</span>).__call__(cls)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="comment"># traceback.print_exc()</span></div><div class="line">        cases_run_fail.append(name)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        cases_run_success.append(name)</div><div class="line">    <span class="keyword">return</span> cases_run_fail, cases_run_success</div></pre></td></tr></table></figure><br>可以看到这个函数传入的参数也改变了，case的值里加入了cls这个类。要达成这个效果， 相当于如何根据测试方法找到所属的测试类，利用inspect模块很简单的就拿到了。<br>当然你也可以用<strong>name</strong>拿到函数名。</p></blockquote><p>setup和teardown这两个方法每个测试用例都会执行，看到这里想明白了吗？这就意味着如果你在这里做初始化浏览器的操作，那么这个框架就可以做UI自动化，如果你做的是HTTP的get或者post的操作，那么这个框架也就是API接口框架。</p><p>setup和teardown实现了。我们再来看下setUpClass, tearDownClass的实现。那么我是怎么共享线程间的变量呢？</p><p>常规情况下，我们可以用数据持久化的方式实现，具体来说，就是每个测试函数执行时候先去找一个文件，这个文件在就不再执行setUpClass，当然你得做好线程安全。<br>大家还记得我的多线程是怎么实现的呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#多线程部分代码</span></div><div class="line"><span class="keyword">with</span> ThreadPool(number_of_threads) <span class="keyword">as</span> p:</div><div class="line">p.map(f, cases_to_run)</div><div class="line">p.close()</div><div class="line">p.join()</div></pre></td></tr></table></figure><br>对于每一个线程，都去调用f函数，这个函数就是上方实现了每个函数setup和teardown的f。<br>现在好了，我们用map可以不关心这些，直接嵌套实现：<br>我把所有的用例重新组织，形成一种特殊的数据结构，具体来说，就是每个测试类和属于这个测试类的所有函数， 以如下方式组织(cls, [cls.method1, cls.method2])<br>最终所有的测试类，在放到一个列表对象里。<br>这样第一层次的并发，是基于测试类的，然后针对每一个测试类，我再进行并发。<br>具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#部分代码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(case)</span>:</span></div><div class="line"><span class="comment">#cls是测试类</span></div><div class="line">    cls = case[<span class="number">0</span>]</div><div class="line"><span class="comment">#func_pack是测试函数及所有参数</span></div><div class="line">    func_pack = case[<span class="number">1</span>] </div><div class="line"></div><div class="line"><span class="comment">#实现setUPClass</span></div><div class="line"><span class="comment">#到这一层只是类并发，真正的测试函数还没有并发。</span></div><div class="line"><span class="comment">#setUPClass应该做到测试类有设置就执行，否则就不执行。</span></div><div class="line">    handle_before_class_fixture(cls)</div><div class="line"></div><div class="line">    p = ThreadPool(number_of_threads)</div><div class="line"><span class="comment">#真正的测试函数并发</span></div><div class="line"><span class="comment">#这个func_run就相当于我们之前的f。</span></div><div class="line">    p.map(func_run, func_pack)</div><div class="line">    p.close()</div><div class="line">    p.join()</div><div class="line"></div><div class="line"><span class="comment">#实现tearDownClass</span></div><div class="line">    handle__after_class_fixture(cls)</div></pre></td></tr></table></figure><br>为了验证正确性，我把我们的测试类和方法改进如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@TestClass()</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSumData</span>:</span></div><div class="line"><span class="meta">    @BeforeClass()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before_class</span><span class="params">(cls)</span>:</span></div><div class="line">        print(<span class="string">"haha"</span>)</div><div class="line">        cls.status = <span class="number">1</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Now starting"</span>)</div><div class="line"><span class="meta">    @data_provider([(1, 2, 3), (4, 5, 9)])</span></div><div class="line"><span class="meta">    @Test()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_data</span><span class="params">(self, x, y, z)</span>:</span></div><div class="line">        print(<span class="string">'Case &#123;0&#125; are running with data &#123;1&#125; -- thread id &#123;2&#125;'</span>.format(</div><div class="line">            self, (x, y, z), current_process()))</div><div class="line">        print(self.status)</div><div class="line">        <span class="keyword">assert</span> SumData().sum_data(x, y) == z</div><div class="line"><span class="meta">    @Test(enabled=True)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_data2</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'Case &#123;0&#125; are running with data &#123;1&#125; -- thread id &#123;2&#125;'</span>.format(</div><div class="line">            self, <span class="keyword">None</span> , current_process()))</div><div class="line">        print(self.status)</div><div class="line">        <span class="keyword">assert</span> SumData().sum_data(<span class="number">4</span>, <span class="number">5</span>) == <span class="number">7</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">"Now finished"</span>)</div><div class="line"><span class="meta">    @AfterClass()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">after_class</span><span class="params">(cls)</span>:</span></div><div class="line">        cls.status =<span class="number">0</span></div></pre></td></tr></table></figure><br>跑一下看看：<br><img src="/2018/11/24/测试框架/测试框架实践--实现TestFixture/test_fixture.JPG" alt=""></p><p>可以看到，cls.status这个共享数据，成功被测试函数接收到了。 setUpClass（我这里对应before_class）也成功运行， 且只运行了一次。</p><p>毫无破绽：）</p><p>到此为止，我已经实现了一个测试框架的绝大数功能，下一步，就要改造我的log还有接收用户参数了，敬请期待。<br>历史文章：<br><a href="https://helloqa.com/2018/09/17/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A81/" target="_blank" rel="external">测试框架–教你用Python实现数据驱动1</a><br><a href="https://helloqa.com/2018/09/18/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A82/" target="_blank" rel="external">测试框架–教你用Python实现数据驱动2</a><br><a href="https://helloqa.com/2018/09/25/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/" target="_blank" rel="external">测试框架–数据驱动动态增加测试用例</a><br><a href="https://helloqa.com/2018/11/13/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%8A%A8%E6%80%81%E6%8C%91%E9%80%89%E5%BE%85%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/" target="_blank" rel="external">测试框架实践–动态挑选待运行测试用例</a><br><a href="https://helloqa.com/2018/11/16/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="external">Python测试框架实现(五)–多线程</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试框架实践--多线程</title>
      <link href="/2018/11/16/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/11/16/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>前面几次的分享，我从一个数据驱动的实现展开去，先后讨论了什么是数据驱动，如何实现数据驱动，数据驱动在自动化框架里如何应用。<br><a href="https://helloqa.com/2018/09/17/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A81/" target="_blank" rel="external">测试框架–教你用Python实现数据驱动1</a><br><a href="https://helloqa.com/2018/09/18/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A82/" target="_blank" rel="external">测试框架–教你用Python实现数据驱动2</a><br><a href="https://helloqa.com/2018/09/25/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/" target="_blank" rel="external">测试框架–数据驱动动态增加测试用例</a><br><a href="https://helloqa.com/2018/11/13/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%8A%A8%E6%80%81%E6%8C%91%E9%80%89%E5%BE%85%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/" target="_blank" rel="external">测试框架实践–动态挑选待运行测试用例</a></p><p>为什么要讲这些呢？<br><a id="more"></a></p><p>因为这些是一个测试框架必不可少的部分，看看前面4次的分享，虽然可以成功的运行，但我们采用了顺序运行的方式，跟实际使用相差很远，现实中我们一般实现“并发”运行我们的测试用例。</p><p>说起并发，Python 有多线程（Multiple Threading）和多进程（Multiple Process）之分， 由于GIL即Global Interpreter Lock(全局解释器锁)的存在，python多线程并不能实现真正的并发（无论你的CPU是否多核），相反，多进程因为有独占的内存空间可以真正的实现并发。但在我们的自动化测试框架里，我们还是希望利用线程的公用内存空间特性，特别是同一个测试类我们希望有统一的setup， teardown特性。而这个多进程就不太适用，加上我们测试用例也不是CPU计算密集型，多线程方案的“并发”看起来是最佳选择。</p><p>但是是不是就一定要用threading.Thread呢？</p><p>我们先看看”传统“的多线程并发。 一个通用的多线程模板是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> queue</div><div class="line"><span class="keyword">import</span> time</div><div class="line">exitFlag = <span class="number">0</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, q)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.q = q</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        do_something(self.q)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(q)</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> exitFlag:</div><div class="line">        queue_lock.acquire()</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> work_queue.empty():</div><div class="line">            data = q.get()</div><div class="line">            queue_lock.release()</div><div class="line">            print(<span class="string">"Now thread %s is processing %s"</span> % (threading.currentThread(), data))</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            queue_lock.release()</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    num_worker_threads = <span class="number">3</span></div><div class="line">    target_case = [<span class="string">'case1'</span>, <span class="string">'case2'</span>, <span class="string">'case3'</span>, <span class="string">'case4'</span>, <span class="string">'case5'</span>]</div><div class="line">    queue_lock = threading.Lock()</div><div class="line">    work_queue = queue.Queue()</div><div class="line">    threads = []</div><div class="line">    start_time = time.time()</div><div class="line">    <span class="comment"># Create new thread</span></div><div class="line">    <span class="keyword">for</span> case <span class="keyword">in</span> range(num_worker_threads):</div><div class="line">        thread = MyThread(work_queue)</div><div class="line">        thread.start()</div><div class="line">        threads.append(thread)</div><div class="line">    <span class="comment"># Fill queue</span></div><div class="line">    queue_lock.acquire()</div><div class="line">    <span class="keyword">for</span> case <span class="keyword">in</span> target_case:</div><div class="line">        work_queue.put(case)</div><div class="line">    queue_lock.release()</div><div class="line">    <span class="comment"># Wait queue empty</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> work_queue.empty():</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="comment"># Notify thread quite</span></div><div class="line">    exitFlag = <span class="number">1</span></div><div class="line">    <span class="comment"># Wait all threads done</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.join()</div><div class="line">    end_time = time.time()</div><div class="line">    print(<span class="string">"All cases finished with running time --%s"</span> % (end_time - start_time))</div></pre></td></tr></table></figure><br>把我们前面实现的顺序运行改成并发， 只需要改成如下就可以实现多线程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> queue</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> common.test_case_finder <span class="keyword">import</span> DiscoverTestCases, unpack_test_cases_from_functions</div><div class="line">exitFlag = <span class="number">0</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(case)</span>:</span></div><div class="line">    name, func, value = case</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">if</span> value:</div><div class="line">            func.__call__(name, *value)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            func.__call__(name)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="comment"># traceback.print_exc()</span></div><div class="line">        cases_run_fail.append(name)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        cases_run_success.append(name)</div><div class="line">    <span class="keyword">return</span> cases_run_fail, cases_run_success</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, q)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.q = q</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> exitFlag:</div><div class="line">            queue_lock.acquire()</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> work_queue.empty():</div><div class="line">                data = self.q.get()</div><div class="line">                f(data)</div><div class="line">                time.sleep(<span class="number">5</span>)</div><div class="line">                queue_lock.release()</div><div class="line">                print(<span class="string">"Now thread %s is processing %s"</span> % (threading.currentThread(), data))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                queue_lock.release()</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    num_worker_threads = <span class="number">5</span></div><div class="line">    mypath = <span class="string">r"D:\ktest\tests\test_page1"</span></div><div class="line">    cases_to_run = []</div><div class="line">    cases_run_success = []</div><div class="line">    cases_run_fail = []</div><div class="line">    discover_cases = DiscoverTestCases(mypath)</div><div class="line">    mds = discover_cases.get_modules_spec()</div><div class="line">    raw_test_cases = discover_cases.find_classes_in_module(mds)</div><div class="line">    cases_to_run = unpack_test_cases_from_functions(raw_test_cases)</div><div class="line">    queue_lock = threading.Lock()</div><div class="line">    work_queue = queue.Queue()</div><div class="line">    threads = []</div><div class="line">    start_time = time.time()</div><div class="line">    <span class="comment"># Create new thread</span></div><div class="line">    <span class="keyword">for</span> case <span class="keyword">in</span> range(num_worker_threads):</div><div class="line">        thread = MyThread(work_queue)</div><div class="line">        thread.start()</div><div class="line">        threads.append(thread)</div><div class="line">    <span class="comment"># Fill queue</span></div><div class="line">    queue_lock.acquire()</div><div class="line">    <span class="keyword">for</span> case <span class="keyword">in</span> cases_to_run:</div><div class="line">        work_queue.put(case)</div><div class="line">    queue_lock.release()</div><div class="line">    <span class="comment"># Wait queue empty</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">not</span> work_queue.empty():</div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="comment"># Notify thread quite</span></div><div class="line">    exitFlag = <span class="number">1</span></div><div class="line">    <span class="comment"># Wait all threads done</span></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.join()</div><div class="line">    end_time = time.time()</div><div class="line">    print(<span class="string">"All cases finished with running time --&#123;:.2f&#125; seconds"</span> .format(end_time - start_time))</div><div class="line">    print(<span class="string">'Below cases are passed:\n %s'</span> %cases_run_success)</div><div class="line">    print(<span class="string">'Below cases are failed:\n %s'</span> % cases_run_fail)</div></pre></td></tr></table></figure><br>可以看到，你自己要做很多事情来保证多线程的正常运行，你要维护queue，要注意资源锁，你要使用join来等待子线程都完成。 多线程难道都这么麻烦吗？</p><p>“人生苦短，我用python”不知道你们听过没 ：）</p><p>multiprocessing.dummy 来助你一臂之力！</p><p>dummy是multiprocessing的一个克隆体，唯一的区别在于，dummy使用线程而multiprocessing使用进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> common.test_case_finder <span class="keyword">import</span> DiscoverTestCases, unpack_test_cases_from_functions</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(case)</span>:</span></div><div class="line">    name, func, value = case</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">if</span> value:</div><div class="line">            func.__call__(name, *value)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            func.__call__(name)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="comment"># traceback.print_exc()</span></div><div class="line">        cases_run_fail.append(name)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        cases_run_success.append(name)</div><div class="line">    <span class="keyword">return</span> cases_run_fail, cases_run_success</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    number_of_threads = <span class="number">5</span></div><div class="line">    mypath = <span class="string">r"D:\ktest\tests\test_page1"</span></div><div class="line">    cases_to_run = []</div><div class="line">    cases_run_success = []</div><div class="line">    cases_run_fail = []</div><div class="line">    discover_cases = DiscoverTestCases(mypath)</div><div class="line">    mds = discover_cases.get_modules_spec()</div><div class="line">    raw_test_cases = discover_cases.find_classes_in_module(mds)</div><div class="line">    cases_to_run = unpack_test_cases_from_functions(raw_test_cases)</div><div class="line">    start_time = time.time()</div><div class="line">    <span class="keyword">with</span> ThreadPool(number_of_threads) <span class="keyword">as</span> p:</div><div class="line">        p.map(f, cases_to_run)</div><div class="line">    p.close()</div><div class="line">    p.join()</div><div class="line">    end_time = time.time()</div><div class="line">    print(<span class="string">'Below cases are passed:\n %s'</span> %cases_run_success)</div><div class="line">    print(<span class="string">'Below cases are failed:\n %s'</span> % cases_run_fail)</div><div class="line">    print(<span class="string">"All cases finished with running time --&#123;:.2f&#125; seconds"</span> .format(end_time - start_time))</div></pre></td></tr></table></figure><br>看下图，左边是传统的threading.Thread的多线程用法， 右边是multipleprocess.dummy的用法。<br><img src="/2018/11/16/测试框架/测试框架实践--多线程/multipleprocess_threading.png" alt=""><br>除开定义Thread类外，threading.Thread还用了这么多篇幅才能令多线程工作，但multiprocessing.dummy只用一个Pool就全搞定了。</p><p>好了，今天我们讲到这里，并发也实现了，动态挑选也实现了，一个测试框架就搭起来来， 后面就是增强了， 下一期来实现test fixture， 敬请期待！</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试框架实践--动态挑选待运行测试用例</title>
      <link href="/2018/11/13/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%8A%A8%E6%80%81%E6%8C%91%E9%80%89%E5%BE%85%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
      <url>/2018/11/13/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5--%E5%8A%A8%E6%80%81%E6%8C%91%E9%80%89%E5%BE%85%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>前面几天， 我从数据驱动的一个第3方库ddt出发，连续分享了3篇文章：<br><a href="https://helloqa.com/2018/09/17/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A81/" target="_blank" rel="external">测试框架–教你用Python实现数据驱动1</a><br><a href="https://helloqa.com/2018/09/18/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A82/" target="_blank" rel="external">测试框架–教你用Python实现数据驱动2</a><br><a href="https://helloqa.com/2018/09/25/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/" target="_blank" rel="external">测试框架–数据驱动动态增加测试用例</a><br>后面两篇文章实际上是任何一个测试框架都必须要有的部分。 今天我再分享一篇如何动态挑选测试用例， 大家知道，自动化脚本越写越多，但不是每次都需要full regression， 这个时候需要把开发修改涉及到的测试用例跑一下，而那些无关的用例可以不跑。<br><a id="more"></a></p><p>那么，思路是什么？ 如果对每一个用例，我定义的时候给一个标签比如说Test，再给它一个值，True或False，这样我框架寻找测试用例的时候就找标签编辑为Test且值是True的就好了。<br>老规矩，先上代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># test_decorator.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">TestClass</span><span class="params">(enabled=True)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(cls)</span>:</span></div><div class="line">        setattr(cls, <span class="string">"__test_type__"</span>, <span class="string">"TestClass"</span>)</div><div class="line">        setattr(cls, <span class="string">"__enabled__"</span>, enabled)</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line">    <span class="keyword">return</span> wraps</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Test</span><span class="params">(enabled= True)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(func)</span>:</span></div><div class="line">        setattr(func, <span class="string">"__test_type__"</span>, <span class="string">"Test"</span>)</div><div class="line">        setattr(func, <span class="string">"__enabled__"</span>, enabled)</div><div class="line">        <span class="keyword">return</span> func</div><div class="line">    <span class="keyword">return</span> wraps</div><div class="line"><span class="comment"># 利用装饰器，对于每一个进来的类或func，</span></div><div class="line"><span class="comment">#我们给它加上一个属性一个值，然后再你需要运行的类或者func上装饰就好了。</span></div><div class="line"></div></pre></td></tr></table></figure><br>结合我们上次讲过的动态添加测试用例， 和数据驱动，我们把这部分整合起来看看，一个简单完整的测试框架如下。<br>1.从指定的文件夹/文件下查找待运行测试类/方法<br>2.找到待运行测试类/方法，并根据数据不同重新生成测试用例<br>3.运行测试用例集并保存运行结果</p><p>我的整个项目层次结构是这样的：<br><img src="/2018/11/13/测试框架/测试框架实践--动态挑选待运行测试用例/structor.JPG" alt=""><br>其中：<br>Common:<br>放通用的功能，比如，查找待测试用例的test_case_finder, 和我们上文的定义是否测试类/测试函数的装饰器test_decorator<br>pages<br>放我们所有的页面功能，如果是UI测试，这个就对应于一个个的UI Page，我们将以Page Object组织页面元素，并定义页面类和方法，每一个页面当作一个page看待并定义一个类<br>tests<br>这个下面放我们的测试用例，结构跟pages完全对应，每一个测试类对应于一个page 类。<br>run<br>这个文件定义了用例如何运行，是并行还是顺序。</p><p>还有其它的很多功能，我们暂且不讲，先来看看这几个如何协作的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># pages/page_add.py</span></div><div class="line"><span class="comment">#我们就定义个多数相加的方法。</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumData</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum_data</span><span class="params">(self, *ags)</span>:</span></div><div class="line">        <span class="keyword">return</span> sum(ags)</div></pre></td></tr></table></figure><br>再看它对应的测试类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># tests/test_page1/test_page_add.py</span></div><div class="line"><span class="comment">#这里面我定义了两个测试方法，一个要参数，一个不要。</span></div><div class="line"><span class="comment">#并且用了两个装饰类，一个用来提供测试数据，一个用来标记是否需要测试</span></div><div class="line"><span class="keyword">from</span> common.test_case_finder <span class="keyword">import</span> data_provider</div><div class="line"><span class="keyword">from</span> common.test_decorator <span class="keyword">import</span> Test</div><div class="line"><span class="keyword">from</span> pages.page_add <span class="keyword">import</span> SumData</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSumData</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"><span class="meta">    @data_provider([(1, 2, 3), (4, 5, 9)])</span></div><div class="line"><span class="meta">    @Test()</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_data</span><span class="params">(self, x, y, z)</span>:</span></div><div class="line">        print(<span class="string">"the value are &#123;0&#125;, &#123;1&#125;, &#123;2&#125;"</span>.format(x, y, z))</div><div class="line">        <span class="keyword">assert</span> SumData().sum_data(x, y) == z</div><div class="line"><span class="meta">    @Test(enabled=False)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_data2</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="number">2</span>)</div><div class="line">        <span class="keyword">assert</span> SumData().sum_data(<span class="number">4</span>, <span class="number">5</span>) == <span class="number">7</span></div></pre></td></tr></table></figure><br>这两个装饰类的定义Test（）我们前面已经介绍过了，test provider定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_provider</span><span class="params">(test_data)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">        setattr(func, <span class="string">"__data_Provider__"</span>, test_data)</div><div class="line">        <span class="keyword">global</span> index_len</div><div class="line">        index_len = len(str(len(test_data)))</div><div class="line">        <span class="keyword">return</span> func</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure><br>好了，有了page类，有个test类，那么如何让我们的程序查找到我们需要运行的测试用例呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#test_case_finder.py</span></div><div class="line"><span class="comment"># 简化下，只给出如何鉴别待运行的用例</span></div><div class="line"><span class="comment">#mod_ref就是我们动态加载进来的所有测试module。</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_classes_in_module</span><span class="params">(self, mod_ref)</span>:</span></div><div class="line">test_classes = []</div><div class="line"><span class="keyword">for</span> module <span class="keyword">in</span> mod_ref:</div><div class="line"><span class="comment">#微信关注公众号iTesting，加入万人测试团</span></div><div class="line">cls_members = inspect.getmembers(module, inspect.isclass)</div><div class="line"><span class="keyword">for</span> cls <span class="keyword">in</span> map(<span class="keyword">lambda</span> x: x[<span class="number">1</span>], cls_members):</div><div class="line"><span class="keyword">for</span> name, func <span class="keyword">in</span> list(cls.__dict__.items()):</div><div class="line"><span class="keyword">if</span> hasattr(func, <span class="string">"__test_type__"</span>) <span class="keyword">and</span> hasattr(func, <span class="string">"__enabled__"</span>):</div><div class="line"><span class="keyword">if</span> getattr(func, <span class="string">"__test_type__"</span>) == <span class="string">"Test"</span> <span class="keyword">and</span> getattr(func, <span class="string">"__enabled__"</span>) == <span class="keyword">True</span>:</div><div class="line">test_classes.append(func)</div><div class="line"><span class="keyword">return</span> test_classes</div></pre></td></tr></table></figure><br>那么，用例找出来了，如何数据驱动呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#test_case_finder.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mk_test_name</span><span class="params">(name, value, index=<span class="number">0</span>)</span>:</span></div><div class="line">    index = <span class="string">"&#123;0:0&#123;1&#125;&#125;"</span>.format(index+<span class="number">1</span>, index_len)</div><div class="line">    test_name = <span class="string">"&#123;0&#125;_&#123;1&#125;_&#123;2&#125;"</span>.format(name, index, value)</div><div class="line">    <span class="keyword">return</span> re.sub(<span class="string">r'\W|^(?=\d)'</span>, <span class="string">'_'</span>, test_name)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">unpack_test_cases_from_functions</span><span class="params">(func_list)</span>:</span></div><div class="line">    return_cases = []</div><div class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> func_list:</div><div class="line">        <span class="keyword">if</span> hasattr(func,  <span class="string">'__data_Provider__'</span>):</div><div class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(getattr(func, <span class="string">"__data_Provider__"</span>)):</div><div class="line">                test_name = mk_test_name(func.__name__, getattr(v, <span class="string">"__name__"</span>, v), i)</div><div class="line">                return_cases.append((test_name, func, v))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            return_cases.append((func.__name__, func, <span class="keyword">None</span>))</div><div class="line">    <span class="keyword">return</span> return_cases</div><div class="line"><span class="comment">#我们通过反射的方式找到有Test（）装饰的测试方法，并且只把enabled=True的测试方法放入我们的测试用例里。</span></div></pre></td></tr></table></figure><br>测试用例也找到了，该运行了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#run.py</span></div><div class="line"><span class="comment">#简化版, 实现了一个简单的顺序执行，我们后面将一步步优化至并发，顺序都可以</span></div><div class="line"><span class="keyword">import</span> traceback</div><div class="line"><span class="keyword">from</span> common.test_case_finder <span class="keyword">import</span> DiscoverTestCases, unpack_test_cases_from_functions</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">＃下面一句给定了查找测试用例的根目录，如果不给定，我们默认从ｔｅｓｔｓ文件夹找</div><div class="line">    mypath = <span class="string">r"D:\ktest\tests\test_page1"</span> </div><div class="line">    cases_to_run = []</div><div class="line">    cases_run_success = []</div><div class="line">    cases_run_fail = []</div><div class="line">    discover_cases = DiscoverTestCases(mypath)</div><div class="line">    mds = discover_cases.get_modules_spec()</div><div class="line">    cases_to_run = unpack_test_cases_from_functions(discover_cases.find_classes_in_module(mds))</div><div class="line">    <span class="keyword">while</span> cases_to_run:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            name, func, value = cases_to_run.pop(<span class="number">0</span>)</div><div class="line">            <span class="keyword">if</span> value:</div><div class="line">                func.__call__(name, *value)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                func.__call__(name)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="comment"># traceback.print_exc()</span></div><div class="line">            cases_run_fail.append(name)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            cases_run_success.append(name)</div><div class="line">    print(<span class="string">'Below cases are passed:\n %s'</span> %cases_run_success)</div><div class="line">    print(<span class="string">'Below cases are failed:\n %s'</span> % cases_run_fail)</div><div class="line"></div><div class="line">＃以上给定了一个简单的方法，找到所有的呆测试用例，</div><div class="line">＃然后一个个执行，并且将测试成功和失败用例集分别存放，方便后续测试报告的生成。</div></pre></td></tr></table></figure><br>运行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Below cases are passed:</div><div class="line"> [<span class="string">'test_sum_data_1__1__2__3_'</span>, <span class="string">'test_sum_data_2__4__5__9_'</span>]</div><div class="line">Below cases are failed:</div><div class="line"> []</div></pre></td></tr></table></figure><br>基本上实现了我们的需求，但是一个测试框架，要考虑的还很多，比如：<br>1.测试fixture，包括运行前准备和运行后清理。<br>2.并发执行<br>3.测试报告<br>4.邮件发送<br>5.错误截图<br>6.log记录</p><p>我后续将带你逐个击破，最终写出自己的测试框架，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Selenium Grid 简明用法</title>
      <link href="/2018/09/26/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Python%20Selenium%20Grid%20%E7%AE%80%E6%98%8E%E7%94%A8%E6%B3%95/"/>
      <url>/2018/09/26/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Python%20Selenium%20Grid%20%E7%AE%80%E6%98%8E%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>前几天有同学问我selenium gird的问题， 简要告知后才知道，selenium gird仍然在很多公司的自动化里占很大比重，我一直觉得在Jenkins这种持续集成工具大行其道的今天，selenium gird用来做分布式运行的工具已经可以寿终正寝了，看来还是行业不同，关注点就不同，整理了elenium gird用法，分享给大家。<br><a id="more"></a></p><h4 id="首先，-Selenium-Gird解决了一个什么问题？"><a href="#首先，-Selenium-Gird解决了一个什么问题？" class="headerlink" title="首先， Selenium Gird解决了一个什么问题？"></a>首先， Selenium Gird解决了一个什么问题？</h4><blockquote><p>Selenium-Grid allows you run your tests on different machines against different browsers in parallel. That is, running multiple tests at the same time against different machines running different browsers and operating systems. Essentially, Selenium-Grid support distributed test execution. It allows for running your tests in a distributed test execution environment.<br>简单的说， seleniumgrid允许你在不同的机器上针对不同浏览器并行运行测试。<br>也就是说，同时针对运行不同浏览器和操作系统的不同机器同时运行多个测试。基本上，Selenium-Grid支持分布式测试执行。它允许在分布式测试执行环境中运行测试。</p></blockquote><h4 id="其次，何时使用？"><a href="#其次，何时使用？" class="headerlink" title="其次，何时使用？"></a>其次，何时使用？</h4><blockquote><p>To run your tests against multiple browsers, multiple versions of browser, and browsers running on different operating systems.<br>要针对多个浏览器运行测试，可以在不同操作系统上运行多个版本的浏览器和浏览器。<br>To reduce the time it takes for the test suite to complete a test pass.<br>减少测试套件完成测试通行所需的时间。</p></blockquote><h4 id="然后，-它的原理是什么？"><a href="#然后，-它的原理是什么？" class="headerlink" title="然后， 它的原理是什么？"></a>然后， 它的原理是什么？</h4><p>Grid由单个Hub和一个或多个Node组成。两者都是使用selenium-server.jar可执行文件启动的。<br>hub接收要执行的测试以及应该运行测试的那个浏览器和platform（即WINDOWS，LINUX等）的信息。它知道已经register到hub的每个节点的配置。<br>它会在满足浏览器 - 平台组合的可用节点中选择一个。一旦选择了一个节点，一个测试发起的Selenium命令就被发送到hub，并将传递到分配给该测试的节点。<br>该节点运行浏览器，并在该浏览器内针对被测试应用程序执行Selenium命令。</p><h4 id="最后，-如何安装使用？"><a href="#最后，-如何安装使用？" class="headerlink" title="最后， 如何安装使用？"></a>最后， 如何安装使用？</h4><p>1.下载<a href="http://selenium-release.storage.googleapis.com/index.html" target="_blank" rel="external">Selenium-Server jar file</a>. 确保安装路径在系统的环境变量path里，这样你才能从command line访问。</p><p>2.启动hub节点<br>在command line里输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -jar selenium-server-standalone-&lt;version&gt;.jar -role hub</div></pre></td></tr></table></figure><br>成功后你会看到如下图：<br><img src="/2018/09/26/自动化测试系列/Python Selenium Grid 简明用法/Hub.JPG" alt=""><br>此命令会帮你自动注册一个hub，default 端口4444. 你可以通过网页<a href="http://localhost:4444/grid/console来查看。" target="_blank" rel="external">http://localhost:4444/grid/console来查看。</a><br><img src="/2018/09/26/自动化测试系列/Python Selenium Grid 简明用法/Hub_console.JPG" alt=""><br>3.启动node节点<br>在command line里输入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">java -jar selenium-server-standalone-&lt;version&gt;.jar -role node  -hub http://localhost:<span class="number">4444</span>/grid/register</div><div class="line"><span class="comment">#注意，你的node节点如果和hub节点不一个地址，你需要把-hub后面的的地址中的 localhost：4444换成真实的hub地址。</span></div></pre></td></tr></table></figure><br><img src="/2018/09/26/自动化测试系列/Python Selenium Grid 简明用法/node_register.JPG" alt=""><br>成功后，去Hhub节点的<a href="http://localhost:4444/grid/console来查看：" target="_blank" rel="external">http://localhost:4444/grid/console来查看：</a><br><img src="/2018/09/26/自动化测试系列/Python Selenium Grid 简明用法/grid_console.JPG" alt=""></p><p>注意Node节点的register有多个参数可以选择<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#register Node的时候加上如下参数， 相当于register了一个Linux上 3.6版本的firefox。</span></div><div class="line"> -browser  browserName=firefox,version=<span class="number">3.6</span>,platform=LINUX</div></pre></td></tr></table></figure><br>4.使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#还记得之前讲过的automation framework吗，我们利用下原来的脚本，仅仅把setup（）函数修改一番</span></div></pre></td></tr></table></figure><br><img src="/2018/09/26/自动化测试系列/Python Selenium Grid 简明用法/Run1.JPG" alt=""><br>运行命令如下：<br><img src="/2018/09/26/自动化测试系列/Python Selenium Grid 简明用法/Run1_command.JPG" alt=""></p><p>这就是跑单个用例的情况，如果你希望不同的用例跑在不同的机器上怎么办？<br>就多注册几个node节点，注册时加上<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#register Node的时候加上如下参数， 相当于register了一个Linux上 3.6版本的firefox。</span></div><div class="line"> -browser  browserName=firefox,version=<span class="number">3.6</span>,platform=LINUX</div></pre></td></tr></table></figure><br>然后代码里只要在setup 浏览器哪里指定浏览器名称就好了，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.browser = webdriver.Remote(command_executor=<span class="string">"http://localhost:4444/wd/hub"</span>,</div><div class="line">                                      desired_capabilities=&#123;</div><div class="line">                                          <span class="string">'platform'</span>: <span class="string">'ANY'</span>,</div><div class="line">                                          <span class="string">'browserName'</span>: <span class="string">"chrome"</span></div><div class="line">                                      &#125;)</div></pre></td></tr></table></figure><br>具体哪个node支持哪个browser可以在Hub上通过 <a href="http://localhost:4444/grid/console查看" target="_blank" rel="external">http://localhost:4444/grid/console查看</a><br><img src="/2018/09/26/自动化测试系列/Python Selenium Grid 简明用法/Hub_console_multiple.JPG" alt=""></p><p>有的同学就问了，selenium grid在多个机器上跑不同浏览器做到了，那么怎么做到并发呢？selenium grid本身不提供并发支持，需要自己写并发的代码，或者我们用pytest来看看如果并发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m pytest test --workers <span class="number">2</span> --tests-per-worker <span class="number">2</span> --html=<span class="number">222.</span>html</div></pre></td></tr></table></figure><p>结合前图就可以知道，selenium grid会根据你browser的设置去找register到grid上的对应的browser，找到就运行，这样就实现了并发，多机器同时运行。</p><p>5.总结<br>有的人说，我用Jenkins也可以做到同样的事情啊？可以建立多个job，每个job对应一个浏览器不就好了？ 的确如此， 但是你想这样一个场景，我想让这个用例运行在chrome 68及以上版本，同时还想有一些用例运行在chrome50以下版本，这样jenkins就麻烦了，需要配置不同的节点来运行。<br>但是selenium grid却都可把浏览器装在同一个机器上选择版本运行。</p><p>总之， selenium gird有自己的应用场景，特别对于大型系统来说，selenium grid应用还比较普遍。 大家可以根据自己情况自行选择。</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
          <category> web自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试框架--数据驱动动态增加测试用例</title>
      <link href="/2018/09/25/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
      <url>/2018/09/25/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E5%8A%A8%E6%80%81%E5%A2%9E%E5%8A%A0%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>前面我们讲了什么是python数据驱动，如何使用及如何实现数据驱动。没看过文章的请移步：<br><a href="https://helloqa.com/2018/09/17/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A81/" target="_blank" rel="external">Python数据驱动实践(一)–ddt实现数据驱动</a><br><a href="https://helloqa.com/2018/09/18/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A82/" target="_blank" rel="external">Python数据驱动实践(二)–教你用Python实现数据驱动</a></p><p>今天我们来解决另外一个问题，实现数据驱动后，如何在测试报告里体现？<br><a id="more"></a><br>老规矩，先上段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 这段代码实现了一个事情， 测试一个sum_data的方法。</span></div><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_provider</span><span class="params">(test_data)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">        @wraps(func)</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> test_data:</div><div class="line">                print(<span class="string">'func starts'</span>)</div><div class="line">                func(self, *i, **kwargs)</div><div class="line">                print(<span class="string">'func ends'</span>)</div><div class="line">        <span class="keyword">return</span> repl</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumData</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum_data</span><span class="params">(self, *ags)</span>:</span></div><div class="line">        <span class="keyword">return</span> sum(ags)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSumData</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"><span class="meta">    @data_provider([(1, 2, 3), (4, 5, 9)])</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_data</span><span class="params">(self, x, y, z)</span>:</span></div><div class="line">        print(<span class="string">"the value are &#123;0&#125;, &#123;1&#125;, &#123;2&#125;"</span>.format(x, y, z))</div><div class="line">        <span class="keyword">assert</span> SumData().sum_data(x, y) == z</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    print(TestSumData().test_sum_data())</div><div class="line"><span class="comment">#唯一需要注意的是，@wraps的作用：</span></div><div class="line"><span class="comment">#由于装饰器的加入导致Python解释器认为函数本身发生了改变，所以用@wraps，</span></div><div class="line"><span class="comment">#它可以将原函数对象的指定属性复制给包装函数对象，保证装饰器不会对被装饰函数造成影响</span></div></pre></td></tr></table></figure><br>我们知道，运行测试用例时候，通常会给一个待运行函数的集合，针对集合的每一个函数，逐个运行一遍，然后收集每个测试函数（用例）的名字，运行结果，然后保存，待生成测试报告用。</p><p>我们当前的代码， 根据data provider提供的数据不同，test_sum_data 这个函数也会运行多次，但是测试报告里只有一个test_sum_data， 那么如何解决呢？<br>1.先检查要运行的测试函数有没有data provider。<br>2.对于每个有data provider的测试函数，针对每一条数据，生成一个新的名字。<br>3.把新的名字加入到要运行的test case列表里。</p><p>根据这个我们知道，我们代码少两个函数实现， 一个是检查函数有没有data provider， 二是给有data provider装饰的函数生成新名字。怎么实现，当然是装饰器啦。<br>那么如何检查函数有没有提供data呢？我们可以人为给提供了data的函数加些属性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_provider</span><span class="params">(test_data)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">        setattr(func, <span class="string">"__data_Provider__"</span>, test_data)</div><div class="line">        <span class="keyword">global</span> index_len</div><div class="line">        index_len = len(str(len(test_data)))</div><div class="line">        <span class="keyword">return</span> func</div><div class="line">    <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure><br>如何给有__data__provider <em>\</em> 属性的函数生成新名字呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mk_test_name</span><span class="params">(name, value, index=<span class="number">0</span>)</span>:</span></div><div class="line">    index = <span class="string">"&#123;0:0&#123;1&#125;&#125;"</span>.format(index+<span class="number">1</span>, index_len)</div><div class="line">    test_name = <span class="string">"&#123;0&#125;_&#123;1&#125;_&#123;2&#125;"</span>.format(name, index, value)</div><div class="line">    <span class="keyword">return</span> re.sub(<span class="string">r'\W|^(?=\d)'</span>, <span class="string">'_'</span>, test_name)</div></pre></td></tr></table></figure><br>那么，怎么组织把这些命名的新函数添加到待运行列表呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_test_cases</span><span class="params">(cls)</span>:</span></div><div class="line">    return_cases = []</div><div class="line">    <span class="keyword">for</span> name, func <span class="keyword">in</span> list(cls.__dict__.items()):</div><div class="line">        <span class="keyword">if</span> hasattr(func,  <span class="string">'__data_Provider__'</span>):</div><div class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(getattr(func, <span class="string">"__data_Provider__"</span>)):</div><div class="line">                test_name = mk_test_name(name, getattr(v, <span class="string">"__name__"</span>, v), i)</div><div class="line">                return_cases.append((test_name, func, v))</div><div class="line">    <span class="keyword">return</span> return_cases</div></pre></td></tr></table></figure><br>最后我们整理下，看看实际上是如何使用的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_provider</span><span class="params">(test_data)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">        setattr(func, <span class="string">"__data_Provider__"</span>, test_data)</div><div class="line">        <span class="keyword">global</span> index_len</div><div class="line">        index_len = len(str(len(test_data)))</div><div class="line">        <span class="keyword">return</span> func</div><div class="line">    <span class="keyword">return</span> wrapper</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumData</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum_data</span><span class="params">(self, *ags)</span>:</span></div><div class="line">        <span class="keyword">return</span> sum(ags)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSumData</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"><span class="meta">    @data_provider([(1, 2, 3), (4, 5, 6)])</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_sum_data</span><span class="params">(self, x, y, z)</span>:</span></div><div class="line">        print(<span class="string">"the value are &#123;0&#125;, &#123;1&#125;, &#123;2&#125;"</span>.format(x, y, z))</div><div class="line">        <span class="keyword">assert</span> SumData().sum_data(x, y) == z</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mk_test_name</span><span class="params">(name, value, index=<span class="number">0</span>)</span>:</span></div><div class="line">    index = <span class="string">"&#123;0:0&#123;1&#125;&#125;"</span>.format(index+<span class="number">1</span>, index_len)</div><div class="line">    test_name = <span class="string">"&#123;0&#125;_&#123;1&#125;_&#123;2&#125;"</span>.format(name, index, value)</div><div class="line">    <span class="keyword">return</span> re.sub(<span class="string">r'\W|^(?=\d)'</span>, <span class="string">'_'</span>, test_name)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_test_cases</span><span class="params">(cls)</span>:</span></div><div class="line">    return_cases = []</div><div class="line">    <span class="keyword">for</span> name, func <span class="keyword">in</span> list(cls.__dict__.items()):</div><div class="line">        <span class="keyword">if</span> hasattr(func,  <span class="string">'__data_Provider__'</span>):</div><div class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(getattr(func, <span class="string">"__data_Provider__"</span>)):</div><div class="line">                test_name = mk_test_name(name, getattr(v, <span class="string">"__name__"</span>, v), i)</div><div class="line">                return_cases.append((test_name, func, v))</div><div class="line">    <span class="keyword">return</span> return_cases</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    cases_to_run = []</div><div class="line">    cases_run_success = []</div><div class="line">    cases_run_fail = []</div><div class="line"><span class="comment">#注1</span></div><div class="line">    cases_to_run = get_test_cases(TestSumData)</div><div class="line">    <span class="keyword">while</span> cases_to_run:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            case = cases_to_run.pop(<span class="number">0</span>)</div><div class="line">            name = case[<span class="number">0</span>]</div><div class="line">            func = case[<span class="number">1</span>]</div><div class="line">            v = case[<span class="number">2</span>]</div><div class="line">            func(name, *v)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            <span class="comment"># traceback.print_exc()</span></div><div class="line">            cases_run_fail.append(name)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            cases_run_success.append(name)</div><div class="line">    print(cases_run_success)</div><div class="line">    print(cases_run_fail)</div><div class="line"><span class="comment">#output</span></div><div class="line">the value are <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></div><div class="line">the value are <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></div><div class="line">[<span class="string">'test_sum_data_1__1__2__3_'</span>]</div><div class="line">[<span class="string">'test_sum_data_2__4__5__6_'</span>]</div></pre></td></tr></table></figure><br>我们定义并维护了三个列表，一个是cases_to_run，放我们找到的所有的测试用例，一个是cases_run_success，放运行成功的用例，最后一个<br>cases_run_fail， 放测试不成功的用例。<br>从运行结果我们可以看出， 我们只有一个测试函数test_sum_data，测试报告里却有了两个用例test_sum<em>data112</em>_3， test_sum<em>data245</em>_6。</p><p>就这样我们就实现了测试报告里数据驱动可视化。</p><p>Hold on， 看我上面代码的注释（注1），我们传入的是固定的测试类，那么在真实的测试中，我希望框架去自动查找测试类和测试方法，这个怎么搞？<br>请期待下次分享 ：）</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试框架--教你用Python实现数据驱动2</title>
      <link href="/2018/09/18/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A82/"/>
      <url>/2018/09/18/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A82/</url>
      
        <content type="html"><![CDATA[<p>在做自动化测试时，我们通常有这样的需求，对某一个用例，希望可以根据我们提供的不同数据而运行多次，每次运行加载一条数据，但是运行的是同一个用例，仅仅是数据不同。<br>这个模式Java里TestNG有个概念叫DataProvider， python里也有，叫ddt。 上次我们介绍了用法，连接在此<a href="https://helloqa.com/2018/09/17/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A81/" target="_blank" rel="external">Python数据驱动实践</a>，今天来讲下如何自己实现一个ddt。<br><a id="more"></a><br>我们先来看一个简单例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_data</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="keyword">assert</span> sum_data(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span></div><div class="line">    <span class="keyword">assert</span> sum_data(<span class="number">4</span>, <span class="number">5</span>) ==<span class="number">8</span></div></pre></td></tr></table></figure><br>正常来说， 要验证这个函数的实现正确与否，最基本的两个检查点一定是一个通过一个不通过。 上面代码可以看到我们写了两条用例，基本实现了我们的需求，但是感觉还有优化的空间，于是我们改成了这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_data</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum_data</span><span class="params">(x, y, z)</span>:</span></div><div class="line">    <span class="keyword">assert</span> sum_data(x, y) == z</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    test_sum_data(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">    test_sum_data(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</div></pre></td></tr></table></figure><br>看起来简单了一点，但是对于接口测试来说，一个函数可能验证的点有几十条，难道我们要copy-paste test_sum_data这个函数多次吗？<br>大家都知道， python里有装饰器这个概念，装饰器最大的特点就是接收一个函数称为参数，然后做一些”夹带私货“的操作后再返回这个函数。<br>如果你不是很了解装饰器的话，也没关系，你只要记住如下转换就可以了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#假设你有一个函数叫func， 你有一个装饰器函数叫decorator， 那么如下代码</span></div><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure><br>python解释器会解释成下面这样的语句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func = decorator(func)</div><div class="line"><span class="comment">#如果你的装饰器decorator带参数怎么办？</span></div><div class="line"><span class="meta">@decorator(arg1, arg2)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="comment">#相当于：</span></div><div class="line">func = decorator(arg1,arg2)(func)</div></pre></td></tr></table></figure><br>了解了上面，那我们继续看，我们应该怎么用装饰器来精简我们的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_data</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_data</span><span class="params">(test_data)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">(x, y, z)</span>:</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> test_data:</div><div class="line">                x, y, z = i</div><div class="line">                print(<span class="string">'func starts'</span>)</div><div class="line">                func(x, y, z)</div><div class="line">                print(<span class="string">'func ends'</span>)</div><div class="line">        <span class="keyword">return</span> repl</div><div class="line">    <span class="keyword">return</span> wraps</div><div class="line"><span class="meta">@my_data([(1, 2, 3), (4,5,6)])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum_data</span><span class="params">(x, y , z)</span>:</span></div><div class="line">    <span class="keyword">assert</span> sum_data(x, y) == z</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    test_sum_data(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">#运行一遍看， 结果如下：</span></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"88.py"</span>, line <span class="number">22</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    test_sum_data(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</div><div class="line">  File <span class="string">"88.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> repl</div><div class="line">    func(x, y, z)</div><div class="line">  File <span class="string">"88.py"</span>, line <span class="number">18</span>, <span class="keyword">in</span> test_sum_data</div><div class="line">    <span class="keyword">assert</span> sum_data(x, y) == z</div><div class="line">AssertionError</div><div class="line">func starts</div><div class="line">func ends</div><div class="line">func starts</div></pre></td></tr></table></figure><br>可以看到函数第2此运行的时候失败了，报的错也是assert error。<br>你们发现没？ 函数test_sum_data的自身的实参不起作用了， 变成从my_data提供了，那么我的函数就要相应的优化下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_data</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_data</span><span class="params">(test_data)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">(*args)</span>:</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> test_data:</div><div class="line">                print(<span class="string">'func starts'</span>)</div><div class="line">                x, y , z = i</div><div class="line">                func(x, y , z)</div><div class="line">                print(<span class="string">'func ends'</span>)</div><div class="line">        <span class="keyword">return</span> repl</div><div class="line">    <span class="keyword">return</span> wraps</div><div class="line"><span class="meta">@my_data([(1, 2, 3), (4,5,9)])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum_data</span><span class="params">(x, y , z)</span>:</span></div><div class="line">    print(<span class="string">"Your are verifing (&#123;&#125; + &#123;&#125;) == &#123;&#125;"</span>.format(x, y, z))</div><div class="line">    <span class="keyword">assert</span> sum_data(x, y) == z</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    test_sum_data()</div><div class="line"><span class="comment">#这样我们在方法test_sum_data后面不加参数就可以了。</span></div><div class="line"><span class="comment">#注意：*args是可变参数的意思，它的实现实际上是个unpack，大家有兴趣可以自行了解下。</span></div></pre></td></tr></table></figure><br>可是还有个问题，我想把这个数据驱动给我不同的函数使用怎么办？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_data</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_equal</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x==y</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_data</span><span class="params">(test_data)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraps</span><span class="params">(func)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">(*args， **kwargs)</span>:</span></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> test_data:</div><div class="line">                print(<span class="string">'func starts'</span>)</div><div class="line">                func(*i, **kwargs)</div><div class="line">                print(<span class="string">'func ends'</span>)</div><div class="line">        <span class="keyword">return</span> repl</div><div class="line">    <span class="keyword">return</span> wraps</div><div class="line"><span class="meta">@my_data([(1, 2, 3), (4,5,9)])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sum_data</span><span class="params">(x, y , z)</span>:</span></div><div class="line">    print(<span class="string">"Your are verifing (&#123;&#125; + &#123;&#125;) == &#123;&#125;"</span>.format(x, y, z))</div><div class="line">    <span class="keyword">assert</span> sum_data(x, y) == z</div><div class="line"><span class="meta">@my_data([(2,2), (1, 2)])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_is_equal</span><span class="params">(x, y)</span>:</span></div><div class="line">    print(<span class="string">"Your are verifing &#123;&#125; == &#123;&#125;"</span>.format(x, y))</div><div class="line">    <span class="keyword">assert</span> is_equal(x, y) ==<span class="number">1</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    test_sum_data()</div><div class="line">    test_is_equal()</div><div class="line"><span class="comment">#运行一下， O了。</span></div></pre></td></tr></table></figure><br>就这样，我们一步一步实现了数据驱动的功能，实际上，如果你看过Python DataProvidor–ddt的源码，就发现，它实际上也是这么实现的。<br>本文的主要难点在装饰器上，而对于装饰器的理解，主要难点在闭包上，大家可以相应的搜索下，如有疑问，欢迎交流。</p><p>Hold On， 这就结束了吗？ NO！</p><p>我们知道，自动化过程中我们通常会希望一个case在报告里有一个对应结果. 但对于我们实现的DataProvider，在测试报告里只会显示一条记录，太不利于我们调试了。<br>那么，如何在测试报告里体现呢？ 且听下回分解：）</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试框架--教你用Python实现数据驱动1</title>
      <link href="/2018/09/17/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A81/"/>
      <url>/2018/09/17/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6--%E6%95%99%E4%BD%A0%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A81/</url>
      
        <content type="html"><![CDATA[<p>在做自动化测试特别是接口测试的过程中，我们经常碰到这样的例子，几个用例步骤，操作完全一样，仅仅是数据和结果不一样。常规的做法是每套数据写一个测试用例。<br>这样弊端也非常明显，一是假如这部分用例操作需要改变，那么用例要一个个修，二就是代码很不整洁。那么有什么好的办法没？今天我们来了解下自动化测试里的数据驱动<br><a id="more"></a><br>顾名思义，数据驱动的存在就是为了解决上述问题。那么在自动化测试里，有哪些好的数据驱动库呢？</p><blockquote><p>DDT (Data-Driven Tests) allows you to multiply one test case by running it with different test data, and make it appear as multiple test cases.</p></blockquote><p>1.安装<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install ddt</div></pre></td></tr></table></figure><br>2.API<br>ddt作为unittest的补充，它的使用需要跟unittest结合起来。<br>ddt提供了如下用法：</p><p>ddt.add_test:<br>给一个类添加一个测试用例。</p><p>dd.ddt：<br>装饰类，也就是继承自TestCase的类。</p><p>ddt.data：<br>装饰测试方法。参数是一系列的值。</p><p>ddt.file_data：<br>装饰测试方法。参数是文件名。文件可以是json 或者 yaml类型。</p><p>注意，如果文件以”.yml”或者”.yaml”结尾，ddt会作为yaml类型处理，其他所有文件都会作为json文件处理。<br>如果文件中是列表，每个列表的值会作为测试用例参数，同时作为测试用例方法名后缀显示。<br>如果文件中是字典，字典的key会作为测试用例方法的后缀显示，字典的值会作为测试用例参数。</p><p>ddt.unpack：<br>传递的是复杂的数据结构时使用。比如使用元组或者列表，添加unpack之后，ddt会自动把元组或者列表对应到多个参数上。字典也可以这样处理。</p><p>测试用例方法名生成规则“<br>使用ddt后，会产生一个新的测试用例方法名：之前的测试用例方法名_ordinal_data<br>之前的测试用例方法名：即定义的测试用例方法名。比如def test_large()，这里就是test_large</p><p>ordinal：整数，从1开始递加。</p><p>data：<br>如果传递过来的数据存在name属性，则这里就是该数据的name值。如果未定义name属性，ddt会尽量将传递过来的数据转化为python标识符，作为data显示。比如（3,2）就转化为3_2。需要注意的是，如果数据是字典，则这里就是字典的key。</p><p>ddt里用的最多的就是@data 和 @file_data:</p><p>data: contains as many arguments as values you want to feed to the test.</p><p>file_data: will load test data from a JSON or YAML file.</p><p>3.举例<br>使用ddt很简单，你只需要在你的测试类上加装饰器@ddt， 然后在你需要用数据驱动测试用例上加装饰器@data @unpack， @file_data 即可。</p><p>我们先来看看@data的用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#ddt_related/test_ddt.py</span></div><div class="line"><span class="comment">#先看数据直接提供部分</span></div><div class="line"><span class="keyword">import</span> unittest</div><div class="line"><span class="keyword">from</span> ddt <span class="keyword">import</span> ddt, data, unpack</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">larger_than_2</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x&gt;<span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_values</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"><span class="meta">@ddt</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_larger_than_2_no_para</span><span class="params">(self)</span>:</span></div><div class="line">        self.assertTrue(larger_than_2(<span class="number">2</span>))</div><div class="line"><span class="meta">    @data(3, 4, 5)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_larger_than_2</span><span class="params">(self, value)</span>:</span></div><div class="line">        self.assertTrue(larger_than_2(value))</div><div class="line"><span class="meta">    @data((1,2, 3))</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add_values</span><span class="params">(self, value)</span>:</span></div><div class="line">        a, b, c = value</div><div class="line">        self.assertEqual(add_values(a, b), c)</div><div class="line"><span class="meta">    @data([2, 3, 6], [4,5,9])</span></div><div class="line"><span class="meta">    @unpack</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add_values_unpack</span><span class="params">(self, a, b, c)</span>:</span></div><div class="line">       self.assertEqual(add_values(a, b), c)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    unittest.main()deblock %&#125;</div></pre></td></tr></table></figure><br>我们来运行下， 结合我们前面介绍过的pytest框架， commandline里运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m pytest ddt_related/test_ddt.py  --html=report.html</div></pre></td></tr></table></figure><p>结果如下：<br><img src="/2018/09/17/测试框架/测试框架--教你用Python实现数据驱动1/example1.JPG" alt=""><br>我们从结果中可以看到，ddt自动帮我们把数据驱动的用例分解成多个用例运行，用例名称也按照一定的规则重新生成了。</p><p>再来看看@file_data的用法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 我们先在ddt_related文件夹下建立文件json_data.json， 内容如下：</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"add_test"</span>: &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c"</span>:<span class="number">3</span>&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">#然后我们运行用例：</span></div><div class="line"><span class="meta">@ddt</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleTest</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"><span class="meta">    @file_data(os.path.join(os.path.dirname(__file__), "json_data.json"))</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_add_values_unpack</span><span class="params">(self, a, b, c)</span>:</span></div><div class="line">        self.assertEqual(add_values(a, b), c)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"><span class="comment"># command line运行 python -m pytest ddt_related/test_ddt.py  --html=report.html</span></div><div class="line"><span class="comment">#我们发现用例执行成功， 说明json文件被正确的读取和应用了。</span></div></pre></td></tr></table></figure><br>注意， ddt的一个坏处是什么？ 不同的数据文件不能混淆在一个文件.<br>举例来说，我们实现了两个方法， 一个需要1个参数，另外一个需要2个参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">larger_than_2</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x&gt;<span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_values</span><span class="params">(x, y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div></pre></td></tr></table></figure><br>如果你想以一个文件放2个函数的数据，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 我们先在ddt_related文件夹下建立文件json_data.json， 内容如下：</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"add_test"</span>: &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"c"</span>:<span class="number">3</span>&#125;，</div><div class="line">  <span class="string">"larger_than_2"</span> :[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后你运行用例，会失败如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TypeError: test_add_values_unpack() missing <span class="number">2</span> required positional arguments: <span class="string">'b'</span> <span class="keyword">and</span> <span class="string">'c'</span></div><div class="line">TypeError: test_larger_than_2() got an unexpected keyword argument <span class="string">'b'</span></div></pre></td></tr></table></figure><br>ddt给出的解释是：</p><blockquote><p>In case of a list, each value in the list will correspond to one test case, and the value will be concatenated to the test method name.<br>In case of a dict, keys will be used as suffixes to the name of the test case, and values will be fed as test data.</p></blockquote><p>如果我们测试用例接受的参数个数不同，那么就需要建立不同的数据文件， 所以从这个程度上来说，ddt也有它的局限性， 那么如何规避这个问题呢？，我们可以在文件里存储数据，然后读出来后，按需放入@data来使用。</p><p>有了ddt，我们实现了用数据驱动测试， 并且代码量显著减少了，确实不错，我们如果再认真一点， 就会思考ddt是如何实现数据驱动的？为什么多一条数据就多一条用例？<br>为什么用了ddt， 我测试用例的名称，在测试报告的体现，不再是原来的了，而是加了suffix？</p><p>下面我将带领大家深入了解ddt的实现，并由此自己用代码实现数据驱动， 敬请期待 ：）</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试框架 </tag>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化框架Pytest从入门到熟练使用</title>
      <link href="/2018/07/31/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6Pytest%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/31/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6Pytest%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>如需阅读全文，请关注公众号TesterTalk索要密码。<br>unittest是python自带的单元测试框架，它封装好了一些校验返回的结果方法和一些用例执行前的初始化操作，使得单元测试易于开展，因为它的易用性，很多同学也拿它来做功能测试和接口测试，只需简单开发一些功能（报告，初始化webdriver，或者http请求方法）便可实现。 </p><p>但自动化测试中我们常常需要根据不同需求挑选部分测试用例运行，并且我们希望用例克服环境不稳定的局限，即运行失败后自动重新运行一次，如果成功就认为是环境问题导致第一次失败，还有我们经常希望测试用例可以并发执行等等，这些unittest都做不到或者需要大量二次开发才能做到，那么有没有更加强大的框架可以替代unittests呢？<br><a id="more"></a></p><p>pytest是python里的一个强大框架，它可以用来做单元测试，你也可以用来做功能，接口自动化测试。而且它比unittest支持的功能更多更全面。但是pytest在Getstarted里给出的实例却很简单，很多同学错以为它只是跟unittest一样是个单元测试框架罢了，如果你查询中文互联网，你也只能找到寥寥数篇大致一样的用法，可以说pytest的精髓使用，没有被大家挖掘出来，如此强大的框架不应该被埋没，今天我就带领大家深入pytest使用，共同领略pytest的强大。</p><h3 id="1-pytst安装"><a href="#1-pytst安装" class="headerlink" title="1.pytst安装"></a>1.pytst安装</h3><p>pytest不属于python的标准库，所以需要安装才能使用， 安装方式如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -U pytest</div></pre></td></tr></table></figure></p><p>如果你已经安装有pytest，想查看它的版本号：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pytest --version</div></pre></td></tr></table></figure></p><h3 id="2-你的第一个pytest测试"><a href="#2-你的第一个pytest测试" class="headerlink" title="2.你的第一个pytest测试"></a>2.你的第一个pytest测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#直接使用官网用例</span></div><div class="line"><span class="comment"># content of TesterTalk.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_answer</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">assert</span> func(<span class="number">3</span>) == <span class="number">5</span></div><div class="line"><span class="comment">#在你的terminial里输入 python -m pytest TesterTalk.py,你将会看到如下信息：</span></div></pre></td></tr></table></figure><p><img src="/2018/07/31/测试框架/自动化框架Pytest从入门到熟练使用/pytest_start.JPG" alt=""><br>非常简单吧， 如果想运行多个用例该如何做呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># content of TesterTalk.py</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">(self)</span>:</span></div><div class="line">        x = <span class="string">"this"</span></div><div class="line">        <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">(self)</span>:</span></div><div class="line">        x = <span class="string">"hello"</span></div><div class="line">        <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</div><div class="line"><span class="comment">#把要测试的case以test_开头就好了。</span></div><div class="line"><span class="comment">#terminal里输入 pytest TesterTalk.py, 执行结果一个成功一个失败。</span></div></pre></td></tr></table></figure></p><p><strong> 注意: </strong><br>（1）.如果你想用pytest寻找整个文件夹下的测试用例，那么文件须以test_开头或者以<em>test结尾。<br>（2）.测试类以Test开头，并且不能带有 <strong>init</strong> 方法。<br>（3）.测试函数以test</em>开头。<br>（4）.另外，pytest不支持也不打算支持中文路径，如果项目路径中有中文会报错。<br>好了，pytest的getStarted就结束了， 看了上面的应用方式的确没觉得它哪里强大。 别着急，我们再来想一想，如果你有个测试框架，你希望如何用这个框架做测试？</p><h3 id="3-灵活的指定测试用例运行集。"><a href="#3-灵活的指定测试用例运行集。" class="headerlink" title="3.灵活的指定测试用例运行集。"></a>3.灵活的指定测试用例运行集。</h3><p>在unittest框架里，你只能通过suite.addTest（），或者defaultTestLoader.Discover()两种方法在查找测试用例，对于你不需要的测试用例，只能用@unittest.skip()<br>来忽略，但做不到不改动代码变更测试用例集，pytest很好的实现了这一点，它支持如下查找：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"># 1. 运行某个package下的所有用例。</div><div class="line">pytest test_4. #会运行test_4下面所有的test_*.py 或者*_test.py文件里所有的Test开头的类（这个类不允许有__init__方法）下面的以test_开头的方法。</div><div class="line"></div><div class="line">#2. 运行某个文件（module）下的所有用例。</div><div class="line">pytest testtalk.py #会查找这个文件下所有的Test开头的类（这个类不允许有__init__方法）下面的以test_开头的方法。</div><div class="line"></div><div class="line">#3. 运行包含（或不包含）某个关键词的测试类/方法。</div><div class="line">class TestClass(object):</div><div class="line">    def test_one(self):</div><div class="line">        x = "this"</div><div class="line">        assert 'h' in x</div><div class="line"></div><div class="line">    def test_two(self):</div><div class="line">        x = "hello"</div><div class="line">        assert hasattr(x, 'check')</div><div class="line">#在terminal里输入 pytst -k "TestClass and not two" #会运行 test_one这个function但不会与性test_two.</div><div class="line"></div><div class="line">#4.根据node ids运行测试用例。 pytest给每个test assign里一个id。 可以用::隔开。 举例来说：</div><div class="line"># TesterTalk.py</div><div class="line">class TestClass(object):</div><div class="line">    def test_one(self):</div><div class="line">        x = "this"</div><div class="line">        assert 'h' in x</div><div class="line"></div><div class="line">    def test_two(self):</div><div class="line">        x = "hello"</div><div class="line">        assert hasattr(x, 'check')</div><div class="line">#在terminal里输入 pytest TesterTalk.py：：TestClass 会执行TestClass下的所有用例</div><div class="line">#在terminal里输入 pytest TesterTalk.py：：TestClass：：test_two, 仅会执行test_two.</div><div class="line"></div><div class="line">#5.根据标签（mark）运行，比如有个测试类，你想在regression时候才运行，另外一个测试类你想在releasae的时候才运行。</div><div class="line">#TesterTalk.py</div><div class="line">@pytest.mark.release</div><div class="line">class TestClass1(object):</div><div class="line">    def test_one(self):</div><div class="line">        x = "this"</div><div class="line">        assert 'h' in x</div><div class="line"></div><div class="line">    def test_two(self):</div><div class="line">        x = "hello"</div><div class="line">        assert hasattr(x, 'check')</div><div class="line"></div><div class="line"></div><div class="line">@pytest.mark.regression</div><div class="line">class TestClass2(object):</div><div class="line">    def test_one(self):</div><div class="line">        x = "this"</div><div class="line">        assert 'h' in x</div><div class="line"></div><div class="line">    def test_two(self):</div><div class="line">        x = "hello"</div><div class="line">        assert hasattr(x, 'check')</div><div class="line">#你只需在terminal里指定标签就可以了。 </div><div class="line">pytest TesterTalk.py -m release</div><div class="line">pytest TesterTalk.py -m regression</div><div class="line">是不是比unittest方便太多了，所有的测试类，测试方法，你只需要用@pytest.mark.XXX装饰就好了。然后一次更改，多次挑选运行！</div><div class="line">这样就完了吗？ NO, No,No, 你如果想几个标签一起运行怎么办？或者你不想某个标签运行怎么办？ </div><div class="line">Very simple：</div><div class="line">pytest TesterTalk.py -m “release or regression" #有release或者regression标签的都会运行。</div><div class="line">pytest TesterTalk.py -m “not regression” # regression标签的不会运行。</div><div class="line"></div><div class="line">当然了，unittest里支持的skip方法，pytest也支持，具体用法如下：</div><div class="line">#TesterTalk.py</div><div class="line">@pytest.mark.skip('skip')</div><div class="line">class TestClass1(object):</div><div class="line">    def test_one(self):</div><div class="line">        x = "this"</div><div class="line">        assert 'h' in x</div><div class="line"></div><div class="line">    def test_two(self):</div><div class="line">        x = "hello"</div><div class="line">        assert hasattr(x, 'check')</div><div class="line"></div><div class="line">#skip装饰器可以放在类前面skip掉整个测试类，也可以防止function前面只skip掉这个function。</div><div class="line">#对应的还有skipif， 请自己看文档了解。</div></pre></td></tr></table></figure></p><p>难道就仅限于此吗？ 其实pytest帮我们实现了更多的高级功能，比如：</p><h3 id="4-并发运行测试用例集"><a href="#4-并发运行测试用例集" class="headerlink" title="4.并发运行测试用例集"></a>4.并发运行测试用例集</h3><p>关注公众号TesterTalk，跟我一起关注测试技术<br>首先，你得安装个插件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pytest-parallel  <span class="comment">#pytest-parallel比pytst-xdist要更好。</span></div></pre></td></tr></table></figure><br>其次，要注意区这个插件仅仅支持python3.6版本及以上，而且如果你想多进程并发，必须跑在Unix或者Mac机器上，windows环境仅仅支持多线程运行。<br>运行上需要指定参数：</p><blockquote><p>–workers (optional) X。  多进程运行， X是进程数。 默认值1。<br>–tests-per-worker (optional) X. 多线程运行， X是每个worker运行的最大并发线程数。 默认值1。</p></blockquote><p>举例来说：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># TesterTalk.py</span></div><div class="line"><span class="keyword">import</span> pytest</div><div class="line"></div><div class="line"><span class="meta">@pytest.mark.release</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass1</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">(self)</span>:</span></div><div class="line">        x = <span class="string">"this"</span></div><div class="line">        <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">(self)</span>:</span></div><div class="line">        x = <span class="string">"hello"</span></div><div class="line">        <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@pytest.mark.regression</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass2</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">(self)</span>:</span></div><div class="line">        x = <span class="string">"this"</span></div><div class="line">        <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">(self)</span>:</span></div><div class="line">        x = <span class="string">"hello"</span></div><div class="line">        <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</div><div class="line"><span class="comment">#terminal里输入 pytest TesterTalk.py --workers 2 #指定一个进程并发</span></div><div class="line"></div><div class="line"><span class="comment">#terminal里输入 pytest TesterTalk.py --workers 2 --test-per-worker 3 #指定2个进程并发，每个进程最多运行3个线程。</span></div></pre></td></tr></table></figure></p><h3 id="5-测试报告优化"><a href="#5-测试报告优化" class="headerlink" title="5.测试报告优化"></a>5.测试报告优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#允许HTML格式报告</span></div><div class="line"><span class="comment">#首先还是要安装：</span></div><div class="line">pip install pytest-html</div><div class="line"></div><div class="line">Usage：</div><div class="line">使用很简单带参数 --html=report.html就好。</div><div class="line">仍然拿我们刚才举例：</div><div class="line">pytest TesterTalk.py --html=./report.html</div></pre></td></tr></table></figure><p>生成的结果如下：<br><img src="/2018/07/31/测试框架/自动化框架Pytest从入门到熟练使用/HTML_REPORT.JPG" alt=""></p><p>有时候，我们需要克服环境问题，让失败的用例rerun，有没有办法呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#rerun失败的case</span></div><div class="line"><span class="comment">#首先还是要安装：</span></div><div class="line">pip install pytest-rerunfailures</div><div class="line">Usage:</div><div class="line">--reruns <span class="number">5</span> ＃ｒｅｒｕｎ　５次</div><div class="line">----reruns <span class="number">5</span> --reruns-delay <span class="number">1</span> <span class="comment"># rerun5次， 但是每次rerun前等待1秒。</span></div><div class="line"></div><div class="line">仍以我们刚才的为例：</div><div class="line"><span class="comment">#terminal里输入 pytest TesterTalk.py --reruns 1 --html=./report.html</span></div></pre></td></tr></table></figure></p><p>生成的结果如下：<br><img src="/2018/07/31/测试框架/自动化框架Pytest从入门到熟练使用/HTML_REPORT_RERUN.JPG" alt=""><br>可以看到，rerun聚合在了报告里。</p><p>我们自动化一般用到持续集成，Jenkins里需要junit XML格式的报告，pytest有没有办法直接生成？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">无需安装，直接使用：</div><div class="line">pytest --junitxml=path </div><div class="line"></div><div class="line">例如：</div><div class="line">pytest TesterTalk.py --reruns <span class="number">1</span> --html=./report.html --junitxml=./xml_format_report.xml</div><div class="line">会在本地目录生成xml_format_report.xml</div></pre></td></tr></table></figure></p><p>这就结束了吗？还远呢？数据参数化你了解下？</p><h3 id="6-数据参数化"><a href="#6-数据参数化" class="headerlink" title="6.数据参数化"></a>6.数据参数化</h3><p>pytest有几种数据参数化方式：<br><strong> pytest.fixture(). 不带参数 </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#1.fixture()不带参数：</span></div><div class="line"><span class="keyword">import</span> pytest</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@pytest.fixture()</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initial_browser</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line">    <span class="keyword">return</span> webdriver.Chrome()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBaidu</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_open_baidu</span><span class="params">(self, initial_browser)</span>:</span></div><div class="line">        initial_browser.get(<span class="string">"http://www.baidu.com"</span>)</div><div class="line"></div><div class="line"><span class="comment">#在terminal里输入pytest testing/testertalk.py  --html=./report.html， 你会看到百度浏览器打开了。说明函数间可以传递值，我们也可以利用这个来做unittest里setup（）的事情。</span></div></pre></td></tr></table></figure></p><p><strong> pytest.fixture()， 带parms参数</strong>:</p><blockquote><p>params with @pytest.fixture, a list of values for each of which the fixture function will execute and can access a value via request.param.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#利用fixtures的params</span></div><div class="line"><span class="keyword">import</span> pytest</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@pytest.fixture(params=[&#123;'username':'TesterTalk',"password":1&#125;, &#123;'username':'Test',"password":1&#125;])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">account_provider</span><span class="params">(request)</span>:</span> <span class="comment">#request是固定的。</span></div><div class="line">    <span class="keyword">return</span> request.param  <span class="comment">#request.parm也是固定的。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_login</span><span class="params">(account_provider)</span>:</span></div><div class="line">    <span class="comment">#some operations</span></div><div class="line">    print(account_provider)</div><div class="line"></div><div class="line">假设你需要用多个用户名密码测试登录，只需要用fixture（）加params就好。</div><div class="line"><span class="comment">#在terminal里输入pytest testing/testertalk.py  --html=./report.html</span></div></pre></td></tr></table></figure><br>report显示下图,可以看到test_login被执行了2遍，每次执行带入的数据不同：<br><img src="/2018/07/31/测试框架/自动化框架Pytest从入门到熟练使用/DataDriven_easy.JPG" alt=""></p></blockquote><p>除了直接用pytest.fixture, 还可以这么用：</p><p><strong> pytest.mark.usefixtures() </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pytest</div><div class="line"></div><div class="line"><span class="meta">@pytest.fixture(params=[&#123;'username':'TesterTalk',"password":1&#125;, &#123;'username':'Test',"password":1&#125;])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">account_provider</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">return</span> request.param</div><div class="line"></div><div class="line"><span class="meta">@pytest.mark.usefixtures("account_provider")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_login</span><span class="params">(account_provider)</span>:</span></div><div class="line">    <span class="comment">#some operations</span></div><div class="line">    print(account_provider)</div><div class="line"><span class="comment">#在terminal里输入pytest testing/testertalk.py  --html=./report.html，report跟上面的演示一样。</span></div><div class="line">注意：</div><div class="line">使用fixture标记函数后，函数将默认接入一个request参数，它将包含使用该fixture函数的信息，这使我们可以更加灵活的根据不同的函数来决定创建不同的对象以及释放函数。 举例来说userfixtures可以用作setup（）和teardown（）</div></pre></td></tr></table></figure><p>pytest固然强大，这就结束了吗？还有什么高阶的功能吗？必须的。</p><h3 id="7-pytest-mark-parametrize实现数据驱动"><a href="#7-pytest-mark-parametrize实现数据驱动" class="headerlink" title="7.pytest.mark.parametrize实现数据驱动"></a>7.pytest.mark.parametrize实现数据驱动</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#直接在测试方法前直到数据源</span></div><div class="line"><span class="keyword">import</span> pytest</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@pytest.mark.parametrize("account_provider", </span></div><div class="line">                         [&#123;<span class="string">'username'</span>:<span class="string">'TesterTalk'</span>,<span class="string">"password"</span>:<span class="number">1</span>&#125;, </div><div class="line">                          &#123;<span class="string">'username'</span>:<span class="string">'Test'</span>,<span class="string">"password"</span>:<span class="number">1</span>&#125;])</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_login</span><span class="params">(account_provider)</span>:</span></div><div class="line">    <span class="comment">#some operations</span></div><div class="line">    print(account_provider)</div><div class="line"><span class="comment">#在terminal里输入pytest testing/testertalk.py  --html=./report.html，就能看到login跑了2次。</span></div></pre></td></tr></table></figure><p>如果我的数据来自外部文件呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pytest</div><div class="line"><span class="comment">#直接写函数读取外部文件生成数据值，注意values返回值是个list</span></div><div class="line">values = read_from_excel()</div><div class="line"></div><div class="line"><span class="meta">@pytest.mark.parametrize('v', values)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_login</span><span class="params">(v)</span>:</span></div><div class="line">    <span class="comment">#some operations</span></div><div class="line">    print(v)</div><div class="line"><span class="comment">#在terminal里输入pytest testing/testertalk.py  --html=./report.html，就能看到login跑了2次，结果跟上面一样。</span></div><div class="line"></div></pre></td></tr></table></figure></p><p>到这里为止，你已经学习了pytst的基础功能，高阶功能，还有什么吗？ 如果你之前的框架是unittest， pytest支持无缝切换， 你不需要改任何代码。<br>记得上次直播我分享的unittest实现的自动化框架吗，我们看看这个page：<br><img src="/2018/07/31/测试框架/自动化框架Pytest从入门到熟练使用/unittest.JPG" alt=""><br>这个是unittest实现的测试类，我们之间在terminal里运行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pytet test_baidu.py --html=./report.html ,就是这么简单，我们看看报告是什么样子</div></pre></td></tr></table></figure></p><p><img src="/2018/07/31/测试框架/自动化框架Pytest从入门到熟练使用/unittest_intergrate.JPG" alt=""><br>怎么样，就问你惊喜不惊喜？刺激不刺激！</p><p>当然，pytest的特色还远不只与此，我们最后介绍一个高级特性，它允许你在用例运行的整个session里，或者一个module里共享测试数据。</p><h3 id="8-作用域（scope）实现数据共享（autouse）"><a href="#8-作用域（scope）实现数据共享（autouse）" class="headerlink" title="8.作用域（scope）实现数据共享（autouse）"></a>8.作用域（scope）实现数据共享（autouse）</h3><p>我们知道，fixture，允许你不带参数运行和带参数运行， 调用fixture的第三种方式就是使用autouse<br>fixture decorator一个optional的参数是autouse, 默认设置为False。 当默认为False，就可以选择用上面两种方式来试用fixture。 当设置为True时，在一个session内的所有的test都会自动调用这个fixture。 权限大，责任也大，所以用该功能时也要谨慎小心。</p><p>举例来说，我想初始化我的浏览器，但是我不想每次测试运行都初始化，怎么办呢？我可以用scope限制住。<br>首先要建立一个conftest.py文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pytest</div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@pytest.fixture(scope="session", autouse=True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_session_enginie_chrome</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"I will use session engine -- chrome"</span>)</div><div class="line">    browser= webdriver.Chrome()</div><div class="line">    <span class="keyword">return</span> browser</div><div class="line"></div><div class="line"><span class="meta">@pytest.fixture(scope="module")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_module_enginie_firefox</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"I will use module engine -- firefox"</span>)</div><div class="line">    browser = webdriver.Firefox()</div><div class="line">    <span class="keyword">return</span> browser</div><div class="line"></div><div class="line"><span class="meta">@pytest.fixture(scope="module")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function_enginie_chrome</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"I will use funciton engine --chrome"</span>)</div><div class="line">    browser = webdriver.Firefox()</div><div class="line">    <span class="keyword">return</span> browser</div></pre></td></tr></table></figure></p><p>其次，写我们的测试类<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#test_666.py</span></div><div class="line"><span class="keyword">import</span> pytest</div><div class="line"></div><div class="line"><span class="comment">##如果autouse fixture被session装饰，那么它只会初始化一次，不管它在哪里定义的。通常用于全局系统初始化.</span></div><div class="line"><span class="meta">@pytest.fixture(scope='session', autouse=True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">before</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">"session start"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_browser</span><span class="params">(my_session_enginie_chrome, before)</span>:</span></div><div class="line">    browser = my_session_enginie_chrome</div><div class="line">    browser.get(<span class="string">"https://wwww.baidu.com"</span>)</div><div class="line">    <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment">#整个module用，在这个module范围内可以用。</span></div><div class="line"><span class="meta">@pytest.fixture(scope='module', autouse=True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">before</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">"before start--%s"</span> % request.module.__name__)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_browser</span><span class="params">(my_module_enginie_firefox, before)</span>:</span></div><div class="line">    browser = my_module_enginie_firefox</div><div class="line">    browser.get(<span class="string">"https://wwww.baidu.com"</span>)</div><div class="line">    <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">1</span></div><div class="line"></div><div class="line"><span class="comment"># 每个test都会运行。</span></div><div class="line"><span class="meta">@pytest.fixture(scope='function', autouse=True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">before</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">print</span> (<span class="string">"before start--%s"</span> % request.function.__name__)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_browser</span><span class="params">(my_function_enginie_chrome, before)</span>:</span></div><div class="line">    browser = my_function_enginie_chrome</div><div class="line">    browser.get(<span class="string">"https://wwww.baidu.com"</span>)</div><div class="line">    <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">1</span></div></pre></td></tr></table></figure></p><p>fixture的存在使得我们在编写测试函数的准备函数、销毁函数或者多个条件的测试提供了更加灵活的选择。<br>autouse的scope含义如下：</p><blockquote><p>autouse fixtures obey the scope= keyword-argument: if an autouse fixture has scope=’session’ it will only be run once, no matter where it is defined. scope=’class’ means it will be run once per class, etc.<br>if an autouse fixture is defined in a test module, all its test functions automatically use it.<br>if an autouse fixture is defined in a conftest.py file then all tests in all test modules below its directory will invoke the fixture.</p></blockquote><p>好了讲到这里，谁还认为pytest不够强大的？！ pytest绝对是你开展功能自动化测试，接口自动化测试的利器，希望大家都可以用起来！</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python接口测试框架实践</title>
      <link href="/2018/07/30/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/Python%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/07/30/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/Python%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>两，三年以前给大家分享过如何用jmeter做接口测试，但工具毕竟有限制，所以在真实的项目中，大家还是用自研的框架多。我之前写过一个简单的基于unittest+request的接口测试框架，也分享给大家过，最近在免费直播中我也有讲到，但直播毕竟讲不透彻，还是有很多同学不是特别清楚，到底如何做一个接口测试框架，今天我们再次详细解释下，如何生成自己的接口测试框架。</p><a id="more"></a><p>关于接口测试，基本概念请点击<a href="http://localhost:4000/categories/api-test/" target="_blank" rel="external">这里</a>,接口测试我们一般先手工做，然后再自动化，无论手工还是自动化，接口测试的步骤都大致如下：</p><ol><li>根据接口文档/规范及接口功能来设计测试用例，设计法则参考黑盒测试和白盒测试方法。</li><li>准备测试数据，用工具（Postman， fiddler， soapui等）或代码（python+requests或其它语言），根据测试用例构造请求，发请求。</li><li>检查服务器返回的结果。 包括状态码和返回值的检查。 各种合法非法的请求接口能否正确处理，要特别注意安全性（仅前端校验，后端忘记校验），authentication，性能（特别是并发），数据一致性，完整性方面（幂等）的问题。</li></ol><p>接口测试的检查点，一般如下：<br><img src="/2018/07/30/测试框架/Python接口测试框架实践/接口测试评估标准.JPG" alt=""></p><p>手工如何测试，很清楚了，那么我们讲接口测试自动化框架，从哪里开始呢？</p><p>既然是自动化，那么就必须不需要人工干预，框架如何做到不需要人工干预呢？窃以为有如下方面：</p><p><strong> 用例的自动收集 </strong><br>就是要自动接受用户输入，自动分析并查找待跑用例。什么意思呢？你跑自动化时候，一般需要指定跑那些case，这些case属于哪个类别（regression， smoke， unit test？）框架需要能根据用户输入快速找到要跑到用例集，并把它加到待跑用例的列表里。如果你不指定，框架会跑默认文件夹下的用例集。</p><p><strong> 用例的运行方式 </strong><br>就是组织查找到的用例集合，你想怎么运行？ 顺序执行还是并发执行，执行过程中要不要记log，有错误是要继续还是要停止运行？运行失败要不要重新跑一遍？执行完毕后要不要收集执行结果？</p><p><strong> 测试报告 </strong> 所有用例执行完毕后需要有整个运行情况的报告，包括整体运行结果，执行的用例列表，用例中成功百分比，失败百分比，失败的用例，框架有没有在它发生错误的时候截图？有没有记log，在失败的用例上点击用例名称，能不能通过链接的方式快速定位截图，log？  你想要txt格式的报告还是更user friendly的HTML格式？                                                                           </p><p>前面3部分有了，一个测试框架的壳子就出来了，但还不够好，还需要加上：</p><p><strong> 自动触发运行 </strong><br>何时运行这个框架？每次有代码改动？发版前？还是每日定时？</p><p><strong> 环境配置 </strong><br>基本上公司的测试环境不可能只有一个，那么如何配置同样的脚本跑在不同的环境上？</p><p><strong> Data provider (数据生成) </strong><br>环境不一样，测试数据不能一样吧？如何提供不同环境的数据且不更改自动化代码？</p><p><strong> 邮件发送 </strong><br>自动化测试结束后自动发送测试报告到相应人的邮箱。</p><p><strong> 日志，错误处理 </strong><br>运行中记录运行情况，错误情况及出错后的处理。</p><p>下面，我们就以我实现的EasyAPIFramework（Python＋Unittest＋HTMLTestRunner）为例，详细说明下框架是如何一步步搭建起来的。</p><p>Unittest。unittest是python语言里使用最广泛的一个框架，看名字就知道它本来做unit test用的，但因为太强大了，所以也被拿来做功能自动化，接口自动化。</p><p>unittest有四个重要的概念：</p><p>1.test fixture</p><blockquote><p>represents the preparation needed to perform one or more tests(setup, teardown)。</p></blockquote><p>setUp(): 每次执行测试用例之前调用。无参数，无返回值。该方法抛出的异常都视为error，而不是测试不通过。没有默认的实现。<br>tearDown(): 每次执行测试用例之后调用。无参数，无返回值。测试方法抛出异常，该方法也正常调用，该方法抛出的异常都视为error，而不是测试不通过。只用setUp()调用成功，该方法才会被调用。没有默认的实现。通过setup 和 tesrDown组装一个module成为一个固定的测试装置。注意：如果setup运行抛出错误，则测试用例代码则不会执行。但是，如果setpu执行成功，不管测试用例是否执行成功都会执行teardown。</p><p>2.test case</p><blockquote><p>独立测试的单位，一般一个testcase完成一个功能。注意两点：</p></blockquote><p>(1).testcase通常继承自测试类，测试类一般继承自unittest.TestCase。测试类里通常实现了setup(), teardown(), 及测试用例。</p><p>(2).test case要以test开头。</p><p>3.test suite</p><blockquote><p>A test suite is a collection of test cases, test suite。通常用来聚合测试用例， 并且test suites可以嵌套。</p></blockquote><p>4.test runner</p><blockquote><p>A test runner is a component which orchestrates the execution of tests and provides the outcome to the user.<br>运行测试用例的驱动类，可以执行TestCase，也可执行TestSuite。执行后TestCase和Testsuite会自动管理TestResult。简单来说就是run（），里面就是手工测试的步骤代码化。</p></blockquote><p>除了上述概念，unittest里还有几个概念需要你知道：</p><p>5.TestLoder：是用来加载 TestCase到TestSuite中，其中有几个loadTestsFrom_()方法，<br>就是从各个地方寻找TestCase，创建他们的实例，然后add到TestSuite中，再返回一个TestSuite实例</p><p>6.TextTestRunner：是来执行测试用例的，其中的run（test）会执行TestSuite/TestCase中的run(result)方法。</p><p>7.TextTestResult：测试结果会保存到TextTestResult实例中，包括运行了多少用例，成功与失败多少等信息</p><p>一般来说，unittest执行测试的流程如下：</p><p>创建好TestCase，然后由TestLoader加载（也可以用TestDiscover指定文件夹的方式Load）TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，整个过程集成在unittest.main模块中。</p><p>下面我们举个例子来看下，一个简单的unittest的测试用例长什么样子：<br><img src="/2018/07/30/测试框架/Python接口测试框架实践/unittest例子.JPG" alt=""><br>好，看上图，这里我实现了一个测试类，它继承了unittest.TestCase.然后再测试类里实现了setup(), test_XXX(), teardown()方法，有的测试方法上我加个了@unittest.skip(). 说这个什么意思呢？我开始说测试框架要实现查找测试用例集，unittest帮我们把测试用例标记好了，所有的测试用例要以test开头，当你调用TestLoder（defaultTestLoader()类，通过该类下面的discover()方法可自动根据测试目录start_dir匹配查找测试用例文件（test*.py），并将查找到的测试用例组装到测试套件）查找测试用例集的时候，所以test开头的会被自动加入测试用例集。哪些被标记为unittest.skip（）的则不会。 第2，我想实现跑某些用例，怎么办呢？unitest 不支持按照标签运行，但是它提供了testsuite概念，你可以把一个测试类的几个测试用例添加到testsuite里。这样unitest就实现了框架的第一要素，测试用例集的查找。</p><p>那么用例集查找好了，你定义的test_XXX()的方法最终都会在TextTestRunner的run（）方法中被执行到。也就是说，通过TextTestRunner我们实现了用例的顺序执行。（并发执行unittest貌似不支持，并发执行可以用pytest）看，利用unittest我们可以轻易开发出一个测试用例并实现了用例收集和用例执行。</p><p>那么测试报告如何生成呢？我们可以借助HTMLTestRunner来实现。</p><blockquote><p>HTMLTestRunner is an extension to the Python standard library’s unittest module. It generates easy to use HTML test reports<br>下载地址:(<a href="http://tungwaiyip.info/software/HTMLTestRunner.html" target="_blank" rel="external">http://tungwaiyip.info/software/HTMLTestRunner.html</a>), 下载好后放到放在C:\Python37\Lib目录下。具体用法参考我代码，稍后放出。</p></blockquote><p>好， 有了unittest +HTMLRunner，测试框架所需要的１２３就有了，后面的６到８（自动触发运行，环境配置，Data provider (数据生成)，邮件发送，日志，错误处理），其中（自动触发运行，环境配置，邮件发送）可以通过集成Jenkins的方式实现， Data provider (数据生成)，日志，错误处理，需要我们代码实现。</p><p>我们再回过来看这个简单的框架<br><img src="/2018/07/30/测试框架/Python接口测试框架实践/framework_overview.JPG" alt=""><br>这个框架分了几个部分（以前写的英文版我就不翻译了哈）：</p><p> <strong> “Common”: </strong> –Common methods to facilitates the whole project.</p><blockquote><p>html_report: To generate HTML report after test cases run.<br>shared_api: Import method like post/get to serve all the API requests.<br>txt_report: Independent way to run all the cases under test and generate simple txt format report.</p></blockquote><p>主要来说就是一些公用的library，包括如对selenium的二次封装（web自动化），对API调用的二次封装（API自动化），datadriven读文件方法及项目所用到的公用库文件。<br>shared_api里包含了我对requests的封装，其实，针对webservices（一般为？wsdl文件）的API，也可以写个公用方法包括在内，可以看看它长什么样子：</p><p><img src="/2018/07/30/测试框架/Python接口测试框架实践/SharedAPI.JPG" alt=""><br>如果你要做web自动化框架，那么就写个Selenium_helper，包括你所有对selenium的wrap方法，然后你在测试类的setup（）， teardown（）两个类下调用（看出来了吧，框架本身应该和什么类型的测试无关，框架就是用来帮你组织你的测试用例的）。</p><p><strong> “Page”: </strong> –The page under test.</p><blockquote><p>in this file, only store the page related function/method/date<br>test case related to this page should not be included here.<br>different page should have separated pages.</p></blockquote><p>真正你要测试的项目（如果是功能自动化，你需要利用page object模式实现页面元素，和定位元素的loactor分离（其实测试数据，逻辑，业务都应该分离并可重用））。<br>一个完整的页面或功能我们组织在一起叫一个page，这个page应该包括这个页面的元素，及针对元素的操作，但测试业务逻辑不般不包括。</p><p>一个page通常是什么样子呢？<br><img src="/2018/07/30/测试框架/Python接口测试框架实践/page.JPG" alt=""></p><p><strong> “Settings”: </strong> –Global settings &amp; configuration &amp; global data.</p><blockquote><p><strong>init</strong>:<br>data_source: all the account, common test data.<br>test config: environment, domain or other common config.</p></blockquote><p>这里就是整个项目的配置文件，包括数据配置也可以放置在内，一般会有变量来接受来自jenkins的环境变量。如果没有就设置default值。 Test_config里应该包含你测试的数据，不同环境区分开，也可以写到外部excel或者xml了，然后利用common方法里的datadriven方法读出。 我们就是通过这个来实现环境及数据的切换。<br><img src="/2018/07/30/测试框架/Python接口测试框架实践/cicd_integrate.JPG" alt=""></p><p><strong> “test” </strong> – Test cases inherited from pages, this is the cases under test.</p><blockquote><p>each test file should have a page file accordingly.<br>framework will only search the cases under this folder</p></blockquote><p>就是你测试类和测试方法所在，通常你测试类的名称要和你测试对象的名称一样，只是在前面加test（注意unittest只有以test开头的测试用例才会被执行）。<br><img src="/2018/07/30/测试框架/Python接口测试框架实践/unittest例子.JPG" alt=""></p><p>注意，setup（）应该包括测试用例的数据准备（比如你需要打他driven，这次的数据就应该包括进来），还有selenium调用及browser的initial（针对web功能自动化），requests接口的初始化（API自动化）等。teardown（）里，要做好相应的销毁动作。</p><p><strong> “main” </strong> – Load &amp; run all of the test cases defined in test folder.</p><blockquote><p>System will automated search all the test method defined in test folder and run them.</p></blockquote><p>当然你也可以通过TestDiscover及testsuite的addTest来筛选你需要执行的用例，我简化为搜索所有test文件夹下的用例了（直接利用discover方法）。<br><img src="/2018/07/30/测试框架/Python接口测试框架实践/Discover.JPG" alt=""></p><p>好了，到这里为止，我们就实现了一个基本的接口测试框架，是不是感觉非常简单啊？如果你对代码感兴趣，接口框架代码可以参考：<br><a href="https://github.com/Light07/EasyAPIAutomationFramework" target="_blank" rel="external">Github</a></p><p>其实，在真正的项目实践中，要考虑到比这个要复杂的多，起码并发执行我们没实现啊，数据驱动我们也没实现。失败rerun也没有。后续我会重新实现一个开源的接口测试框架给大家，把我提及的全部功能都实现，当然，大家也可以直接选用pytest，我后续也会写下pytest教程，敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的字符串相关面试题--再探</title>
      <link href="/2018/07/17/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98--%E5%86%8D%E6%8E%A2/"/>
      <url>/2018/07/17/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98--%E5%86%8D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>上次分享了一道有趣的字符串面试题，今天我们再重新审视下这道题，并借此机会了解下python库的强大。<br><a id="more"></a></p><p>上次的原题是这样的:</p><h3 id="给定一个字符串，求字符串中连续相同的字符的个数，-例如给定字符串“abbcccdxt”，输出-‘a1’-’b2’-’c3’-’d1’-’x1’-’t1’-。"><a href="#给定一个字符串，求字符串中连续相同的字符的个数，-例如给定字符串“abbcccdxt”，输出-‘a1’-’b2’-’c3’-’d1’-’x1’-’t1’-。" class="headerlink" title="给定一个字符串，求字符串中连续相同的字符的个数， 例如给定字符串“abbcccdxt”，输出[‘a1’,’b2’,’c3’,’d1’,’x1’,’t1’]。"></a>给定一个字符串，求字符串中连续相同的字符的个数， 例如给定字符串“abbcccdxt”，输出[‘a1’,’b2’,’c3’,’d1’,’x1’,’t1’]。</h3><p>我原来的解决方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">        <span class="keyword">return</span></div><div class="line">    base = s[<span class="number">0</span>]</div><div class="line">    result = []</div><div class="line">    count = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</div><div class="line">        <span class="keyword">if</span> i == base:</div><div class="line">            count +=<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            result.append(base+str(count))</div><div class="line">            count =<span class="number">1</span></div><div class="line">            base = i</div><div class="line">    result.append(base + str(count))</div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line">print(count_s(<span class="string">'abbcccdxt'</span>))</div><div class="line"></div></pre></td></tr></table></figure></p><p>后来有同学在评论中指出，有更好的解决方案，我们使用下看看。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">            <span class="keyword">return</span></div><div class="line">    d = OrderedDict()</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> s:</div><div class="line">        <span class="keyword">if</span> _ <span class="keyword">in</span> d.keys():</div><div class="line">            d.update(&#123;_:d[_]+<span class="number">1</span>&#125;)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            d.update(&#123;_: d.setdefault(_, <span class="number">1</span>)&#125;)</div><div class="line">    <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x: x +str(d[x]), d))</div><div class="line"></div><div class="line">print(count_s(<span class="string">'abbcccdxt'</span>))</div><div class="line"></div></pre></td></tr></table></figure></p><p><strong> OrderedDict </strong></p><blockquote><p>The OrderedDict API is substantially the same as regular dictionaries but will iterate over keys and values in a guaranteed order depending on when a key was first inserted. If a new entry overwrites an existing entry, the original insertion position is left unchanged. Deleting an entry and reinserting it will move it to the end.<br><strong> Usage </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">d = OrderedDict()</div><div class="line">d[<span class="string">'parrot'</span>] = <span class="string">'dead'</span></div><div class="line">d[<span class="string">'penguin'</span>] = <span class="string">'exploded'</span></div><div class="line">d.update(&#123;<span class="string">'foo'</span>: <span class="string">'bar'</span>&#125;)</div><div class="line">print(d.items())</div><div class="line"><span class="comment">#output:</span></div><div class="line">odict_items([(<span class="string">'parrot'</span>, <span class="string">'dead'</span>), (<span class="string">'penguin'</span>, <span class="string">'exploded'</span>)])</div></pre></td></tr></table></figure></p></blockquote><p><strong> dict.setdefault(key, default=None) </strong></p><blockquote><p>如果字典中包含有给定键，则返回该键对应的值，否则返回为该键设置的值</p></blockquote><p><strong> map(function, iterable, …) </strong></p><blockquote><p>map() 会根据提供的函数对指定序列做映射。<br>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p></blockquote><h3 id="2。-上题我们来变形下，我要求得出如下结果-‘aa’-‘bb’-‘ccc’-‘d’-‘x’-‘t’"><a href="#2。-上题我们来变形下，我要求得出如下结果-‘aa’-‘bb’-‘ccc’-‘d’-‘x’-‘t’" class="headerlink" title="2。 上题我们来变形下，我要求得出如下结果 [‘aa’, ‘bb’, ‘ccc’, ‘d’, ‘x’, ‘t’]"></a>2。 上题我们来变形下，我要求得出如下结果 [‘aa’, ‘bb’, ‘ccc’, ‘d’, ‘x’, ‘t’]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">            <span class="keyword">return</span></div><div class="line">    d = OrderedDict()</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> s:</div><div class="line">        <span class="keyword">if</span> _ <span class="keyword">in</span> d.keys():</div><div class="line">            d.update(&#123;_:d[_]+<span class="number">1</span>&#125;)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            d.update(&#123;_: d.setdefault(_, <span class="number">1</span>)&#125;)</div><div class="line">    <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x: d[x]*x, d))</div><div class="line">print(count_s(<span class="string">'abbcccdxt'</span>))</div></pre></td></tr></table></figure><h3 id="3。-我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’。‘bb’由于字符数2个相同不打印出"><a href="#3。-我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’。‘bb’由于字符数2个相同不打印出" class="headerlink" title="3。 我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’。‘bb’由于字符数2个相同不打印出"></a>3。 我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’。‘bb’由于字符数2个相同不打印出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</div><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">     <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">             <span class="keyword">return</span></div><div class="line">     d = OrderedDict()</div><div class="line">     <span class="keyword">for</span> _ <span class="keyword">in</span> s:</div><div class="line">         <span class="keyword">if</span> _ <span class="keyword">in</span> d.keys():</div><div class="line">             d.update(&#123;_:d[_]+<span class="number">1</span>&#125;)</div><div class="line">         <span class="keyword">else</span>:</div><div class="line">             d.update(&#123;_: d.setdefault(_, <span class="number">1</span>)&#125;)</div><div class="line">     <span class="keyword">return</span> list(map(<span class="keyword">lambda</span> x: x*d[x],filter(<span class="keyword">lambda</span> x: <span class="keyword">True</span> <span class="keyword">if</span> d[x]==<span class="number">3</span> <span class="keyword">else</span> <span class="keyword">False</span> , d)))</div><div class="line"> print(count_s(<span class="string">'abbcccdxt'</span>))</div></pre></td></tr></table></figure><p><strong> filter(function, iterable) </strong></p><blockquote><p>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。<br>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p></blockquote><h3 id="4。-最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”-我们会得到’abc’-‘bcc’-‘ccb’-‘cbb’-‘bbc’-‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。"><a href="#4。-最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”-我们会得到’abc’-‘bcc’-‘ccb’-‘cbb’-‘bbc’-‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。" class="headerlink" title="4。 最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”,我们会得到’abc’, ‘bcc’, ‘ccb’, ‘cbb’, ‘bbc’, ‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。"></a>4。 最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”,我们会得到’abc’, ‘bcc’, ‘ccb’, ‘cbb’, ‘bbc’, ‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="keyword">return</span> [s[number:number+<span class="number">3</span>] <span class="keyword">for</span> number <span class="keyword">in</span> range(len(s)<span class="number">-2</span>)]</div><div class="line"></div><div class="line">print(Counter(count_s(<span class="string">'abccbbcc'</span>)))</div><div class="line"></div></pre></td></tr></table></figure><h3 id="这个题目，有各种变形，比如我现在要求出字符串的所有子集，-例如-给你‘123’我要得到-‘1’-‘2’-‘3’-‘1’-‘2’-‘2’-‘3’-‘1’-‘2’-‘3’"><a href="#这个题目，有各种变形，比如我现在要求出字符串的所有子集，-例如-给你‘123’我要得到-‘1’-‘2’-‘3’-‘1’-‘2’-‘2’-‘3’-‘1’-‘2’-‘3’" class="headerlink" title="这个题目，有各种变形，比如我现在要求出字符串的所有子集， 例如 给你‘123’我要得到[[‘1’], [‘2’], [‘3’], [‘1’, ‘2’], [‘2’, ‘3’], [‘1’, ‘2’, ‘3’]]"></a>这个题目，有各种变形，比如我现在要求出字符串的所有子集， 例如 给你‘123’我要得到[[‘1’], [‘2’], [‘3’], [‘1’, ‘2’], [‘2’, ‘3’], [‘1’, ‘2’, ‘3’]]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s) &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">        <span class="keyword">return</span></div><div class="line">    r = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</div><div class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> [s[number:number + i+<span class="number">1</span>] <span class="keyword">for</span> number <span class="keyword">in</span> range(len(s) - i)]:</div><div class="line">                r.append(list(item))</div><div class="line">    <span class="keyword">return</span> r</div><div class="line"></div><div class="line">print((count_s(<span class="string">'123'</span>)))</div></pre></td></tr></table></figure><p>怎么样，这一圈下来明白python的标准库有多强大了吧， 作为一个pythoner，一定要足够pythonic.</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口测试入门及进阶</title>
      <link href="/2018/07/16/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6/"/>
      <url>/2018/07/16/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>本文是功能测试进阶系列直播课程第3讲，接口测试入门及进阶。 请至公众号 <strong> TesterTalk </strong> 查看详细内容。<br><a id="more"></a></p><p>RPC:远程过程调用。RPC的核心并不在于使用什么协议。RPC的目的是让你在本地调用远程的方法，而对你来说这个调用是透明的，你并不知道这个调用的方法是部署哪里。通过RPC能解耦服务，这才是使用RPC的真正目的。RPC的原理主要用到了动态代理模式，至于http协议，只是传输协议而已。</p><p>RPC是一个软件结构概念，是构建分布式应用的理论基础。就好比为啥你家可以用到发电厂发出来的电？是因为电是可以传输的。至于用铜线还是用铁丝还是其他 种类的导线，也就是用http还是用其他协议的问题了。</p><p>RESTful ： 简称 REST,是描述了一个架构样式的网络系统，其核心是面向资源，REST专门针对网络应用设计和开发方式，以降低开发的复杂性，提高系统的可伸缩性。REST提出设计概念和准则为：</p><p>  1.网络上的所有事物都可以被抽象为资源(resource)</p><p>  2.每一个资源都有唯一的资源标识(resource identifier)，对资源的操作不会改变这些标识</p><p>  3.所有的操作都是无状态的</p><p>REST – REpresentational State Transfer 直接翻译：表现层状态转移。一句话概括很精辟：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p><p>REST不是”rest”这个单词，而是几个单词缩写。 但即使那几个单词说出来，也无法理解在说什么 -_-!! （不是要贬低人，是我自己也理解困难）；1.<br>REST描述的是在网络中client和server的一种交互形式；<br>REST本身不实用，实用的是如何设计 RESTful API（REST风格的网络接口）；</p><ol><li>Server提供的RESTful API中，URL中只使用名词来指定资源，原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心。<br>比如：<a href="http://api.qc.com/v1/newsfeed" target="_blank" rel="external">http://api.qc.com/v1/newsfeed</a>: 获取某人的新鲜;<br><a href="http://api.qc.com/v1/friends" target="_blank" rel="external">http://api.qc.com/v1/friends</a>: 获取某人的好友列表;<br><a href="http://api.qc.com/v1/profile" target="_blank" rel="external">http://api.qc.com/v1/profile</a>: 获取某人的详细信息;</li><li>用HTTP协议里的动词来实现资源的添加，修改，删除等操作。即通过HTTP动词来实现资源的状态扭转：<br>GET    用来获取资源，<br>POST  用来新建资源（也可以用于更新资源），<br>PUT    用来更新资源，<br>DELETE  用来删除资源。<br>比如：DELETE <a href="http://api.qc.com/v1/friends" target="_blank" rel="external">http://api.qc.com/v1/friends</a>: 删除某人的好友 （在http parameter指定好友id）<br>POST <a href="http://api.qc.com/v1/friends" target="_blank" rel="external">http://api.qc.com/v1/friends</a>: 添加好友<br>UPDATE <a href="http://api.qc.com/v1/profile" target="_blank" rel="external">http://api.qc.com/v1/profile</a>: 更新个人资料<br>禁止使用： GET <a href="http://api.qc.com/v1/deleteFriend" target="_blank" rel="external">http://api.qc.com/v1/deleteFriend</a></li></ol><p>看Url就知道要什么<br>看http method就知道干什么<br>看http status code就知道结果如何</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试入门与进阶</title>
      <link href="/2018/07/11/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
      <url>/2018/07/11/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<p>本文是功能测试进阶系列直播课程第2讲，自动化测试入门与进阶。 请至公众号 <strong> TesterTalk </strong> 查看详细内容。<br><a id="more"></a></p><p>大家晚上好，<br>能在周日晚上8点还来听直播的人，都是比较自律的人，感谢你们的到来。<br>今天是我们手工测试进阶的第2讲–自动化测试入门与进阶。</p><p>对于大多数手工测试人员或者说不会自动化的人来说，自动化测试显得很神秘，很高大上，很难。很多人想学又没有信心，学几天遇到问题就放弃的大有人在。<br>其实自动化测试也是每一个初入职场的年轻人要跨越的一个坎儿，就像你年轻时想玩而又没玩过的游戏，想追但又追上的姑娘。 在你没得到的时候，你愿意倾其所有沉溺其中，这个是好事儿，特别对年轻人来说，有的追比没的追要好。但切忌不要把自动化当作你的日思夜想的女神，你把它抬的越高，你就越渺小。等你过了这个阶段，你就会发现，女神也会上厕所，自动化也发现不了新bug。</p><p>好，讲这个主要是为了说明，自动化测试不是什么金枝玉叶，所谓和尚摸得，我阿Q也摸得。没了这层畏难的情绪，自动化学起来就容易多了。</p><p>大家都知道，追姑娘要潘驴邓小闲，做自动化我认为也得要5个要素，我总结下，就是势力大过天：<br>势 – 就是势力的势。 大家普遍认为该上自动化了/手工测试确实已经满足不了项目需要了。<br>力 – 就是势力的力。 团队成员有技术实力，能搞起来，起码有个带头的。<br>大 – 就是大。 老板知情，并支持。这样才能有钱有资源。<br>过 – 就是功过的过。自动化肯定不是一番风顺，做成做不成，功未必有，过一定少不了，有提早有意识并能承受。<br>天 – 就是每天的天。自动化不是做好了就放那里了， 要天天看，有错误要及时debug，要随时更新，保持有效。</p><p>大家都看过 《google软件测试》这本书吧，google里unit test占比大约在70%，API test占比在20%作用，剩下的10%在UI自动化。这个也符合自动化分层理论，<br>（放图）， 大家可以看到这个模型，UI自动化仅仅占据了很小的一部分， 下次分享我会讲下API如何做自动化。</p><p>其实UI自动化测试的最大挑战就是元素识别，元素识别到了，后续操作就简单了，而掌握元素识别，需要你对 XPATH，CSS等一些HTML基础知识有所了解，要想使用好，就要对javascript， jquery有所了解，这些都需要平常的积累和有针对性的练习。</p><p>再说两个常见问题：</p><ol><li>元素要达到某个条件才显示<br>display:none 改变页面元素显示状态，  block<br>2.弹出框问题：<br>看我公众号文章，一劳永逸。</li></ol><p>以上就是我今天的分享，毕竟，语音和图片类型的直播由于条件限制不能直接给大家演示代码，自动化方面的常见问题及解答，大家可以去我公众号看看， 直接回复 “自动化测试” 就可以。我的公众号是 TesterTalk。</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论测试人员的核心竞争力</title>
      <link href="/2018/07/08/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E8%AE%BA%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/"/>
      <url>/2018/07/08/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E8%AE%BA%E6%B5%8B%E8%AF%95%E4%BA%BA%E5%91%98%E7%9A%84%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>本文是功能测试进阶系列直播课程第1讲–论测试人员的核心竞争力，直播脱水版。 更详细内容， 请至公众号 <strong> TesterTalk </strong> 查看。<br><a id="more"></a></p><p>今天我分享的主题是“论测试人员的核心竞争力”？ 那么我先问下大家，你们觉得测试人员的核心竞争力是什么？ 有的说，发现bug的数量，有的说开发能力，有的说业务能力。<br>那么，我，蔡老师，是怎么想的呢？ 我在抛出我的观点前，先跟大家分享一个故事。</p><p>三国演义，大家都知道吧？ 刘关张桃园三结义，创下了一段历史经典，也开创了一个帝国。 那么，我问一个问题，为什么卖草鞋的刘备能当大哥？腰缠万贯的地主张飞只能做小弟啊？<br>我们再来看， 桃园三结义的地点是哪里？张飞的一处庄园。<br>祭祀用的牛羊哪里来的？张飞买的。<br>结义完，打黄巾军要招募人才，怎么招募的？ 张飞散尽家财。<br>你说，同样是屠夫，为什么人家隔壁水浒传里的郑屠还能欺行霸市，强抢民女，我张飞只能把自己卖了，还给人数钱啊？</p><p>说到这里，有朋友可能有不同意见，说刘备乃中山靖王之后，出场自带BGM，那好，我们先放过这个大耳贼，就说卖枣子的那位吧？论长相，面若重枣，这个职业生涯都写在脸上了。咱们张大官人， 糙是糙了点，起码面部没有明显缺陷。<br>论职业，关二哥属于小本经营，连个铺面都没有。 咱们张大官人，做屠夫可是庄园好几处了。<br>论能力，关二哥可以温酒斩华雄，咱张大官人可是能百万军中取上将之头， 况且，这句话还是关二哥对曹操说的，你琢磨琢磨，CEO夸你，小样，技术不错嘛，你说，不行不行，张大官人可比我厉害多了。那个更牛逼啊？<br>可以说，要不是爱舞蹈弄枪，咱张大官人也能像隔壁西门大官人那样，天天当新郎，夜夜入洞房了。 对吧？ 那凭什么我这么牛逼确给别人当小弟呢？大耳贼卖个草鞋就能取东吴公主？<br>凭的就是双手过膝的刘备掌握了乱世成功的核心竞争力， 而咱们小资产阶级的张大官人，也只能牵马坠蹬，任其驱使。</p><p>那么，我们测试，要想开创一番事业，应该掌握的核心竞争力是那个呢？</p><p>在我看来，只有一条 ： “持续提升团队效率”。 </p><p>为什么测试核心竞争力是持续提升团队效率啊? 你想啊，老板是开公司的，开公司是为了干嘛？赚钱,对吧，那么怎么赚钱？卖产品，卖服务？产品和服务如何能卖出去？产品和服务必须要质量好，质量达标了才谈得上其它，对吧？<br>那么如何把产品和质量搞好？ 开发敬畏每一行代码， 产品研究透用户需求和痛点， 那么测试呢？ 能做什么？测试作为开发流程的一部分，是不是要从规范流程，提出问题，验证方案，观察效果，来倒逼着团队改善啊？ 那么，这个活动本身，总结一下，是不是就是持续提升团队效率？！！</p><p>好了，现在大家都没有异议了， 我们来看，如何持续提升团队效率？</p><ol><li>既然要提升团队效率， 那么我们就得搞明白团队是怎么运作的。<br>（放图片， 讲解）<br>那么， 我们看，对于处于不同阶段的团队，对于团队成语来自不同地方，外部和内部的团队，我们测试还能不能用同一套方法来提升效率啊？ 不能吧？<br>2.什么是效率。<br>（放图片， 讲解）。  AB两个人，同样的工作，完成的时间不同， 谁效率高？ 是不是时间短的效率就高？ 那么A的工作业务一变化就要重构，B的永远不要改呢？这个时候谁的效率高？<br>效率总要结合自己公司情况的。<br>3.确定好了团队，效率，就相当于，你知道了你要去哪里，你也知道了到那里后要干什么。 现在就是怎么到那里的问题了。<br>毛主席说过，要战略上藐视敌人，战术上重视敌人。 那么这个战术是什么呢？<br>就我的理解来看，可以分成以下几个部分：<br>1.思想篇。<br>（放图片， 讲解）。 古人云，发上等愿，做中等事，结下等果。 如果测试的思想仅仅局限于测试，你就只能在测试的小圈圈里打转，就不可能获得全局的视野。<br>2.技能篇。<br>（放图片， 讲解）。 关羽的赤兔马，吕布的方天画戟，我们的业务， 代码， 和自动化。 每一个都不能少。<br>讲沟通时候，放“俺也一样”图片。<br>3.影响篇。<br>俗话说，三人成虎。  一件事情，说的人多了就成了真的， 那么我们测试就要不停的影响周边的人，让更多的人参与到改善质量的行列中来，那么我们能发挥影响的范围就会越来越大。</li></ol><p>（放图片， 讲解）</p><p>最后，人的能力千差万别，有的人一出场就是带头大哥， 有的人拼死拼活也只能给人当小弟。 我们无需羡慕，只需做好自己就行。 就像我看动漫，我永远不喜欢粉主角， 灌篮高手里我喜欢看三井寿对梦想的坚持， 火影忍者里我欣赏甚至羡慕Rock li对超越自己的极致追求。 至于你想当月亮还是愿做萤火虫，都是个人的选择而已。<br>最后一首小诗结束今天的分享：<br>天下风云出我辈<br>一入江湖岁月催<br>王图霸业笑谈中<br>不胜人生一场醉。   </p><p>谢谢大家。，谢谢大家的支持！</p><p>最后的最后，最关键的没说。 大家可以关注我的公众号 <strong> Testertalk </strong>， 我会持续分享软件测试的技术.</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的字符串相关面试题</title>
      <link href="/2018/07/02/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/07/02/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>面试过程中， 算法几乎变成了一个逃不过去的坎儿， 而在算法的面试中， 关于字符串的问题很常见，也很基础，今天我们就来讲几个非常有代表意义的面试题。</p><a id="more"></a><h3 id="1。-给定一个字符串，求字符串中连续相同的字符的个数，-例如给定字符串“abbcccdxt”，输出-‘a1’-’b2’-’c3’-’d1’-’x1’-’t1’"><a href="#1。-给定一个字符串，求字符串中连续相同的字符的个数，-例如给定字符串“abbcccdxt”，输出-‘a1’-’b2’-’c3’-’d1’-’x1’-’t1’" class="headerlink" title="1。 给定一个字符串，求字符串中连续相同的字符的个数， 例如给定字符串“abbcccdxt”，输出[‘a1’,’b2’,’c3’,’d1’,’x1’,’t1’]"></a>1。 给定一个字符串，求字符串中连续相同的字符的个数， 例如给定字符串“abbcccdxt”，输出[‘a1’,’b2’,’c3’,’d1’,’x1’,’t1’]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">        <span class="keyword">return</span></div><div class="line">    base = s[<span class="number">0</span>]</div><div class="line">    result = []</div><div class="line">    count = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</div><div class="line">        <span class="keyword">if</span> i == base:</div><div class="line">            count +=<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            result.append(base+str(count))</div><div class="line">            count =<span class="number">1</span></div><div class="line">            base = i</div><div class="line">    result.append(base + str(count))</div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line">print(count_s(<span class="string">'abbcccdxt'</span>))</div><div class="line"></div></pre></td></tr></table></figure><h3 id="2。-上题我们来变形下，我要求得出如下结果-‘aa’-‘bb’-‘ccc’-‘d’-‘x’-‘t’"><a href="#2。-上题我们来变形下，我要求得出如下结果-‘aa’-‘bb’-‘ccc’-‘d’-‘x’-‘t’" class="headerlink" title="2。 上题我们来变形下，我要求得出如下结果 [‘aa’, ‘bb’, ‘ccc’, ‘d’, ‘x’, ‘t’]"></a>2。 上题我们来变形下，我要求得出如下结果 [‘aa’, ‘bb’, ‘ccc’, ‘d’, ‘x’, ‘t’]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">        <span class="keyword">return</span></div><div class="line">    base = s[<span class="number">0</span>]</div><div class="line">    result = []</div><div class="line">    count = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</div><div class="line">        <span class="keyword">if</span> i == base:</div><div class="line">            count +=<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            result.append(base*count)</div><div class="line">            count =<span class="number">1</span></div><div class="line">            base = i</div><div class="line">    result.append(base *count)</div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line">print(count_s(<span class="string">'abbcccdxt'</span>))</div><div class="line"></div></pre></td></tr></table></figure><h3 id="3。-我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’，‘bb’由于字符数2个相同不打印出"><a href="#3。-我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’，‘bb’由于字符数2个相同不打印出" class="headerlink" title="3。 我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’，‘bb’由于字符数2个相同不打印出"></a>3。 我们再变下，求字符串中连续相同个数是3的字符，比如打印出‘ccc’，‘bb’由于字符数2个相同不打印出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">        <span class="keyword">return</span></div><div class="line">    base = s[<span class="number">0</span>]</div><div class="line">    result = []</div><div class="line">    count = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s[<span class="number">1</span>:]:</div><div class="line">        <span class="keyword">if</span> i == base:</div><div class="line">            count +=<span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> count ==<span class="number">3</span>:</div><div class="line">                result.append(base*count)</div><div class="line">            count =<span class="number">1</span></div><div class="line">            base = i</div><div class="line">    <span class="keyword">if</span> count == <span class="number">3</span>:</div><div class="line">        result.append(base * count)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line">print(count_s(<span class="string">'abbcccdxt'</span>))</div></pre></td></tr></table></figure><h3 id="4。-最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”-我们会得到’abc’-‘bcc’-‘ccb’-‘cbb’-‘bbc’-‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。"><a href="#4。-最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”-我们会得到’abc’-‘bcc’-‘ccb’-‘cbb’-‘bbc’-‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。" class="headerlink" title="4。 最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”,我们会得到’abc’, ‘bcc’, ‘ccb’, ‘cbb’, ‘bbc’, ‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。"></a>4。 最后，再来“作”一下，我现在不要求连续相同了，我要求得出字符串中所有3个字符的重复个数，比如字符串“abccbbcc”,我们会得到’abc’, ‘bcc’, ‘ccb’, ‘cbb’, ‘bbc’, ‘bcc’这些长度为3的字符，其中“bcc”出现2次，其它都出现一次。我们要实现它。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_s</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">if</span> len(s)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="keyword">not</span> isinstance(s, str):</div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="keyword">return</span> [s[number:number+<span class="number">3</span>] <span class="keyword">for</span> number <span class="keyword">in</span> range(len(s)<span class="number">-2</span>)]</div><div class="line"></div><div class="line">print(Counter(count_s(<span class="string">'abccbbcc'</span>)))</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Headless实现无UI自动化</title>
      <link href="/2018/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Headless%E5%AE%9E%E7%8E%B0%E6%97%A0UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
      <url>/2018/06/28/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Headless%E5%AE%9E%E7%8E%B0%E6%97%A0UI%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在做自动化的时， 偶尔你需要打开一个页面获取某些字段，但由于某些原因（通常是安全）， 你又不想这个页面展示出来， 这个时候，不打开浏览器而使用浏览器就是刚需了。<br>我本来以为这个是很基础的知识，这两天一直有人问，那么就干脆写下来吧。</p><a id="more"></a><p>Headless的浏览器我们以前经常用PhantomJS， 但随着google宣布支持headless后， PhantomJS也停止更新了，那么是时候使用headless了。</p><p>什么是Headless chrome呢？</p><blockquote><p>Headless Chrome 是 Chrome 浏览器的无界面形态，可以在不打开浏览器的前提下，使用所有 Chrome 支持的特性运行你的程序。相比于现代浏览器，Headless Chrome 更加方便测试 web 应用，获得网站的截图，做爬虫抓取信息等。相比于出道较早的 PhantomJS，SlimerJS 等，Headless Chrome 则更加贴近浏览器环境.</p></blockquote><p>Headless有什么好处呢？</p><blockquote><p>最直观的就是由于不需界面，所以速度上比普通浏览器稍快，也不会因为误操作界面导致人为错误。 另外，headless在爬虫程序，和网页截图时也经常用。</p></blockquote><p><strong> 如何使用？ </strong><br>chrome 的headless模式实现起来很简单，无需下载， 只要你运行的机器上有最新版的chrome即可（事实上59版本以后都支持）， 当然了你需要crhome driver在你python安装路径的根目录下。。<br>下面我们以百度首页为例，打印出搜索框的文本“百度一下”。</p><p><img src="/2018/06/28/自动化测试系列/利用Headless实现无UI自动化/baidu.JPG" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">options = webdriver.ChromeOptions()</div><div class="line"></div><div class="line">options.add_argument(<span class="string">'--headless'</span>)</div><div class="line">options.add_argument(<span class="string">'--disable-gpu'</span>)</div><div class="line"></div><div class="line">driver = webdriver.Chrome(chrome_options=options)</div><div class="line">driver.get(<span class="string">"http://baidu.com"</span>)</div><div class="line">time.sleep(<span class="number">1</span>)</div><div class="line">print(driver.find_element_by_xpath(<span class="string">".//*[@id='su']"</span>).get_attribute(<span class="string">"value"</span>))</div></pre></td></tr></table></figure></p><p>是不是很简单？全程没有看到网页被打开，但是我们还是获得了我们需要的元素。</p><p>事实上， headless 不仅仅chrome支持， firefox也支持。用法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"></div><div class="line">options = webdriver.FirefoxOptions()</div><div class="line">options.add_argument(<span class="string">'--headless'</span>)</div><div class="line">options.add_argument(<span class="string">'--disable-gpu'</span>)</div><div class="line"></div><div class="line">driver = webdriver.Firefox(firefox_options=options)</div><div class="line">driver.get(<span class="string">"http://baidu.com"</span>)</div><div class="line">time.sleep(<span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> driver.find_element_by_xpath(<span class="string">".//*[@id='su']"</span>).get_attribute(<span class="string">"value"</span>)</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫入门 --打造网站自生成系统（二）</title>
      <link href="/2018/06/24/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/06/24/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>上篇我们讲了下爬虫的基础知识，通过上篇的学习，我们已经知道了如何打造自己的爬虫，那么这篇讲下如何把下载好的内容生成到网页中并发布。<br><a id="more"></a></p><p>hexo 安装<br><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/index.html</a> </p><p>proxy：<br><a href="https://pypi.org/project/scrapy-rotating-proxies/" target="_blank" rel="external">https://pypi.org/project/scrapy-rotating-proxies/</a></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫入门 --打造网站自生成系统（一）</title>
      <link href="/2018/06/24/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/06/24/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>以前IT界流传着一句笑话：”当你一个朋友忽然消失了的时候，他不是去了华为就是去了阿里”。 对于没有在这两个宇宙大厂的我来说，这么长时间没消息，要么我弃坑不更了，要么折腾新玩意儿去了。<br>弃坑是不可能弃坑的，所以当你感叹这么好的公众号怎么也弃坑的时候，我都会拿一个新玩意儿来取悦你 ：）<br><a id="more"></a></p><p>爬虫其实不算是新的东西了， 网上也有很多的教程，都很详尽，那么我为什么还要拿出来说呢？因为我发现大多数教材都是教你如何从网络上爬取内容，然后就结束了。 但是我们爬下来的内容是要使用的啊？<br>这方面的就很少。还记得我之前分享过的<a href="http://helloqa.com/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">博客开发系列</a>吗？正好，我们把这两个结合起来，一起来看看，如何用爬虫打造专属自己的自动化博客生成系统。</p><p>本系列分为如下模块：<br>1.介绍爬虫框架scrapy的原理，及简单使用。<br>2.自动分析爬取的文章，分类并转化格式为适合博客的markdown格式。<br>3.自动发布博客，并介绍如何绑定域名。<br>4.每天躺在床上看自己的博客“更新”。</p><p>今天我们先看第一个， 爬虫框架Scrapy。</p><h3 id="首先，爬虫是什么呢？-爬虫的原理是什么？"><a href="#首先，爬虫是什么呢？-爬虫的原理是什么？" class="headerlink" title="首先，爬虫是什么呢？ 爬虫的原理是什么？"></a>首先，爬虫是什么呢？ 爬虫的原理是什么？</h3><p>爬虫是一个程序，用来获取网站的信息。 爬虫的原理一般是根据一定的分析算法找出用户想要的URL，放到一个队列里，然后按照一定的策略选择进一步要抓取的URL，直到满足停止条件。 然后对所有抓取的网页进行分析，过滤，存储并建立索引，方便后续查询，检索。 </p><h3 id="什么是scrapy"><a href="#什么是scrapy" class="headerlink" title="什么是scrapy"></a>什么是scrapy</h3><p>Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。</p><h3 id="scrapy原理-（此部分为官网文档，及网络摘抄）"><a href="#scrapy原理-（此部分为官网文档，及网络摘抄）" class="headerlink" title="scrapy原理 （此部分为官网文档，及网络摘抄）"></a>scrapy原理 （此部分为官网文档，及网络摘抄）</h3><p>Scrapy 使用了 Twisted异步网络库来处理网络通讯。整体架构大致如下（绿线是数据流向）：<br><img src="/2018/06/24/测试开发系列/爬虫系列/爬虫入门 --打造网站自生成系统（一）/scrapy_structure.jpg" alt=""></p><p>各部分详细说明如下：<br><img src="/2018/06/24/测试开发系列/爬虫系列/爬虫入门 --打造网站自生成系统（一）/scrapy_structure_detail.JPG" alt=""></p><p>一此完整的运行流程如下：<br><img src="/2018/06/24/测试开发系列/爬虫系列/爬虫入门 --打造网站自生成系统（一）/scrapy_structure_dataflow.JPG" alt=""></p><h3 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy</div></pre></td></tr></table></figure><h3 id="入门教程（官网摘取架构各部分作用，个人提供练习）"><a href="#入门教程（官网摘取架构各部分作用，个人提供练习）" class="headerlink" title="入门教程（官网摘取架构各部分作用，个人提供练习）"></a>入门教程（官网摘取架构各部分作用，个人提供练习）</h3><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在开始爬取之前，您必须创建一个新的Scrapy项目。 进入您打算存储代码的目录中，运行下列命令:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject _myspider</div></pre></td></tr></table></figure><br><img src="/2018/06/24/测试开发系列/爬虫系列/爬虫入门 --打造网站自生成系统（一）/scrapy_structure_project1.JPG" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scrapy.cfg  项目的配置信息，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中）</div><div class="line">items.py    设置数据存储模板，用于结构化数据，如：Django的Model</div><div class="line">pipelines    数据处理行为，如：一般结构化的数据持久化</div><div class="line">settings.py 配置文件，如：递归的层数、并发数，延迟下载等</div><div class="line">spiders      爬虫目录，如：创建文件，编写爬虫规则</div></pre></td></tr></table></figure></p><h3 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a>定义Item</h3><p>Item 是保存爬取到的数据的容器；其使用方法和python字典类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。</p><p>类似在ORM中做的一样，您可以通过创建一个 scrapy.Item 类， 并且定义类型为 scrapy.Field 的类属性来定义一个Item。 (如果不了解ORM, 不用担心，您会发现这个步骤非常简单)</p><p>首先根据需要从dmoz.org获取到的数据对item进行建模。 我们需要从dmoz中获取名字，url，以及网站的描述。 对此，在item中定义相应的字段。编辑 _myspider 目录中的 items.py 文件:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyspiderItem</span><span class="params">(scrapy.Item)</span>:</span></div><div class="line">    title = scrapy.Field()</div><div class="line">    link = scrapy.Field()</div><div class="line">    desc = scrapy.Field()</div></pre></td></tr></table></figure><br>一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义。</p><h3 id="编写第一个爬虫-Spider"><a href="#编写第一个爬虫-Spider" class="headerlink" title="编写第一个爬虫(Spider)"></a>编写第一个爬虫(Spider)</h3><p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。</p><p>其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。</p><p><strong> 为了创建一个Spider，您必须继承 scrapy.Spider 类， 且定义以下三个属性:<br>name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。<br>start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。<br>parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。 </strong></p><p>以下为我们的第一个Spider代码，保存在 _myspider/spiders 目录下的 mine.py 文件中:<br>我们要从10tiao.com这个网站爬取首页上的所有公号文章，并按照如下方式保存<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"author"</span>: <span class="string">"作者：谢宝友"</span>, <span class="string">"create_date"</span>: <span class="string">"2018-05-24 13:21"</span>, <span class="string">"name"</span>: <span class="string">"GitChat精选"</span>， content：...&#125; </div></pre></td></tr></table></figure><br><strong> start_requests </strong> 这个请求接收需要爬取的第一个页面，然后交给parse（）处理，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"><span class="keyword">import</span> scrapy</div><div class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector</div><div class="line"></div><div class="line"><span class="keyword">from</span> _myspider.items <span class="keyword">import</span> MyspiderItem</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuotesSpider</span><span class="params">(scrapy.Spider)</span>:</span></div><div class="line">    name = <span class="string">"quotes"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span><span class="params">(self)</span>:</span>  <span class="comment">#  start_requests这个函数也可以不要，只要有start_urls = [。。]即可。</span></div><div class="line">        url = <span class="string">"http://10tiao.com"</span></div><div class="line"></div><div class="line">        <span class="keyword">yield</span> scrapy.Request(url, self.parse)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">        info = MyspiderItem()</div><div class="line"></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> response.xpath(<span class="string">".//*[@id='id-content-wrap']//article"</span>):</div><div class="line">            info[<span class="string">"name"</span>] = Selector(text=i.extract()).xpath(<span class="string">"//*[@id='id-author-name']//text()"</span>).extract()[<span class="number">0</span>]</div><div class="line">            info[<span class="string">"title"</span>] = Selector(text=i.extract()).xpath(<span class="string">"//a//text()"</span>).extract()[<span class="number">0</span>]</div><div class="line"><span class="comment">#此url为了抽取标题下面的正文内容，url获取后，交给callback函数进一步处理。</span></div><div class="line">            url = Selector(text=i.extract()).xpath(<span class="string">"//h1[@class='post-title text-left']/a/@href"</span>).extract()[<span class="number">0</span>]</div><div class="line"><span class="comment">#注意meta，用来传递值到下一个处理函数。</span></div><div class="line">            <span class="keyword">yield</span> scrapy.Request(url, meta=&#123;<span class="string">'info1'</span>:info&#125;, callback=self.parse_url_contents)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_url_contents</span><span class="params">(self, response)</span>:</span></div><div class="line">        info = MyspiderItem()</div><div class="line">        info1 = response.meta[<span class="string">'info1'</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> response.xpath(<span class="string">".//*[@id='img-content']"</span>):</div><div class="line"><span class="comment">#Scrapy提供了Selector选择器供我们筛选出目标选项。具体请参考Selector文档</span></div><div class="line">            info[<span class="string">'create_date'</span>] = Selector(text=i.extract()).xpath(<span class="string">"//*[@id='post-date']/text()"</span>).extract()[<span class="number">0</span>]</div><div class="line">            info[<span class="string">'author'</span>] = Selector(text=i.extract()).xpath(<span class="string">"//*[@id='author']/text()"</span>).extract()[<span class="number">0</span>]</div><div class="line">            info[<span class="string">'content'</span>] = Selector(text=i.extract()).xpath(<span class="string">"//*[@id='js_content']"</span>).extract()[<span class="number">0</span>]</div><div class="line">            info[<span class="string">"name"</span>] = info1[<span class="string">"name"</span>]</div><div class="line">            <span class="keyword">yield</span> info</div></pre></td></tr></table></figure></p><p>注意：<br>Request中meta参数的作用是传递信息给下一个函数，使用过程可以理解成：把需要传递的信息赋值给这个叫meta的变量，但meta只接受字典类型的赋值，因此要把待传递的信息改成“字典”的形式，即：meta={‘key1’:value1,’key2’:value2}</p><p>如果想在下一个函数中取出value1,只需得到上一个函数的meta[‘key1’]即可，因为meta是随着Request产生时传递的，下一个函数得到的Response对象中就会有meta，即response.meta，取value1则是value1=response.meta[‘key1’]</p><h3 id="存储结果（Pipeline）"><a href="#存储结果（Pipeline）" class="headerlink" title="存储结果（Pipeline）"></a>存储结果（Pipeline）</h3><p>Item pipeline 的主要责任是负责处理 spider 抽取的 Item，主要任务是清理、验证和持久化数据。当页面被 spider 解析后，将被发送到 pipeline，每个 pipeline 的组件都是由一个简单的方法组成的Python类。pipeline 获取Item，执行相应的方法，并确定是否需要在 pipeline中继续执行下一步或是直接丢弃掉不处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">import</span> codecs</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyspiderPipeline</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line"><span class="comment">#这里简单的保存到result.json文件里。</span></div><div class="line">        self.file = codecs.open(<span class="string">'result.json'</span>, <span class="string">'wb'</span>, encoding=<span class="string">'utf-8'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></div><div class="line">        line = json.dumps(dict(item), ensure_ascii=<span class="keyword">False</span>) + <span class="string">"\n"</span></div><div class="line">        self.file.write(line)</div><div class="line">        <span class="keyword">return</span> item</div></pre></td></tr></table></figure></p><h3 id="激活Item-Pipeline组件"><a href="#激活Item-Pipeline组件" class="headerlink" title="激活Item Pipeline组件"></a>激活Item Pipeline组件</h3><p>在settings.py文件中，往ITEM_PIPELINES中添加项目管道的类名，激活项目管道组件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ITEM_PIPELINES = &#123;</div><div class="line">   <span class="string">'_myspider.pipelines.MyspiderPipeline'</span>: <span class="number">300</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="运行爬虫"><a href="#运行爬虫" class="headerlink" title="运行爬虫"></a>运行爬虫</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scrapy crawl quotes  <span class="comment">#quotes是你在spider里定义的爬虫名字。</span></div><div class="line">你也可以把运行的结果dump到文件里：</div><div class="line">scrapy crawl quotes -o result.json</div></pre></td></tr></table></figure><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><ol><li>看下我们的运行结果， result.json节选：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#为了排版方便，我把content里的内容注释掉了。</span></div><div class="line">&#123;<span class="string">"author"</span>: <span class="string">"Google Play"</span>, <span class="string">"create_date"</span>: <span class="string">"2018-05-24 13:00"</span>, <span class="string">"name"</span>: <span class="string">"GitChat精选"</span>&#125;</div><div class="line">&#123;<span class="string">"author"</span>: <span class="string">"张 璁"</span>, <span class="string">"create_date"</span>: <span class="string">"2018-05-24 13:34"</span>, <span class="string">"name"</span>: <span class="string">"GitChat精选"</span>&#125;</div><div class="line">&#123;<span class="string">"author"</span>: <span class="string">"机器之心"</span>, <span class="string">"create_date"</span>: <span class="string">"2018-05-24 12:23"</span>, <span class="string">"name"</span>: <span class="string">"GitChat精选"</span>&#125;</div><div class="line">&#123;<span class="string">"author"</span>: <span class="string">"机器之心"</span>, <span class="string">"create_date"</span>: <span class="string">"2018-05-24 12:23"</span>, <span class="string">"name"</span>: <span class="string">"GitChat精选"</span>&#125;</div></pre></td></tr></table></figure></li><li>是不是很简单？确实简单， 爬虫的爬取，收集信息比较直观，但是爬虫最重要的的问题就是经常被ban，至于如何解决，目前没有一劳永逸的方法，读者朋友们可以网络上搜索解决。</li><li>本文未涉及登录问题有些网站需要登录获取authentication token后才能继续爬取（我比较喜欢这个，方便控制）， 有两个办法，一个是用requests直接发请求获取后保存使用。第二scrapy貌似提供了登录的方法，这个我还没有研究， 大家可以自行研究。</li></ol>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫入门 --打造网站自生成系统（零）</title>
      <link href="/2018/06/06/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E9%9B%B6%EF%BC%89/"/>
      <url>/2018/06/06/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%20--%E6%89%93%E9%80%A0%E7%BD%91%E7%AB%99%E8%87%AA%E7%94%9F%E6%88%90%E7%B3%BB%E7%BB%9F%EF%BC%88%E9%9B%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>以前IT界流传着一句笑话：”当你一个朋友忽然消失了的时候，他不是去了华为就是去了阿里”。 对于没有在这两个宇宙大厂的我来说，这么长时间没消息，要么我弃坑不更了，要么折腾新玩意儿去了。<br>弃坑是不可能弃坑的，所以当你感叹这么好的公众号怎么也弃坑的时候，我都会拿一个新玩意儿来取悦你 ：）<br><a id="more"></a><br>首先，请大家web浏览器或者手机浏览器输入 qahome.cn  看看这个网站。<br>很普通嘛，甚至还有些许bug，但是如果我告诉你，这个网站，包括网站布局，内容，都是自动生成的呢？<br>如果我再告诉你，这个网站还有”生命“， 会自动发布新文章并分门别类呢？</p><p>是不是有点技术含量了啊？ 这个就是最近阶段我的所学成果 – 网络爬虫。</p><p>简单来说，我做了如下事情:</p><ol><li>代码自动抓取用户感兴趣的内容。</li><li>内容抓下来后，自动清洗，排版，转换格式，加私货，然后保存。</li><li>结合网站模板自动发布。</li><li>你只需天天躺在家里看你的网站更新即可。</li></ol><p>后面我会抽出时间详细普及下爬虫及爬虫框架，敬请期待！</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求1000以内的素数</title>
      <link href="/2018/04/24/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/%E6%B1%821000%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0/"/>
      <url>/2018/04/24/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/%E6%B1%821000%E4%BB%A5%E5%86%85%E7%9A%84%E7%B4%A0%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>算法问题逐渐成为面试题里的必考题目，但大多测试人员都对其不太重视，笔者也是如此，故决定开一个系列，不定期分享一些算法题目。今天来看一道经典的面试题，求1000内的素数。<br><a id="more"></a></p><h2 id="素数定义："><a href="#素数定义：" class="headerlink" title="素数定义："></a>素数定义：</h2><p>除了1和它本身之外再不能被其他数整除的自然数。</p><p>##算法思想：</p><h3 id="第一种解法-–-直接根据素数定义来，对于给定的数n，拿1～n-1的数去除n，只有n不能被任一个数整除，n才是素数。"><a href="#第一种解法-–-直接根据素数定义来，对于给定的数n，拿1～n-1的数去除n，只有n不能被任一个数整除，n才是素数。" class="headerlink" title="第一种解法 – 直接根据素数定义来，对于给定的数n，拿1～n-1的数去除n，只有n不能被任一个数整除，n才是素数。"></a>第一种解法 – 直接根据素数定义来，对于给定的数n，拿1～n-1的数去除n，只有n不能被任一个数整除，n才是素数。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prime</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n): <span class="comment">#1不是素数，所以循环从2开始</span></div><div class="line">        <span class="keyword">if</span> n%i ==<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prime</span><span class="params">(x)</span>:</span></div><div class="line">    r_list = []</div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, x+<span class="number">1</span>): <span class="comment">#1不是素数，所以循环从2开始， 求到x为止的素食，所以循环需要到x+1.</span></div><div class="line">        <span class="keyword">if</span> prime(n):</div><div class="line">            r_list.append(n)</div><div class="line">    <span class="keyword">return</span> r_list</div><div class="line"></div><div class="line">print((get_prime(<span class="number">1000</span>))</div></pre></td></tr></table></figure><p>看起来很简单对不对，但随着x的增大，时间复杂度开销太大了，有没有更好的方法呢？</p><ol><li>对于一个自然数N，只要能被一个非1非自身的数整除，它就肯定不是素数。 我们一定要一个个的除过去吗？非也</li><li>对于一个自然数N，如果它不是素数，是合数，那么肯定存在1到N的两个数，n1×n2=N。 那么n1 和n2不可能两个都大于根号n（√N），不难理解吧？我们可以把n1和n2看<br>成一对，假设n1 &lt; √N，那么，只要n1能被N整除，N就不是素数。 也就是说， 只要2到√N之间的数能被N整除，那么N就不是素数，否则，N就是素数。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prime</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n)+<span class="number">1</span>)):</div><div class="line">        <span class="keyword">if</span> n%i ==<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prime</span><span class="params">(x)</span>:</span></div><div class="line">    r_list = []</div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, x+<span class="number">1</span>):</div><div class="line">        <span class="keyword">if</span> prime(n):</div><div class="line">            r_list.append(n)</div><div class="line">    <span class="keyword">return</span> r_list</div><div class="line"></div><div class="line">print(len(get_prime(<span class="number">1000</span>)))</div></pre></td></tr></table></figure></li></ol><p>对于每一个n, 查找范围是不是少了一半？ 我们再来想下。</p><p>除2之外的偶数，会不会是素数？不可能把，也就是说，偶数只有2是素数，那么素数之剩下奇数了，优化如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">prime</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(math.sqrt(n)+<span class="number">1</span>)):</div><div class="line">        <span class="keyword">if</span> n%i ==<span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_prime</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">if</span> x&lt;<span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> x ==<span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span></div><div class="line">    r_list = [<span class="number">2</span>]</div><div class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>, x+<span class="number">1</span>, <span class="number">2</span>):</div><div class="line">        <span class="keyword">if</span> prime(n):</div><div class="line">            r_list.append(n)</div><div class="line">    <span class="keyword">return</span> r_list</div><div class="line"></div><div class="line">print(len(get_prime(<span class="number">1000</span>)))</div></pre></td></tr></table></figure></p><h3 id="第二种解法-–-埃氏筛法"><a href="#第二种解法-–-埃氏筛法" class="headerlink" title="第二种解法 – 埃氏筛法."></a>第二种解法 – 埃氏筛法.</h3><ol><li>列出从2开始的所有自然数，构造一个序列：2, 3, 4, 5, 6, 7, 8, 9, 10 …</li><li>取序列的第一个数2，它一定是素数，然后把序列的2的倍数筛掉, 剩下：3,5,7，9….</li><li>取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：5,7,….</li><li>取新序列的第一个数5，然后用5把序列的5的倍数筛掉：7…</li><li>不断筛下去，就可以得到所有的素数。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#以下代码摘抄自网络</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></div><div class="line">    n = <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        n = n + <span class="number">2</span></div><div class="line">        <span class="keyword">yield</span> n</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span><span class="params">(n)</span>:</span> <span class="comment">#先别着急理解这个函数，看后面。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span>  <span class="comment">#此处&gt;0可以更改为！=0.不影响结果，原因是要把所有可以被素数整除的数筛选掉。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">yield</span> <span class="number">2</span></div><div class="line">    it = _odd_iter() <span class="comment"># 初始序列</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></div><div class="line">        <span class="keyword">yield</span> n</div><div class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></div><div class="line"><span class="comment">#难点在于理解这个_not_divisible函数里的x。filter函数用法是：filter(fuction,list)：将list中每一个元素带入到function中，计算返回值，将返回值为True的list中的元素形成一个新的list。</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</div><div class="line">    <span class="keyword">if</span> n &lt; <span class="number">10</span>:</div><div class="line">        print(n)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想进BAT？这些面试题助你一臂之力（附答案）</title>
      <link href="/2018/04/10/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/%E6%83%B3%E8%BF%9BBAT%EF%BC%9F%E8%BF%99%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/"/>
      <url>/2018/04/10/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/%E6%83%B3%E8%BF%9BBAT%EF%BC%9F%E8%BF%99%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8A%A9%E4%BD%A0%E4%B8%80%E8%87%82%E4%B9%8B%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<p>请微信添加公众号TesterTalk获取此文章密码。<br>昨天TesterHome发表了如下文章《被同龄人抛弃？68道中高级测试工程师面试题助你一臂之力》引爆了我的朋友圈。 我大致看了下，里面的问题很有代表性，即使是我这样的老司机，没有经过充分准备也不能回答的令自己满意，故花点时间，写下这些面试题的答案，给大家参考，也欢迎大家讨论指正。</p><p>正文全部引用上述文章的问题，答案写在每一个问题下面。</p><a id="more"></a><h1 id="1-软性热身题"><a href="#1-软性热身题" class="headerlink" title="1 软性热身题"></a>1 软性热身题</h1><p>这种题目，考的就是你的软性能力，比如表达能力，理解能力，协调能力，一个词概括就是套路。这类题目会在面试开始热身的时候，问一道两题，不会多，但是如果你能回答的有条不紊，清晰达意，那么就会给面试官留下非常好的印象，大致的题目如下：</p><p>自我介绍</p><p><font color="red">我叫XXX，毕业于XXX，从事测试行业已经XX年，我擅长接口测试自动化，测试框架，巴拉巴拉，我共服务过X个公司分别有Y个成就，江湖人称666.总之，尽量用<br>简介的语言突出自己的优点，要保持humble，就像我介绍的这样，嗯：）</font></p><p>介绍下你负责的公司项目</p><p><font color="red">我主导了XXX，协助了YYY，参与了ZZZ。 这个回答你要记清楚，后续的面试肯定还有项目细节，甚至技术实现细节。同类的项目说一个足以，重点突出不同技术栈或者有管理，对外沟通的项目</font></p><p>你有什么优点和缺点？</p><p><font color="red">实际情况作答，比如优点是长的好看，缺点是太好看之类的，总之，要谦虚，不要傲。</font></p><p><br><br>在同一个项目组内，你认为你怎么做会比另外一名测试更加优秀？<br></p><p><font color="red">我个人认为这个题目很有迷惑性，如果你只追求比别人优秀，肯定很难跟别人合作，如果你没有别人优秀，那么我为什么要用你？<br>要我答的话，我重点会放在如何一点一滴积累技术实力，及用这些实力解决项目组存在的问题上，这实际上也是很多优秀测试人员的必备素质</font></p><p><br><br>你为什么离开上家公司？离职原因（这个会在最后问）<br></p><p><font color="red">看老板不爽啊，PM太SB啦喜欢的同事跟开发跑啦等等， 一个都不要说！！！ 我要面试别人，关注的是离职背后的动机，这人是不是被开除的，这人是不是不好相处，这人是不是有明显性格缺陷，只要不沾这些必死项，其它实际作答吧。</font></p><p><br><br><strong> <p><font color="red"> 个人觉得软性题，不必要过多关注，除自我介绍外，通常是通过面试后HR关的闲聊题，主要还是要关注下面的技术问题。</font></p><p> </p></strong><br><br># 2 测试理论基础题<br><br>这类题目就是考测试工程师的基本能力了，比如测试计划，测试流程，如何bug，你做过哪些测试，一般我们认为这些能力做的再好都是应该的，不会有加分，但是只要做的不好，那就是个不合格的测试工程师了。这种题目也不会问的太多，大概题目如下：<br><br>请描述下你上个公司的测试流程？<br></p><p><font color="red">实际情况作答， Scrum模式举例如下：<br>1.我们公司采用Scrum模式开发，测试也跟这个走，在每个sprint开始前会前后召开grooming meeting， planning meeting， Grooming meeting上把这个sprint可能做的tasks从product backlog里捞出来， 然后按照优先级排序， planning meeting上估时，做commitments，并确认每个story的后端，前端，测试。<br>2.planning后sprint正式开始时，需求，design，UI应该都ready了，测试就可以设计用例， 通过review后发给所有组成员review。  story ready for test时，开发把代码放到测试环境，测试开始测试，发现问题jira报bug，linked到story，测试全部完成后标记 UAT GL， 等公司release process开始。<br>3.Release process开始，不同小组把各自代码放到统一测试环境，继续测试一次，这轮关注别组不会影响自己。<br>4.然后还有一轮甚至两轮 pre release，主要验证代码，环境，变量等问题。<br>5.最后release， 观察下，有问题回退版本，没问题继续走下个sprint</font></p><p><br><br>请描述下bug的几个要素？<br></p><p><font color="red">ID， Summary， reproduce steps， Priority， Assign to， Sprint info， fix version（due data）等等。<br>这道题我好想回答一句，jira里都有，你自己不会看呀：）</font></p><p><br><br>白盒和黑盒的区别，你是怎么运用的？<br></p><p><font color="red">简单来说一个关注内部实现逻辑，一个只从用户角度出发，不关注具体实现。具体定义及区别请参考我以往文章。<br>一般中高级测试都会偏灰盒一些，既关注内部实现逻辑又关注用户jounery，设计case的时候两边参考。<br>内部实现逻辑可以看代码，也可以请开发讲给你听，知道了怎么实现，能在设计用例时构造不同数据cover逻辑覆盖。同时也清楚了regression 的scope</font></p><p><br><br>你是如何做测试分析？<br></p><p><font color="red">这题是考察测试思维，一个应用/功能如何测试的问题，我的原则是确定需求，先定性后定量。<br>具体来说，定性， 哪些是显性需求？那些是隐性需求？功能在scope吗？性能？可靠性？安全性？兼容mobile平台吗？<br>定量就是， 功能要测， 那么有哪些功能，每个功能点是什么， 入口是什么，出口是什么，precondition是什么，数据哪里构造等等。<br>重复上述操作直到分析完成</font></p><p><br><br>如何设计测试用例？什么样子的测试用例是好用例？<br></p><p><font color="red">个人觉得上题回答好了，这题不会问了。 设计用例原则上好的用例各有千秋（不外乎边界值，等价类，流程图，正交法，判定表等）， 但坏的实践要避免，具体如下：<br>1.一个测试用例验证多个功能点（A,B,C三个功能一个用例，那么用例失败了，到底是A引起的？还是B引起的?增加后续开发定位问题的难度，浪费时间）<br>2.期望结果不明确（例如： make sure every thing works fine. what the f×××？！）<br>3.不可执行（比如一个配置项组合， 手工要执行的case写了2000个， 怎么执行完？）<br>4.precondition，steps描述不清楚，上手困难（你负责的story可能要由其它测试人员交叉执行）。<br>5.不必要的外部依赖（用例应直指功能核心，无关的入口/步骤/依赖 不必要一股脑放进来）</font></p><p><br><br>功能测试在 beta 版本对外的上线标准是什么？<br></p><p><font color="red">貌似业界对beta的定义不太统一，有人说这个是A/B测试的一种， 但一般认为专业测试人员完成后，有部分用户参与的一轮测试即beta测试。一般测试环境为用户实际应用环境，目标在于要求用户使用发现不合理，不符合实际情况的问题，然后改进。<br>功能上线标准每个公司不一样，大致如下：<br>1.所有功能点(需求)都被用例覆盖到了<br>2.所有用例执行过至少一遍<br>3.所有发现的bug被修复并验证，做过regression了。<br>4.不能修复的记录了/关闭了/known issue了。<br>5.bug曲线区域平稳了</font></p><p><br><br></p><p><font color="red">本人认为此类问题属于淘汰题，一个问题回答不上来或者深度不够，直接闲聊然后结束面试。</font></p><p><br><br># 3 测试管理题<br><br>这类题目就是考验你作为测试leader或者测试负责人的管理能力了。<br><br>如果项目周期很短，测试人力匮乏，你是怎么协调的？<br></p><p><font color="red">范围不变，赶工/增加人手，快速跟进/并行开始任务。 范围能变，砍低优先级用例，缩小测试范围。</font></p><p><br><br>描述下你团队的测试分工<br></p><p><font color="red">实话实说， 比如：<br>干活是不可能干活的，这辈子都不可能干活的， 做管理又不会做，就是颜值这种东西，才能维持得了团队这样子。</font></p><p><br><br>对于团队成员，你是如何打kpi的？<br></p><p><font color="red">没钱没颜你速去，童颜巨 你快来这样子。<br>我一般看三点：<br>1.出活<br>2.持续出活<br>3.持续精彩的出活</font></p><p><br><br># 4 移动测试相关<br><br>如今是移动互联网的天下，谁家没有个应用，所以这一块基本都会问到，同时也会看你的简历，如果你没有做过，基本也不会问的太深，如果你是专门做这一块的，那么要好好准备了。<br><br><strong> 概念题 </strong><br><br>描述下web测试和移动应用测试的相同点和区别？<br></p><p><font color="red">公众号以前分享过，不赘述，把握以下几点：<br>0.任何类型测试先定性，再定量， 范围， 分类一定，大差不差。<br>1.web通常不要安装，移动应用通常要安装。<br>2.移动设备存在特殊性，不同设备的屏幕/分辨率，系统，定制UI都不相同。<br>3.移动应用不应该影响移动设备现有功能，如电话/短信等。<br>4.移动端要重点关注，发热（电量消耗）， crash， 流量(4G/WIFI/2G)等</font></p><p><br><br>你是如何做应用的兼容性测试的？<br></p><p><font color="red">一般兼容性主要关注：<br>1.硬件的适配：不同手机厂商、硬件性能，不同屏幕大小的适配<br>2.OS版本的兼容。 iOS，Android， 手机，pad， 版本号啊，MUI定制啊等<br>3.不同分辨率屏幕的适配<br>解决办法（云测，此处欠我广告费），除公司自备主流设备外，需参考：<br>1.各大厂商发布的季度/年度手机出货量，尽量覆盖出货量大的，热门的机型<br>2.应用做tracking，记录自己用户常用机型<br>3.购买各种云测服务，解决机型适配问题</font></p><p><br><br>请讲出客户端下 3 个常用的性能指标的名称与具体含义？<br></p><p><font color="red">基本的：<br>1.CPU利用率<br>2.内存使用率<br>3.平均用户响应时间<br>独有的：<br>1.电量<br>2.流量<br>3.首次打开速度<br>4.竞品相应项目质量比较</font></p><p><br><br>iOS应用和Android应用测试有什么侧重点？<br></p><p><font color="red">主要是iOS系统和Android系统的本质造成的：<br>1.Android运行基于虚拟机，iOS则是沙盒机制<br>2.iOS是伪后台，任何第三方程序都不能在后台运行；而Android是真后台，安卓中任何程序都能在后台运行，直到内存不够才关闭<br>3.IOS中用于UI指令权限最高，安卓中数据处理指令权限最高。<br>测试实际应用上来，个人觉得没有本质区别，要注意以下问题：<br>1.安全性。 因为Android2的本质，任何程序都就可以轻松访问其他程序文件，要关注下有没有偷偷访问不需要功能/偷流量/常时间运行占用内存消耗电量等问题。<br>2.Android开源，定制版本过多（比如小米系列MIUI）， 要关注定制引起的问题。</font></p><p><br><br>请讲诉移动应用的灰度是怎么做的？<br></p><p><font color="red">灰度发布作为A/B Test的一种，一般指发布新功能到部分用户，收集反馈/改进，进而发布到全步用户的一种策略。<br>个人经历过以下方面：<br>1.新服务发布到全部服务器，但通过配置项把不同特征用户的请求打到不同的后端服务上去。比如ip是中国的用户访点击某个按钮，调用的是后端。。。/vi这个API， 而国外ip调用。。/V2<br>2.新功能的后端服务只发布到部分服务器，只有访问到这个服务器的用户才能用新功能。<br>3.同一个用户访问的平台不同，请求的服务就不同，比如app的访问V1， web的访问V2，可以通过发布app版本来实现。<br>另外这个实现还有很多专业的AB测试平台可以实现， 例如（云测，此处欠我广告费）。<br>如果涉及到写DB操作， 一般都双写。即访问新服务时，写到新服务的DB数据也要写到老服务的DB。甚至全部切换至新服务后再并行运行一段时间，才彻底切换到新服务，停写老服务。</font></p><p><br><br><strong> 实践题 </strong><br><br>应用的闪退通常是什么原因造成的？如果应用闪退，Android 和 iOS 上是分别怎么抓取日志的？<br></p><p><font color="red">一般闪退原因如下：<br>1.内存超载<br>2.后端服务或动态链接库未找到<br>3.应用初始化时无法正确读取到用户数据。<br>4.系统兼容问题。<br>日志抓取的话，iOS：<br>1.通过iTunes Connect（Manage Your Applications - View Details - Crash Reports）获取用户的crash日志<br>2.通过Xcode从你的设备上获得崩溃日志<br>3.自己在程序中添加崩溃捕捉代码，如果应用集成第三方SDK，如百度统计<br>Android：<br>1.通过集成第三方SDK，如百度统计、友盟统计等<br>2、发版时使用加固工具，他们也会收集错误日志，如360加固<br>3、在程序中添加程序异常崩溃的捕捉代码，保存到本地文件中</font></p><p><br><br>请简述移动应用在升级安装时候应该考虑的场景？<br></p><p><font color="red">实际上跟CS架构的升级没什么两样：<br>1.APP有新版本时，打开APP是否有更新提示。<br>2.当版本为非强制升级版时，用户可以取消更新，老版本能正常使用。用户在下次启动app时，仍能出现更新提示。<br>3.当版本为强制升级版时，当给出强制更新后用户没有做更新时，退出APP。下次启动app时，仍出现强制升级提示。<br>4.不删除APP直接更新，检查是否能正常更新，更新后能否正常工作。<br>5.删除老的APP，重新下载APP，能不能正常工作。<br>6.不删除APP直接更新，检查更新后的APP和新安装的APP提供的功能一样。<br>7.检查在线跨版本升级能否成功，版本过老是否提示用户重装。<br>8.更新成功后，用户数据有没有丢失，各个配置项是否还原。</font></p><p><br><br>给你一个应用，请简述你会从哪些方面去测试？<br></p><p><font color="red">一般答分类， 分类如下： 安装/卸载测试， UI， 功能， 性能， 安全， 兼容， 易用， 可移植性。切忌东答一下，西答一下。</font></p><p><br><br>请描述下微信朋友圈发小视频的用例设计？<br></p><p><font color="red">先假设一个需求，征得面试官同意，在这个既定需求下说你的用例，还是那个思想，定性，定量分类， 不展开了，测试用例设计算基本功吧，考察的无非是功能的全面性，边界/异常条件下的处理， 性能/安全。 主要是有测试思维/结构化思维，设计的用例要系统，不能想起那个说那个。</font></p><p><br><br>如果让你来测试扫码支付，你会考虑哪些场景？<br></p><p><font color="red">同上，不赘述</font></p><p><br><br>如何测试一个应用的登录场景？<br></p><p><font color="red">同上，不赘述， 吐槽下，这题改成如何测试百度的登录会更好，BAT齐活了 ：） 实际上这3道题有一道就好了。</font></p><p><br><br><strong><p><font color="red">对中高级测试而言，实践题也是淘汰题，一项卡壳没有后续， 但如果在细节上有疏忽，可以网开一面，进入下个环节</font></p><p></p></strong><br><br># 5 服务端测试相关<br><br>什么都离不开服务端，所以这是你逃不开的，一般来说服务端会问接口测试，性能测试，更深一点，埋点监控止血也会有。<br><br>请问你们公司是如何做接口测试的？<br></p><p><font color="red">累死我了， 题要做吐了。 接口测试实际跟一般测试不同就是测试用例的设计部分。<br>1.接口规范拿到。<br>2.设计接口测试功能用例（主要从用户角度出发看接口能否实现业务需求，用例设计就是黑盒用例那一套）。<br>3.各种入参验证（正常情况，异常情况包括输入参数个数不对，类型不对，可选/必选， 还有考虑参数有互斥或关联的情况）。<br>4.接口返回值各种验证（符合接口文档需求）<br>5.了解接口实现逻辑，实现逻辑覆盖（语句/条件/分支/判定/。。。。。）<br>6.接口能并发执行吗?<br>6.采用工具或者自写代码来验证，HTTP接口一般SoapUI， Jmeter， Fiddler， Postman等都能验证，自己写更好。web service接口一般要写代码来调用。根据测试用例自动化。<br>7.发现问题跟功能测试一样，该报bug报bug，该跟踪状态跟踪状态 </font></p><p><br><br>接口测试质量评估标准是什么？<br></p><p><font color="red">接口测试说的接口可以是模块接口，也可以是集成接口，那么质量评估标准也就转换为单元测试里的接口测试标准，和集成测试里的集成测试标准。<br>实际上这题如果我来回答的话会关注：<br>1.接口功能是否正确，接口功能是否实现了业务需求。<br>2.接口参数正确性包括实参形参的个数/属性，是否匹配。<br>3.接口并发/串行执行时接口返回值的正确性。<br>4.有没有性能问题（并发执行），有没有安全问题（用户能否直接访问该接口，需不需要验证）<br><br>面试答上面的应该够了， 其实这里面涉及到单元测试和集成测试评估点，我公众号以前分享后，在测试基础知识里， 总结的更全面，大家可移步查看。</font></p><p>请问你们公司是如何做性能测试的？请讲诉性能测试的相关指标？</p><p><font color="red">老规矩，先确定需求，再定性，定量。<br>例如：<br>1.这次测试目的是什么，是压力测试/负载测试/疲劳强度测试/BenchMark测试？<br>2.测试的硬件环境是什么？软件是什么？<br>3.测试工具用什么？<br>4.有哪些测试指标？<br>5.测试分析调优/测试报告要吗？<br>具体来说：<br>1.拿到测试需求，确定测试软硬件环境/测试指标， 使用测试工具(Loadrunner, jmeter)录制或者编写测试代码，逐步加压，直到测试目的达成。<br>2.分析测试结果，编写测试报告，突出性能指标包括成功，失败情况，并加以分析。<br>3.调优（一般都是开发的事）<br>相关性能指标：<br>服务器系统资源方面 CPU占用率，内存占用率 磁盘的读写指标<br>网络的占用情况 基础吞吐率<br>事务处理速度 如平均登录时间，操作平均响应时间等。</font></p><p><br><br>压力测试和负载测试的区别<br></p><p><font color="red">一个（压力测试）把最后一根稻草仍你身上，一个（负载测试）就剩最后一根稻草没仍，或者仍给你指定数目稻草。</font></p><p><br><br>服务器中一般要监控哪些数据，如何监控的，怎么从监控数据中发现问题？<br></p><p><font color="red">CPU， 内存， 网络， I/O， 数据库。等等。 一般用工具监控，另外Windows上有性能监视器。<br>发现问题，一般要关注阈值，比如CPU利用率超过85%，说明server压力太大了，数据量一大DB某条SQL写入速度变慢了等等等等</font></p><p><br><br>假设系统A调用系统B，我把B的接口都mock了，进行性能测试，这样有什么好处和坏处？<br></p><p><font color="red">好处是去掉的依赖，可以在B没有好之前测试A，并且B的任何改动/错误/失效不会影响我测试A<br>坏处是真实性能要比测出来的性能差， 性能指标不准确。 因为Mock的服务再真也不能代替真实服务</font></p><p><br><br>有一天早上打车高峰，滴滴服务端挂了大概30分钟，工程师抢修之后，马上上线，之后又挂了，请问有哪些原因会造成这个情况？<br></p><p><font color="red">还是考测试思维， 一定记得先确认需求，再定性，定量。 一般都要反问， 服务器是哪个服务器？后端应用服务器？数据服务器？缓存系统服务器？中间件服务器？文件系统服务器？<br>然后面试官说个，不说就自己假定一个， 然后第一次挂第二次挂分开说，先问有没有错误码，日志有吗，有就看日志，没有就猜 是应用服务器挂了啊，是不是高峰期顶不住这么大并发访问啊？是数据库服务器啊，是不是频繁读写受不了啊，读写有分开吗？同步还是异步啊， 把喇叭里。<br>第二次挂，可能更多了，是不是代码弄错了，改坏了，或者把喇叭里。<br>总之套路就是性能测试中可能预见的问题及原因，这个你们google下吧，自己分类总结下。</font></p><p><br><br><strong>性能这部分题，个人认为除非你面试性能测试工程师，不然都是可选题，答对80%过关肯定没问题，60%也行。关键有个概念，知道性能测试怎么回事，有问题该往哪个方向想就行了。 </strong><br><br># 6 自动化相关<br><br>自动化永远是避不开的，反正你入职的岗位要不要用自动化，你必须得会一点，加分项。这一块包括，自动化一些理念和自动化的工具使用。<br><br>理念和概念：<br><br>如何看待自动化和手动测试？怎样的一个比例才是健康的？<br></p><p><font color="red">见仁见智，一切能提高软件质量的方法都应该尝试。<br>兵无常形，符合自己项目实际情况是最好的。当然你要面试自动化测试，肯定是一切稳定了的功能最好全部自动化掉。 :)</font></p><p><br><br>你们公司的自动化投入产出比怎样？效益怎样？<br></p><p><font color="red">实话实说，UI自动化测试发现新bug的效益很低，主要用在回归测试上，减少测试工作量。接口测试可就不一样了，可以小步快跑，也可以集团作战。</font></p><p><br><br>自动化测试用例的覆盖率多少？<br></p><p><font color="red">有个50%了不得了吧， 一般核心业务里的最高优先级用例100%覆盖，这些用例也是用来跑冒烟的。 另外的看项目资源了。</font></p><p><br><br>完整运行一次自动化用例需要多久时间？<br></p><p><font color="red">Google说它们分钟级或者秒级别， 为毛我们都是小时级别 ：（</font></p><p><br><br>什么是分层自动化？<br></p><p><font color="red">金字塔结构， 最底层UnitTest，往上接口API/集成起来的service， 最上面UI自动化</font></p><p><br><br>你的测试数据是怎么准备的？<br></p><p><font color="red">当然是提前准备的了：）<br>写在脚本里/外部文件（excel， XML）/数据库， 逼格逐级提升</font></p><p><br><br>测试脚本的维护成本是怎么样的？<br></p><p><font color="red">两个原则：<br>1.不坏就不要修<br>2.终身追责，谁污染谁治理</font></p><p><br><br><br><strong> 工具使用 </strong><br><br>WebDriver 相关<br><br>请问你的定位策略是什么？<br></p><p><font color="red">啊啊啊，已经两个小时了，要抓狂了。<br>ID， Clas， CSS， XPath， jquery脚本， 总之能不麻烦开发就不麻烦开发。</font></p><p><br><br>请问如何实现用例失败或者异常时候需要截图？<br></p><p><font color="red">框架自带， python+webdriver里是get_screenshot_as_file， 一般写一个装饰器，放在要执行的类上，try， catch下。</font></p><p><br><br>请问如何分布式执行webdriver用例？<br></p><p><font color="red">两种策略：<br>1.利用Jenkins等，部署部分代码到多个机器上执行<br>2.RemoteWebDriver</font></p><p><br><br>如何在脚本中执行 JavaScript 代码？<br></p><p><font color="red">driver.execute_scripts(‘脚本’) </font></p><p><br><br><strong> 移动应用相关 </strong><br><br>Appium 的定位策略有哪些？<br></p><p><font color="red">使用Appium-Python-Client情况下， 除了以下常规八种定位方式外：<br>driver.find_element_by_id() –元素的 resrouce-id 属性<br>driver.find_element_by_AccessibilityId() – content-desc属性，替代以前的name。<br>driver.find_element_by_xpath() –比css定位慢<br>driver.find_element_by_class_name() –元素的 class 属性<br>driver.find_element_by_css_selector()<br>driver.find_element_by_link_text() –链接元素的全部显示文字<br>driver.find_element_by_tag_name() –元素的标签名<br>driver.find_element_by_partial_link_text() –链接元素的部分显示文字</font></p><p><br></p><p><font color="red">iOS和Android上还有独特的定位方法：<br>iOS：<br>IosUIAutomation –iOS9.3或以下的定位方法<br>driver.find_element_by_ios_uiautomation(‘.elements()[0]’)<br>Android：<br>AndroidUIAutomator， 仅支持 Android 4.2或以上，可支持元素的单个属性和多个属性定位。<br>driver.find_element_by_android_uiautomator(‘new UiSelector().text(“Animation”)’)<br>关于移动端元素的定位的定位，我公众号testertalk也发过系列文章，详细内容请移步。</font></p><p><br><br>请简述Appium的原理<br></p><p><font color="red">真想跟面试官说，您能帮忙打开官网吗？Appium对iOS和Anroid的实现原理不尽相同，并且对同一个平台不同操作系统版本的实现原理也不相同。<br><img src="/2018/04/10/面试相关/算法/想进BAT？这些面试题助你一臂之力/Appium_philosophy1.PNG" alt=""><br>我倾向大家往简单了说：<br>1.Appium是C/S架构的，更像是一个proxy，连接其被测移动平台和测试脚本。<br>2.appium是基于 webdriver 协议添加对移动设备自化api扩展而成的。<br>网上有个很清晰的图，截图如下：<br><img src="/2018/04/10/面试相关/算法/想进BAT？这些面试题助你一臂之力/Appium_philosophy2.PNG" alt=""><br>实际上我个人理解，这个题就是想了解，当你使用一个工具时，你是否关心过它的内部实现，也可以过渡到当你测试一个应用时，你是否关注它的实现。</font></p><p><br><br>iOS 和 Android 的 UI 自动化的原理是什么？<br></p><p><font color="red">上面已经答了，如下：<br>iOS 9.3 and above: Apple’s XCUITest<br>iOS 9.3 and lower: Apple’s UIAutomation<br>Android 4.2+: Google’s UiAutomator/UiAutomator2<br>Android 2.3+: Google’s Instrumentation. (Instrumentation support is provided by bundling a separate project, Selendroid)</font></p><p><br><br>当定位策略都失败的时候，你该怎么做？<br></p><p><font color="red">80%是你元素定位的不对，那么多定位方法，一个不行换另外一个，直接不能定位，先定位父元素，再循环找子元素。一般来说XPATH都能定位到，无非是可阅读性不强。真的全部失效，请求开发帮你改个元素属性好了。<br>这题其实还是”测试sense”问题，扩大点变成了怎么解决工作中困难。反正别认怂， 最好甭废话，直接开干。</font></p><p><br><br>请问Monkey测试的优缺点？<br></p><p><font color="red">没接触过，此题不会</font></p><p><br>如果使用monkey发现了一个毕现闪退，请问怎么使用monkey重现它？<br></p><p><font color="red">同上</font></p><p><br><br>Jmeter<br><br>你用jmeter做什么测试？<br></p><p><font color="red">接口，性能。</font></p><p><br><br>如果有一个登录接口需要服务端返回参数，再带着这个参数去请求才能完成登录，用jmeter 怎么做？<br></p><p><font color="red">可以利用Regular  Expression Extractor传参。 具体请参考我公众号testertalk Jmeter 系列文章。</font></p><p><br><br>———-     最后，来点硬题，嚯嚯嚯！    ———-<br><br># 7 硬 题<br><br>所谓硬题就是答案一般都是固定或者标准的，答案也不会模棱两可，包括：算法，编程，sql，linux<br><br>算法：<br><br>请写出冒泡排序<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def maopao（l）：</div><div class="line">def maopao(l):</div><div class="line">    if not isinstance(l, list):</div><div class="line">        raise TypeError("Need a list as parameter")</div><div class="line">    for i in range(len(l)):</div><div class="line">        for j in range(len(l)-1-i):</div><div class="line">            if l[j]&gt;l[j+1]:</div><div class="line">                l[j], l[j+1] = l[j+1], l[j]</div><div class="line">    return l</div></pre></td></tr></table></figure><br><br>1~9999数列中数字3出现的次数。用递推方法解出。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">#本来以为很简单，写了一下，2位数能算出来结果，3位数会报递归次数太多， 觉得蹊跷， 仔细一查，尼玛这题大有来历，我跪的心服口服。经过查找资料，解答如下：</div><div class="line">1位数： 0～9</div><div class="line">个位数为3： 3， 共1次。</div><div class="line">故0~9之间，3的个数为1</div><div class="line"></div><div class="line">2位数： 10～99</div><div class="line">个位数是3: 13, 23, 33 ...93, 共9个。</div><div class="line">十位数是3： 30， 31， ....39.   共10个。</div><div class="line">故0~99之间，3的个数为1+9+10=20个</div><div class="line"></div><div class="line">3位数： 100～999</div><div class="line">个位数是3： 103， 113， ....193  共10个。</div><div class="line"> 203， 213， ....293  共10个。</div><div class="line"> 。</div><div class="line"> 。</div><div class="line"> 。</div><div class="line"> 903， 913， ....993  共10个。</div><div class="line"> 一共9×10=90次。 </div><div class="line">十位数是3： 130， 132  ....139  共10个。</div><div class="line"> 230， 232  ....239  共10个。</div><div class="line"> 。</div><div class="line"> 。</div><div class="line"> 。</div><div class="line"> 930， 931， ....939  共10个。</div><div class="line"> 一共9×10=90次。</div><div class="line">百位数是3： 300， 301， ....399  共100个。</div><div class="line">故0~999之间，3的个数为20+90+90+100=300次</div><div class="line">也可以这样考虑：</div><div class="line">0~999之间：十位个 位共有10个0~99（解释0～99，100～199，。。。900～999），故有10*20=200次，而百位为1的有100次，共200+100=300次</div><div class="line">300=10*20+100</div><div class="line">4位数： 0～9999</div><div class="line">个位数是3： 1003，1013，1023， 。。。1093 共10个</div><div class="line"> 1103，1113，1123， 。。。1193 共10个  </div><div class="line"> 1203..... 共10个 </div><div class="line"> 1903....                共10个 </div><div class="line"> 共9个10，我们记为A</div><div class="line"> 还有2003～2903， 3003～3903.。。9003～9903 还有9个一样的A。</div><div class="line"> 所有一共有10个（A）， 是10×9×10=900</div><div class="line">十位数是3： 1030，1031，。。。。。。1039， 共10个。</div><div class="line"> 1131～1139， </div><div class="line"> 1231～1239.</div><div class="line"> 。。。</div><div class="line"> 1931～1939， 共有10×10个=100个。我们记为B</div><div class="line"> 还有千位数是2开头的，到9开头的，加起来共有9个（B） 9×10*10=900个。</div><div class="line">百位数是3： 1300， 1301，。。。。1399 共100个。</div><div class="line"> 2300</div><div class="line"> .。</div><div class="line"> 9300 </div><div class="line"> 共10×100=1000个。</div><div class="line">千位数是3： 3000，3001，3999 共 1000次。</div><div class="line"></div><div class="line">故0~9999之间，3的个数为300+900*900*900+1000=4000</div><div class="line">也可以这样考虑：</div><div class="line">0~9999之间：百位十位 个位共有10个0~999（0～999， 1000～1999， 。。9000～9999），故有10*300=3000次，而千位为1的有1000次，共3000+1000=4000次</div><div class="line">4000=10*300+1000</div><div class="line">规律：</div><div class="line">0~9：1</div><div class="line">0~99：20=10*1+10</div><div class="line">0~999：300=10*20+100</div><div class="line">0~9999：4000=10*300+1000</div><div class="line">0~99999：50000=10*4000+10000</div><div class="line">0~999999：600000=10*50000+100000</div><div class="line">f（1）=1</div><div class="line">f(2)=10*f(1)+10 **1</div><div class="line">f(3)=10*f(2)+10 **2</div><div class="line">f(4)=10*f(3)+10 **3</div><div class="line">...</div><div class="line">f(n)=10*f(n-1) + 10*(n-1)</div><div class="line"></div><div class="line">代码如下：</div><div class="line"></div><div class="line">def count_n_times(digit_number): #传入的是位数</div><div class="line">    if digit_number==1:</div><div class="line">        return 1</div><div class="line">    if digit_number&lt;=0:</div><div class="line">        return 0</div><div class="line">    return 10*count_n_times(digit_number-1) + 10**(digit_number-1)</div><div class="line"></div><div class="line">def count_digit_number(number): #给定是一个数</div><div class="line">    return len(str(number))</div><div class="line"></div><div class="line">print(count_n_times(count_digit_number(999)))</div><div class="line"></div><div class="line">我们再来假设下，如果给你的不是9999而是2345呢？即对于任意给定的数n，怎样能快速得到0~n之间3的个数呢?(这就是google的原题了（原题是算1），这题太硬了，我啃了几个小时了，不啃了..)</div></pre></td></tr></table></figure><br><br><br>从一个数组中找出前4个最大的数，用最优解。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#这个就是排序问题了吧，我想法先排好序，在取前4个，那么多排序，冒泡啊，选择啊，快排啊。。</span></div><div class="line">这里面快排最快，用大O算法O (n * log n )。</div><div class="line"></div><div class="line">思想：</div><div class="line">少于<span class="number">2</span>个元素的数组不需要排序</div><div class="line">找一个元素作为基数</div><div class="line">小于基数的放一个数组</div><div class="line">大于基数的放一个数组</div><div class="line">针对小于基数的数组做快速排序，暂且叫low</div><div class="line">针对大于基数的数组做快速排序, 暂且叫high</div><div class="line">最终排序后的 low + 【基数】+ high，就是排好序的数组</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(l)</span>:</span></div><div class="line">    low = []</div><div class="line">    high = []</div><div class="line">    <span class="keyword">if</span> len(l)&lt;<span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        base = l[<span class="number">0</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(l)):</div><div class="line">            <span class="keyword">if</span> base &lt;l[i]:</div><div class="line">                high.append(l[i])</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                low.append(l[i])</div><div class="line">    <span class="keyword">return</span> quicksort(low) + [base] + quicksort(high)</div><div class="line"></div><div class="line">print(quicksort([<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>])[:<span class="number">4</span>])</div><div class="line">其实python里内置了很多优秀的方法来解决其他语言很繁琐的问题，比如本题目可以直接：</div><div class="line">print(sorted([<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>])[:<span class="number">4</span>])  （据说python里sorted实现也是快排，没有经过求证。）</div><div class="line">哈哈，这样，面试官会不会鄙视我 ：）</div><div class="line">我之前也分享过基本的算法，大家可以去我的公众号testertalk查看。</div></pre></td></tr></table></figure><br><br>写一段程序，删除字符串a中包含的字符串b，举例 输入a = “asdw”,b = “sd” 返回 字符串 “aw”，并且测试这个程序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_ele</span><span class="params">(a, b)</span>:</span></div><div class="line">    r = <span class="string">''</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> b]:</div><div class="line">        r +=i</div><div class="line">    <span class="keyword">return</span> r</div><div class="line">print(del_ele(<span class="string">"asdw"</span>, <span class="string">"sd"</span>))</div><div class="line">这个就比较简单了，测试用例就不写了。</div></pre></td></tr></table></figure><br><br>写一个方法，把字符串转为数字，比如 str=”1234”，变成 int 1234。并且测试这个程序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_format</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(a, str):</div><div class="line">        <span class="keyword">raise</span> TypeError(<span class="string">"You need a str"</span>)</div><div class="line">    <span class="keyword">return</span> int(a)</div><div class="line">print(convert_format(<span class="string">"1234"</span>))</div><div class="line">啃完了google的题，我觉得我肯定没有领会这两道题目的意图， 紧张中。。。。  测试用例就不写了。</div><div class="line"></div><div class="line">**个人总结下，硬题是比较好的一个筛选人的方式，但是也比较容易作弊，这个最多能看出来候选人有没有看算法的意识。 对于中高级测试来说，平时一定要刷点算法题，不然百分百被刷下**</div></pre></td></tr></table></figure><br><br><strong> 编程： </strong><br><br>什么是面向对象编程？<br></p><p><font color="red">把一切看成对象，三大特性 继承，封装，多态</font></p><p>讲下Java多线程的使用</p><p><font color="red">java多线程跟别的语言的多线程有区别吗？<br>多线程一般用来更好的利用CPU资源，解决诸如程序“在一部分上会阻塞”，“在另一部分上需要持续运行”的场合。多线程一般用来更好的利用CPU资源，解决诸如程序“在一部分上会阻塞”，“在另一部分上需要持续运行”的场合。<br>例如有个程序需要接受多个用户输入并向服务器发送数据，那么如果不用多线程，一旦程序在等待某个用户输入时，程序就会阻塞。这段时间其它用户也不能使用了</font></p><p>有三个线程T1，T2，T3，怎么确保它们按顺序执行？</p><p><font color="red">在主线程中，每一个线程start（）后立即join（）</font></p><p>Thread 类中的start() 和 run() 方法有什么区别？</p><p><font color="red">个人理解start（）会启动线程，然后调用run（），run（）方法一般要重写。<br>网上资料：<br>调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。<br>1.start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。<br>2.run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。<br>记住：多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发</font></p><p>请写一个线程安全的单例模型</p><p><font color="red">网上搜下吧，java不熟悉</font></p><p><strong> SQL： </strong></p><p>说下左连接和右连接<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">比如有两张表A和B。 A表B表都有ID列， </div><div class="line">select* <span class="keyword">from</span> A left join B where A.ID=B.ID. 会把A表所有记录显示，B表里没有和A表ID对应的，会显示NULL。</div><div class="line">左连接是把符合条件的所有的A表的内容列出来，B表里如果没有内容匹配就用NULL代替。 右连接是符合条件的 B表的内容全显示出来，A表里没有匹配就用NULL代替。</div></pre></td></tr></table></figure></p><p>介绍下什么是索引<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">索引是与表或视图关联的磁盘上结构，可以加快从表或视图中检索行的速度。索引包含由表或视图中的一列或多列生成的键。这些键存储在一个结构（B树）中，使 SQL Server 可以快速有效地查找与键值关联的行。 </div><div class="line">SQL里索引的语法：</div><div class="line"></div><div class="line">SQL CREATE INDEX 语法</div><div class="line">在表上创建一个简单的索引。允许使用重复的值：</div><div class="line">CREATE INDEX index_name</div><div class="line">ON table_name (column_name)</div><div class="line"></div><div class="line">注释：<span class="string">"column_name"</span> 规定需要索引的列。</div><div class="line">SQL CREATE UNIQUE INDEX 语法</div><div class="line">在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。</div><div class="line">CREATE UNIQUE INDEX index_name</div><div class="line">ON table_name (column_name)</div><div class="line">CREATE INDEX 实例</div><div class="line">本例会创建一个简单的索引，名为 <span class="string">"PersonIndex"</span>，在 Person 表的 LastName 列：</div><div class="line">CREATE INDEX PersonIndex</div><div class="line">ON Person (LastName) </div><div class="line"></div><div class="line">如果您希望以降序索引某个列中的值，您可以在列名称之后添加保留字 DESC：</div><div class="line">CREATE INDEX PersonIndex</div><div class="line">ON Person (LastName DESC) </div><div class="line"></div><div class="line">假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：</div><div class="line">CREATE INDEX PersonIndex</div><div class="line">ON Person (LastName, FirstName)</div><div class="line"></div><div class="line">更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</div><div class="line">索引不适用于需要频繁写入的表，适合只读多插入少的表。</div></pre></td></tr></table></figure></p><p>使用sql生产10万条数据</p><p><font color="red">平常没接触过这么大数据量，分批次吧，每次插入1w条，应该没什么压力</font></p><br>给你一张表，根据要求写sql，这个题目比较多，自己百度吧。<br><br><strong> Linux： </strong><br><br>你常用的命令是什么？<br><p><font color="red">ls, mkdir, cat, vi, ps touch</font></p><p>用什么查看log？</p><p><font color="red">watch, tail、cat、tac、head、echo</font></p><p>如何查找一个文件大小超过5M的文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">find . -type f -size +<span class="number">800</span>M</div><div class="line">常用的参数有: </div><div class="line">- type:类型。POSIX支持——b:块设备文档、d:目录、c:字符设备文档、P:管道文档、l:符号链接文档、f:普通文档 </div><div class="line">- name:按文件名查找。支持*模糊匹配 </div><div class="line">- size:文件大小。+表示大于，-表示小于。支持k,M,G单位</div></pre></td></tr></table></figure></p><p>如何查看进程？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ps命令。它能显示当前运行中进程的相关信息，包括进程的PID。Linux和UNIX都支持ps命令，显示所有运行中进程的相关信息。</div><div class="line">ps命令能提供一份当前进程的快照。如果想状态可以自动刷新，可以使用top命令。</div><div class="line">ps aux | less  <span class="comment">#显示所有运行中的进程</span></div></pre></td></tr></table></figure></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><ol><li>这68道题目，我花费了2个晚上总结整理，用的时间我都不好意思说。</li><li>从个人角度看，这些面试题很接地气，很多考题也跟实际工作密切相关，大大增加了筛掉水货的几率，我也曾用部分相似题来筛选别人。</li><li>对于初级测试来说，测试理论，测试基础都应该掌握，移动端测试，服务器端测试，自动化测试，性能测试，也应该逐渐接触起来，不会答没关系，但要大致了解，面试官喜欢有追求的人。</li><li>对于中高级测试来说，除了硬题，其它题目经过充分准备都不应该丢分，回答正确率要在85%以上，另外，回答的深度非常重要，决定了你是年龄资深还是技术资深。</li><li>对于硬题，虽然大部分的测试，甚至测试开发，工作中用到算法的几率也不高，但你如果都答对了，还是能让人眼前一亮的。<br>对于这部分试题，稍有难度的例如google面试题那个，你有个大致思路也行，对于非常基础的，二分啊，排序啊，还是建议多练练，起码应该做到手写正确。<br>现在有能力做好普通测试工作的人太多了，算法也跟学历，长相一样，用人单位不得不拿这些筛选掉很多合适的人，有时候你比别人更优秀的能力，也许就来自于你昨天刷了一道面试题。<br>怎么说呢，面试造火箭，进来拧螺丝，接受现实吧。</li><li>我本人其实是反对面试突击的，所以我公众号从没有发过面试题。 本文目的也不希望大家背答案就面试（面试从来也没有标准答案，背了估计也面不上 ：0），而是希望大家通过做这些面试题，发现自己的不足，从而有针对性的提升自己。</li><li>感谢大家的阅读，能读到这里的都是真粉丝， 欢迎大家提出更好的意见，谢谢。</li></ol>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python+webdriver一劳永逸解决弹出框识别问题</title>
      <link href="/2018/04/04/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Python+webdriver%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E8%A7%A3%E5%86%B3%E5%BC%B9%E5%87%BA%E6%A1%86%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98/"/>
      <url>/2018/04/04/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Python+webdriver%E4%B8%80%E5%8A%B3%E6%B0%B8%E9%80%B8%E8%A7%A3%E5%86%B3%E5%BC%B9%E5%87%BA%E6%A1%86%E8%AF%86%E5%88%AB%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>自动化测试过程中的弹出框识别，应该是老生常谈的问题了，近来不断有新的读者碰见此问题并为此烦恼，干脆写一篇文章终结此类问题。<br><a id="more"></a><br>弹出框有几种类型，一般为alart， iframe， windows（包括可直接识别的div，还有不能能直接识别的），下面我们以百度首页为例，看看这几种弹出框如何识别。</p><p>假设现在要在百度首页点击登录按钮，<br><img src="/2018/04/04/自动化测试系列/Python+webdriver一劳永逸解决弹出框识别问题/baidu_index.JPG" alt=""><br>等如下窗口弹出来后， 点击qq图标转向qq登录<br><img src="/2018/04/04/自动化测试系列/Python+webdriver一劳永逸解决弹出框识别问题/popup_login.JPG" alt=""><br>然后，页面会跳转到第3方窗口，在里面选择账户密码登录<br><img src="/2018/04/04/自动化测试系列/Python+webdriver一劳永逸解决弹出框识别问题/third-party-login.JPG" alt=""><br>然后在如下弹出框里输入用户名和密码<br><img src="/2018/04/04/自动化测试系列/Python+webdriver一劳永逸解决弹出框识别问题/third-party-login2.JPG" alt=""></p><p>我们直接代码看下如何实现，注意，以下下代码仅仅证明可行性，未作任何优化，工程代码应该利用设计模式（PageObject）/分离元素和操作/封装重用类/定义错误处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"></div><div class="line"><span class="comment">#打开首页，点击登录按钮</span></div><div class="line">d = webdriver.Chrome()</div><div class="line">d.get(<span class="string">"http://www.baidu.com"</span>)</div><div class="line">d.find_element_by_xpath(<span class="string">".//*[@id='u1']/a[@name='tj_login']"</span>).click()</div><div class="line"></div><div class="line"><span class="comment">#jquery操作页面元素，点击qq账户登录。</span></div><div class="line"><span class="comment">#1. 这是弹出框问题的终极解决办法，一律用jquey直接操作页面元素，然后通过脚本执行</span></div><div class="line">js_script =<span class="string">'''$("#pass_phoenix_btn .phoenix-btn-item")[0].click()'''</span></div><div class="line">time.sleep(<span class="number">2</span>)</div><div class="line">d.execute_script(js_script)</div><div class="line">time.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment">#切换到qq登录页面，并打印出当前页面以验证正确性。</span></div><div class="line"><span class="comment">#2. switch_to.window允许你跟弹出页面window交互。</span></div><div class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> d.window_handles:</div><div class="line">    d.switch_to.window(handle)</div><div class="line">time.sleep(<span class="number">3</span>)</div><div class="line">print(d.current_url)</div><div class="line"></div><div class="line"><span class="comment">#分析页面元素，看出最终的账户登录是个iframe，找到这个iframe的id，切入到这个iframe，继续执行操作。</span></div><div class="line"><span class="comment">#3. iframe也可以用switch_to.frame直接操作。</span></div><div class="line">element = d.find_element_by_xpath(<span class="string">".//*[@id='combine_page']/div[1]"</span>)</div><div class="line">d.switch_to.frame(element.find_element_by_id(<span class="string">'ptlogin_iframe'</span>))</div><div class="line">d.find_element_by_xpath(<span class="string">".//*[@id='switcher_plogin']"</span>).click()</div><div class="line"></div></pre></td></tr></table></figure></p><p>最后要注意， 等操作完弹出框后，应该用d.switch_to.default_content()这个方法切换回主页面继续。</p><p>欢迎关注TesterTalk，跟我共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git用法总结</title>
      <link href="/2018/04/02/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Git/Git%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/04/02/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/Git/Git%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Git常用的命令很多，不常用的话会忘记，特别是在windows上开发的同学，习惯了GUI格式（话说SourceTree真不错）， 偶尔被人问到如果解决conflict，答用工具时会被鄙视，<br>今天就来复习下Git的常用指令。<br><a id="more"></a></p><p>Git的学习，有两个很好的资源，一个是廖雪峰的官网，这个真是浅显易懂，另一个是codecademy， 想深入学习的同学请移步过去，此处仅用来快速复习。</p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h1><p>直接官网下载，安装好后开始菜单里找到”Git”-&gt;”Git Bash”, 有命令行窗口弹出，则成功。这里通常还会设置下git通用的用户名和邮箱，方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --<span class="keyword">global</span> user.name <span class="string">"此处填写你的用户名"</span></div><div class="line">$ git config --<span class="keyword">global</span> user.email <span class="string">"你的email"</span></div></pre></td></tr></table></figure></p><h1 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2.创建仓库"></a>2.创建仓库</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> clone 一个存在的仓库</div><div class="line">git clone ssh://user@domain.com/repo.git</div><div class="line"></div><div class="line"><span class="number">2.</span>创建一个本地仓库， switch到目标文件夹下，输入</div><div class="line">git init</div></pre></td></tr></table></figure><h1 id="3-本地更改"><a href="#3-本地更改" class="headerlink" title="3. 本地更改"></a>3. 本地更改</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1.</span> 添加所有当前的changes</div><div class="line">git add .</div><div class="line"></div><div class="line"><span class="number">2.</span>添加某一个文件</div><div class="line">git add &lt;file name&gt;</div><div class="line"></div><div class="line"><span class="number">3.</span> 添加某些文件到下次commit</div><div class="line">git add -p &lt;file name&gt;</div><div class="line"></div><div class="line"><span class="number">4.</span> 提交改动到本地分支</div><div class="line">git commit -m <span class="string">"comments"</span></div><div class="line"></div><div class="line"><span class="number">5.</span> 提交所有的本地changes到本地分支， 省去了git add .</div><div class="line">git commit -a</div><div class="line"></div><div class="line"><span class="number">6.</span>在changeID不变得情况下，覆盖上次修改的文件代码</div><div class="line">git commit --amend</div><div class="line"></div></pre></td></tr></table></figure><h1 id="4-提交历史查询"><a href="#4-提交历史查询" class="headerlink" title="4.提交历史查询"></a>4.提交历史查询</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1.</span>显示所有的提交记录</div><div class="line">git log</div><div class="line"></div><div class="line"><span class="number">2.</span>显示某一个文件的历史记录</div><div class="line">git log -p &lt;file&gt;</div><div class="line"></div><div class="line"><span class="number">3.</span> 让log好看点</div><div class="line">git log --pretty=oneline</div><div class="line"></div><div class="line"><span class="number">4.</span>谁在何时改变了什么内容</div><div class="line">git blame &lt;file&gt;</div><div class="line"></div><div class="line"><span class="number">5.</span>可以查看所有分支的所有操作记录(包括提交、回退、已删除的提交操作记录等)</div><div class="line">Git reflog </div><div class="line"></div><div class="line">　如果在回退以后又想再次回到之前的版本，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录</div><div class="line"></div></pre></td></tr></table></figure><h1 id="5-分支和Tag"><a href="#5-分支和Tag" class="headerlink" title="5.分支和Tag"></a>5.分支和Tag</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>列出所有存在的分支</div><div class="line">git branch</div><div class="line"></div><div class="line"><span class="number">2.</span>切换到某一个分支</div><div class="line">git checkout &lt;branch&gt;</div><div class="line"></div><div class="line"><span class="number">3.</span>创建+切换分支</div><div class="line">git checkout -b &lt;name&gt;</div><div class="line"></div><div class="line"><span class="number">3.</span>基于当前分支创建一个新的分支</div><div class="line">git branch &lt;new-branch&gt;</div><div class="line"></div><div class="line"><span class="number">4.</span>基于远程分支创建一个分支</div><div class="line">git branch --track &lt;new-branch&gt; &lt;remote&gt;</div><div class="line"></div><div class="line"><span class="number">5.</span>删除一个本地分支</div><div class="line">git branch -d &lt;branch&gt;</div><div class="line"></div><div class="line"><span class="number">6.</span>给当前的提交打上tag</div><div class="line">git tag &lt;tag-name&gt;</div></pre></td></tr></table></figure><h1 id="6-更新和提交"><a href="#6-更新和提交" class="headerlink" title="6.更新和提交"></a>6.更新和提交</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>查看远程仓库的信息（执行该命令后，会列出当前程序对应的所有远程版本仓库的信息，含仓库名和仓库地址）</div><div class="line">git remote -v</div><div class="line"></div><div class="line">git remote （只是会单纯的列出所有远程仓库的名字，不会展示远程仓库的地址）</div><div class="line"></div><div class="line"><span class="number">2.</span>显示某个远程库的信息</div><div class="line">git remote show &lt;remote&gt;</div><div class="line"></div><div class="line"><span class="number">3.</span>创建新的远程库， name, remote</div><div class="line">git remote add &lt;remote&gt; &lt;url&gt;</div><div class="line"></div><div class="line"><span class="number">4.</span>下载所有远程库的改动, 但是不merge到本地</div><div class="line">git fetch &lt;remote&gt;</div><div class="line"></div><div class="line"><span class="number">4.</span>下载所有远程库的改动, merge到本地</div><div class="line">git pull &lt;remote&gt; &lt;branch&gt;</div><div class="line"></div><div class="line"><span class="number">5.</span>push本地改动到remote</div><div class="line">git push &lt;remote&gt; &lt;branch&gt;</div><div class="line"></div><div class="line"><span class="number">6.</span>发布你的tags</div><div class="line">git push --tags</div></pre></td></tr></table></figure><h1 id="7-Merge和Rebase"><a href="#7-Merge和Rebase" class="headerlink" title="7.Merge和Rebase"></a>7.Merge和Rebase</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="number">1.</span>merge 合并branch分支到当前分支</div><div class="line">git merge &lt;branch&gt;</div><div class="line"></div><div class="line">举例（把master分支合并到当前分支）：</div><div class="line">git checkout feature</div><div class="line">git merge master</div><div class="line"></div><div class="line"><span class="number">2.</span>rebase 把branch合并到当前分支</div><div class="line">git rebase &lt;branch&gt;</div><div class="line"></div><div class="line">举例：</div><div class="line">git checkout feature</div><div class="line">git rebase master</div><div class="line">（它会把整个 feature 分支移动到 master 分支的后面，有效地把所有 master 分支上新的提交并入过来</div><div class="line">但是，rebase 为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。）</div><div class="line"></div><div class="line"><span class="number">3.</span>解决冲突后继续合并</div><div class="line">git rebase --<span class="keyword">continue</span></div><div class="line"></div><div class="line"><span class="number">4.</span>中止rebase，回到rebase前状态</div><div class="line">git rebase --abort</div><div class="line"></div></pre></td></tr></table></figure><h1 id="8-回退"><a href="#8-回退" class="headerlink" title="8. 回退"></a>8. 回退</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>丢弃所有本地更改 ,commit和index 都回回退到某个版本.(注意,这种方式是改变本地代码仓库源码)</div><div class="line">git reset --hard HEAD</div><div class="line"></div><div class="line"><span class="number">2.</span> 对某一个文件丢弃本地的更改</div><div class="line">git checkout HEAD &lt;file&gt;</div><div class="line"></div><div class="line"><span class="number">3.</span>revert一个commit （会留一个新的commit记录）</div><div class="line">git revert &lt;commit&gt;</div><div class="line"></div><div class="line"><span class="number">4.</span>reset 到commit， commit后的所有提交都被丢弃</div><div class="line">git reset --hard &lt;commit&gt;</div><div class="line"></div><div class="line"><span class="number">5.</span>reset到某个commit，同时保留所有本地的改动</div><div class="line">git reset --keep &lt;commit&gt;</div><div class="line"></div></pre></td></tr></table></figure><h1 id="9-常见问题及解决方案："><a href="#9-常见问题及解决方案：" class="headerlink" title="9 常见问题及解决方案："></a>9 常见问题及解决方案：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 你有一个远程主branch，它名字是master， A和B都从master上checkout了本地分支，并创建了远程分支。 A的本地分支和远程分支都叫A， B的都叫B。</div><div class="line">A先改动了代码并成功Push到远程A， 然后通过pull request成功merge到master， 这时候B也成功push代码到B，然后建立pull request想push到master会出错，怎么解决？</div><div class="line"></div><div class="line">（<span class="number">1</span>）. 先push本地分支的改动到远程B分支上。</div><div class="line">（<span class="number">2</span>）. checkout -b c master 从最新的远程主分支check out一个本地分支， 我们叫C</div><div class="line">（<span class="number">3</span>）. git pull 通过git pull 把远程master最新改动拉下来到C</div><div class="line">（<span class="number">4</span>）。 git checkout B, 切换到本地分支B， git merge C，把C的最新代码拉倒B，肯定有冲突，手工解决掉。</div><div class="line">（<span class="number">4</span>）。 B git push到远程B， 并通过建立pull request的方式push到远程master</div><div class="line"></div><div class="line"><span class="number">2.</span> 提交注释错误如何回退</div><div class="line">git commit --amend</div><div class="line"></div><div class="line"><span class="number">3.</span> 提交错误版本到本地仓库如何回退</div><div class="line">（<span class="number">1</span>）. git reflog 找回要回退的commit id。</div><div class="line">（<span class="number">2</span>）. 找到上次提交的记录id例如<span class="number">123</span>， 执行 git reset --hard <span class="number">123</span> 或者 git reset --hard HEAD^</div><div class="line"></div><div class="line"><span class="number">4.</span>自己的远程分支版本回退的方法</div><div class="line">git reflog</div><div class="line">git reset --hard <span class="number">123</span></div><div class="line">git push -f   (注意：本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支)</div><div class="line"></div><div class="line"><span class="number">5.</span>公共远程分支版本回退的问题</div><div class="line">举例：改完代码测试也没有问题,但是上线后发现你的修改导致之前运行正常的代码报错,必须回滚.</div><div class="line">git revert HEAD</div><div class="line">git push origin master</div><div class="line"></div><div class="line">注意：</div><div class="line">git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。</div><div class="line">git revert 命令的好处就是不会丢掉别人的提交。</div><div class="line"></div><div class="line">总结下：</div><div class="line">自己的分支回滚直接用reset</div><div class="line">公共分支回滚用revert</div><div class="line">错的太远了直接将代码全部删掉，用正确代码替代。</div></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python算法分享系列 -- 广度优先</title>
      <link href="/2018/02/22/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/"/>
      <url>/2018/02/22/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/</url>
      
        <content type="html"><![CDATA[<p>继续来学习，今天了解下搜索算法。<br><a id="more"></a></p><p>广度优先搜索（breadth-first search）是一种解决最短路径问题的算法，通常需要：</p><ol><li>使用图来建立问题模型。</li><li>使用广度优先搜索解决问题。<br>那么，什么是图呢？<br>图模拟一组连接，比如说，假设你与朋友玩牌，并要模拟谁欠谁钱，可以下面这样指出<br><img src="/2018/02/22/面试相关/算法/Python算法分享系列 -- 广度优先/tu1.PNG" alt=""><br>图由节点（node）和边（edge）组成。</li></ol><p>广度优先搜索可以帮助我们解决以下两类问题：<br><strong> 1.从节点A出发，能到达节点B吗？ </strong><br><strong> 2.从节点A出发，前往节点B的哪条路最短。 </strong></p><p>我们先来解决第一个问题， 假设有这样一个欠钱的关系图，<br><img src="/2018/02/22/面试相关/算法/Python算法分享系列 -- 广度优先/tu1.PNG" alt=""><br>过年了，债主纷纷要帐，都知道欠钱的是大爷，现在kevin这个大爷想， 钱我可以还，但还钱前，我想找美女陪我吃顿饭，这下，债主们（alex， bob）纷纷傻了，我俩都是大老爷们啊，怎么办？ 去请一个美女过来，还得花钱呐，干脆，我也找我的债主提要求去，于是alex和bob又对他们的债主提出来相同的问题。<br>Alex没有债主，于是他只好希望Bob能找到，Bob找到了Hult和steven， steven也没有债主，他就等Hult，Hult正好欠Buauty这个美女的钱，于是这样一层一层，终于找到了Beauity，Kevin大爷和Beauty吃端饭，把钱还了，皆大欢喜。</p><p>我们来代码实现它,首先把问题转化成图：</p><blockquote><p>图由多个节点组成。<br>每个节点都与邻近节点相连，如果表示类似于“kevin→Bob”这样的关系呢？好在你知道的一种结构让你能够表示这种关系，它就是散列表！<br>散列表让你能将键映射到值， 这种映射关系， python里的实现是字典。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#注意，每一个节点都必须有它对应的节点，如果没有，它对应的节点为空</span></div><div class="line">debt = &#123;&#125;</div><div class="line">debt[<span class="string">'kevin'</span>] = [<span class="string">'alex'</span>, <span class="string">'bob'</span>]</div><div class="line">debt[<span class="string">'bob'</span>] = [<span class="string">'hult'</span>, <span class="string">'steven'</span>]</div><div class="line">debt[<span class="string">'hult'</span>] = [<span class="string">'beauty'</span>]</div><div class="line">debt[<span class="string">'alex'</span>] = []</div><div class="line">debt[<span class="string">'steven'</span>] = []</div><div class="line">debt[<span class="string">'beauty'</span>] = []</div></pre></td></tr></table></figure><p>查找的方式是：<br>0.创建一个队列，队列里是待查找的元素，再创一个列表，列表里是已经检查过的元素。<br>1.把队列元素依次弹出，看它在不在列表，在表示已经查过了，不需要做任何操作，不在，把它加入列表，然后看看弹出的元素有没有符合条件的。。<br>2.如果有直接退出<br>3.如果没有，看弹出的元素，还有没有债主，有就把它的债主加入到这个队列里。、<br>4.重复第1到3步，直到找到美女或者队列为空。<br>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">()</span>:</span></div><div class="line">    debt = &#123;&#125;</div><div class="line">    debt[<span class="string">'kevin'</span>] = [<span class="string">'alex'</span>, <span class="string">'bob'</span>]</div><div class="line">    debt[<span class="string">'bob'</span>] = [<span class="string">'hult'</span>, <span class="string">'steven'</span>]</div><div class="line">    debt[<span class="string">'hult'</span>] = [<span class="string">'beauty'</span>]</div><div class="line">    debt[<span class="string">'alex'</span>] = []</div><div class="line">    debt[<span class="string">'steven'</span>] = []</div><div class="line">    debt[<span class="string">'beauty'</span>] = []</div><div class="line"></div><div class="line">    search_route = []</div><div class="line">    q = deque()</div><div class="line">    q.append(<span class="string">'kevin'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> q:</div><div class="line">        search = q.popleft()</div><div class="line">        <span class="keyword">if</span> search <span class="keyword">not</span> <span class="keyword">in</span> search_route:</div><div class="line"></div><div class="line">            search_route.append(search)</div><div class="line">            <span class="keyword">if</span> is_beauty(search):</div><div class="line">                print(search_route)</div><div class="line">                <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                q += debt[search]</div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_beauty</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">if</span> name == <span class="string">"beauty"</span>:</div><div class="line">        print(<span class="string">"Beauty found!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    BFS()</div></pre></td></tr></table></figure><p>第一个问题从A点到B点有没有解的问题，我们已经解决了，但我们的程序没有把最短路径拿出来，下面来看，如何找最短路径。</p><p>根据图的关系，假设我们已经找到了最终的元素Beauty，那么，就意味着我们找到了最短路径，为什么这么说呢，因为我们是从一层一层找下来的，从图来看，有3层，第一层是kevin，第二层是alex， bob， 第3层是steven， hult，第4层是beauty。 那么初始节点出发（第一层），我们首先遍历了第2层所有的子节点，<br>alex和bob，都没有我们要找的元素，然后我们走向第3层，hult，steven，也没有我们找的元素，但是第3层的hult指向了第4层的一个元素，也就是我们的目标。既然找到了目标，我们反过来查目标的上一个元素是谁，就可以一层一层回溯到起始节点。<br>下面来实现下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"></div><div class="line">father_child = &#123;&#125; <span class="comment">#记录每个元素和它对应的上一层元素。</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS</span><span class="params">()</span>:</span></div><div class="line"></div><div class="line">    debt = &#123;&#125;</div><div class="line">    debt[<span class="string">'kevin'</span>] = [<span class="string">'alex'</span>, <span class="string">'bob'</span>]</div><div class="line">    debt[<span class="string">'bob'</span>] = [<span class="string">'hult'</span>, <span class="string">'steven'</span>]</div><div class="line">    debt[<span class="string">'hult'</span>] = [<span class="string">'beauty'</span>]</div><div class="line">    debt[<span class="string">'alex'</span>] = []</div><div class="line">    debt[<span class="string">'steven'</span>] = []</div><div class="line">    debt[<span class="string">'beauty'</span>] = []</div><div class="line"></div><div class="line">    search_route = []</div><div class="line">    q = deque()</div><div class="line">    q.append(<span class="string">'kevin'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> q:</div><div class="line">        search = q.popleft()</div><div class="line">        <span class="keyword">if</span> search <span class="keyword">not</span> <span class="keyword">in</span> search_route:</div><div class="line">            search_route.append(search)</div><div class="line">            <span class="keyword">if</span> is_beauty(search):</div><div class="line">                <span class="keyword">return</span> search_path(search)[::<span class="number">-1</span>]</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                q += debt[search]</div><div class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> debt[search]:  <span class="comment">#生成元素和它上一层元素的对应关系</span></div><div class="line">                    father_child[item] = search</div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_beauty</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">if</span> name == <span class="string">"beauty"</span>:</div><div class="line">        print(<span class="string">"Beauty found!, search order are:"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_path</span><span class="params">(search)</span>:</span> <span class="comment">#回溯查找路径</span></div><div class="line">    return_order = [search]</div><div class="line">    <span class="keyword">while</span> search <span class="keyword">in</span> father_child.keys():</div><div class="line">        return_order.append(father_child[search])</div><div class="line">        search = father_child[search]</div><div class="line">    <span class="keyword">return</span> return_order</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    print(BFS())</div><div class="line"></div></pre></td></tr></table></figure></p><p>代码不是很好看，优化一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BFS</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, diagram)</span>:</span></div><div class="line">        self.diagram = diagram</div><div class="line">        self.searched = []</div><div class="line">        self.node_relation = &#123;&#125; <span class="comment">#记录每个元素和它对应的上一层元素。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, start_node)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(self.diagram, dict):</div><div class="line">            <span class="keyword">raise</span> SyntaxError(<span class="string">"diagrom must be dict"</span>)</div><div class="line"></div><div class="line">        q = deque() <span class="comment">#双向链表，可以用作栈也可以当作队列</span></div><div class="line">        q.append(start_node)</div><div class="line"></div><div class="line">        <span class="keyword">while</span> q:</div><div class="line">            node = q.popleft()</div><div class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.searched:</div><div class="line">                self.searched.append(node)</div><div class="line">                <span class="keyword">if</span> self.is_beauty(node):</div><div class="line">                    <span class="keyword">return</span> self.search_path(node)[::<span class="number">-1</span>]</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    q += self.diagram[node]</div><div class="line">                    <span class="keyword">for</span> item <span class="keyword">in</span> self.diagram[node]:  <span class="comment">#生成元素和它上一层元素的对应关系</span></div><div class="line">                        self.node_relation[item] = node</div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_beauty</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">"beauty"</span>:</div><div class="line">            print(<span class="string">"Beauty found!, search order are:"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_path</span><span class="params">(self, node)</span>:</span></div><div class="line">        return_order = [node]</div><div class="line">        <span class="keyword">while</span> node <span class="keyword">in</span> self.node_relation.keys():</div><div class="line">            return_order.append(self.node_relation[node])</div><div class="line">            node = self.node_relation[node]</div><div class="line">        <span class="keyword">return</span> return_order</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    debt = &#123;&#125;</div><div class="line">    debt[<span class="string">'kevin'</span>] = [<span class="string">'alex'</span>, <span class="string">'bob'</span>]</div><div class="line">    debt[<span class="string">'bob'</span>] = [<span class="string">'hult'</span>, <span class="string">'steven'</span>]</div><div class="line">    debt[<span class="string">'hult'</span>] = [<span class="string">'beauty'</span>]</div><div class="line">    debt[<span class="string">'alex'</span>] = []</div><div class="line">    debt[<span class="string">'steven'</span>] = []</div><div class="line">    debt[<span class="string">'beauty'</span>] = []</div><div class="line">    print(BFS(debt).bfs(<span class="string">'kevin'</span>))</div></pre></td></tr></table></figure></p><p>好了，现在广度优先搜索大家也会了，广度优先搜索还有个非常经典的练习题目就是迷宫问题，大家可以尝试解解看，原理是一样的。有问题可以给我留言。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python算法分享系列 -- 二叉树</title>
      <link href="/2018/02/07/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/02/07/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>最近比较懒，一直没有更新，耐不住迷妹们在后台频繁的鼓励，今天我们来蹭个热点，了解下二叉树。 最近最火的一个新闻莫过于某著名程序员面试Google被拒，原因是不会反转二叉树。<br>今天我们就来学习二叉树。<br><a id="more"></a></p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><blockquote><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。<br>二叉树常被用于实现二叉查找树和二叉堆。</p></blockquote><h2 id="如何定义一个二叉树"><a href="#如何定义一个二叉树" class="headerlink" title="如何定义一个二叉树"></a>如何定义一个二叉树</h2><p>根据定义，我们知道二叉树最重要的是根节点，左节点和右节点，我们来实现一个类来代表二叉树：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, left=None, right=None)</span>:</span></div><div class="line">        self.val = val</div><div class="line">        self.left = left</div><div class="line">        self.right = right</div></pre></td></tr></table></figure></p><h2 id="实现二叉查找树（Binary-Search-Tree）"><a href="#实现二叉查找树（Binary-Search-Tree）" class="headerlink" title="实现二叉查找树（Binary Search Tree）"></a>实现二叉查找树（Binary Search Tree）</h2><p>首先， 二叉查找树，又称二叉排序树（Binary Sort Tree）， 二叉搜索树，<br>它有如下特点：<br>（0）它是一颗空树，如果不是，它一定符合下列性质：<br>    （1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；<br>    （2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；<br>    （3）左、右子树也分别为二叉排序树；</p><p>先看一个二叉查找树的例子：<br><img src="/2018/02/07/测试开发系列/算法/Python算法分享系列 -- 二叉树/BinarySearchTree.PNG" alt=""><br>下面来实现它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_tree</span><span class="params">(self, root, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> root.val &gt; value:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:</div><div class="line">                root.left = Node(value)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.insert_tree(root.left, value)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> root.val &lt; value:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:</div><div class="line">                root.right = Node(value)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.insert_tree(root.right, value)</div></pre></td></tr></table></figure></p><p>那么，二叉树如何实现查找呢？根据二叉树的特点，我们知道：<br>1.如果要查找的值等于根节点的值，成功退出。<br>2.如果要查找的值小于根节点的值， 递归查找左分支树， 否则，递归查找右分支树，<br>3.如果发现等同于要查找的值，成功退出。<br>4.如果子树为空，返回空。</p><p>在查找之前，我们先看看如何遍历二叉树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">#先访问根节点，再遍历左子树，最后遍历右子树；</span></div><div class="line"><span class="comment">#并且在遍历左右子树时，仍需先访问根节点，然后遍历左子树，最后遍历右子树。</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root)</span>:</span></div><div class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">           <span class="keyword">return</span> []</div><div class="line">       result = [root.val]</div><div class="line">       left_result = self.preorder(root.left)</div><div class="line">       right_result = self.preorder(root.right)</div><div class="line">       <span class="keyword">return</span> result + left_result + right_result</div><div class="line"></div><div class="line">   <span class="comment">#中序遍历：先遍历左子树、然后访问根节点，最后遍历右子树；</span></div><div class="line"><span class="comment">#并且在遍历左右子树的时候。仍然是先遍历左子树，然后访问根节点，最后遍历右子树。</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">midorder</span><span class="params">(self, root)</span>:</span></div><div class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">           <span class="keyword">return</span> []</div><div class="line">       left_result = self.midorder(root.left)</div><div class="line">       result = [root.val]</div><div class="line">       right_result = self.midorder(root.right)</div><div class="line">       <span class="keyword">return</span> left_result + result + right_result</div><div class="line"></div><div class="line">   <span class="comment">#后续遍历：先遍历左子树，然后遍历右子树，最后访问根节点；</span></div><div class="line"><span class="comment">#同样，在遍历左右子树的时候同样要先遍历左子树，然后遍历右子树，最后访问根节点。</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, root)</span>:</span></div><div class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">           <span class="keyword">return</span> []</div><div class="line">       left_result = self.postorder(root.left)</div><div class="line">       right_result = self.postorder(root.right)</div><div class="line">       result = [root.val]</div><div class="line">       <span class="keyword">return</span> left_result  + right_result + result</div></pre></td></tr></table></figure>  <p>查找：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_node</span><span class="params">(self, root, value)</span>:</span></div><div class="line">    <span class="keyword">if</span> value <span class="keyword">in</span> self.postorder(root):</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>  </p><p>最后，我们来看下大神回答不出来的那个问题， 交换二叉树的左右节点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch_node</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    root.left, root.right = root.right, root.left</div><div class="line">    self.switch_node(root.left)</div><div class="line">    self.switch_node(root.right)</div><div class="line">    <span class="keyword">return</span> self.preorder(root)</div></pre></td></tr></table></figure><br>由此可以看出， 二叉树的操作，最多的用到的是递归,递归的本质是自己调用自己，下面给一个函数来理解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#求阶乘</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></div><div class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>)</div><div class="line"></div><div class="line">如何理解呢？</div><div class="line">n = <span class="number">5</span>;    </div><div class="line">x = factorial (n);</div><div class="line">    x = factorial (<span class="number">5</span>);                         <span class="comment"># first call to function</span></div><div class="line">    x = (<span class="number">5</span> * factorial (<span class="number">4</span>));                   <span class="comment"># recursion starts, until logic requirement satisfied</span></div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * factorial (<span class="number">3</span>)));</div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * factorial (<span class="number">2</span>))));</div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * factorial (<span class="number">1</span>)))));</div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * (<span class="number">1</span>)))));           <span class="comment"># all calls made, logic ceases the recursion</span></div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * <span class="number">1</span>))));             <span class="comment"># returns start as resolutions/calculations begin</span></div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * <span class="number">2</span>)));</div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * <span class="number">6</span>));</div><div class="line">    x = (<span class="number">5</span> * <span class="number">24</span>);</div><div class="line">    x = (<span class="number">120</span>);                                 <span class="comment"># final resolution/calculation before return</span></div><div class="line">    x = <span class="number">120</span>;</div></pre></td></tr></table></figure><br>递归的理解不尽相同， 不过读者大可不必去关心函数如何一层层调用的，因为</p><blockquote><p>Recursion is the process of solving a problem in terms of smaller versions of the same problem. Since the problem gets smaller each time, the process eventually terminates in a problem (the “base case”)  that can be solved directly. Be sure of three things:</p><ul><li>The problem gets smaller each time.</li><li>You include a solution for the base case.</li><li>Each case is handled correctly.</li></ul><p>That’s really all there is to it.<br>参考资料：<br>！<a href="https://www.reddit.com/r/learnprogramming/comments/135rdz/help_me_understand_recursion/" target="_blank" rel="external">递归理解1</a><br>！<a href="https://www.johndcook.com/blog/2010/03/30/understanding-recursion/" target="_blank" rel="external">递归理解2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dev-in-test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python算法分享系列 -- 二叉树</title>
      <link href="/2018/02/07/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/02/07/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>最近比较懒，一直没有更新，耐不住迷妹们在后台频繁的鼓励，今天我们来蹭个热点，了解下二叉树。 最近最火的一个新闻莫过于某著名程序员面试Google被拒，原因是不会反转二叉树。<br>今天我们就来学习二叉树。<br><a id="more"></a></p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><blockquote><p>二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。<br>二叉树常被用于实现二叉查找树和二叉堆。</p></blockquote><h2 id="如何定义一个二叉树"><a href="#如何定义一个二叉树" class="headerlink" title="如何定义一个二叉树"></a>如何定义一个二叉树</h2><p>根据定义，我们知道二叉树最重要的是根节点，左节点和右节点，我们来实现一个类来代表二叉树：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val, left=None, right=None)</span>:</span></div><div class="line">        self.val = val</div><div class="line">        self.left = left</div><div class="line">        self.right = right</div></pre></td></tr></table></figure></p><h2 id="实现二叉查找树（Binary-Search-Tree）"><a href="#实现二叉查找树（Binary-Search-Tree）" class="headerlink" title="实现二叉查找树（Binary Search Tree）"></a>实现二叉查找树（Binary Search Tree）</h2><p>首先， 二叉查找树，又称二叉排序树（Binary Sort Tree）， 二叉搜索树，<br>它有如下特点：<br>（0）它是一颗空树，如果不是，它一定符合下列性质：<br>    （1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；<br>    （2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；<br>    （3）左、右子树也分别为二叉排序树；</p><p>先看一个二叉查找树的例子：<br><img src="/2018/02/07/面试相关/算法/Python算法分享系列 -- 二叉树/BinarySearchTree.PNG" alt=""><br>下面来实现它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_tree</span><span class="params">(self, root, value)</span>:</span></div><div class="line">        <span class="keyword">if</span> root.val &gt; value:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:</div><div class="line">                root.left = Node(value)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.insert_tree(root.left, value)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> root.val &lt; value:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:</div><div class="line">                root.right = Node(value)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.insert_tree(root.right, value)</div></pre></td></tr></table></figure></p><p>那么，二叉树如何实现查找呢？根据二叉树的特点，我们知道：<br>1.如果要查找的值等于根节点的值，成功退出。<br>2.如果要查找的值小于根节点的值， 递归查找左分支树， 否则，递归查找右分支树，<br>3.如果发现等同于要查找的值，成功退出。<br>4.如果子树为空，返回空。</p><p>在查找之前，我们先看看如何遍历二叉树：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">#先访问根节点，再遍历左子树，最后遍历右子树；</span></div><div class="line"><span class="comment">#并且在遍历左右子树时，仍需先访问根节点，然后遍历左子树，最后遍历右子树。</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root)</span>:</span></div><div class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">           <span class="keyword">return</span> []</div><div class="line">       result = [root.val]</div><div class="line">       left_result = self.preorder(root.left)</div><div class="line">       right_result = self.preorder(root.right)</div><div class="line">       <span class="keyword">return</span> result + left_result + right_result</div><div class="line"></div><div class="line">   <span class="comment">#中序遍历：先遍历左子树、然后访问根节点，最后遍历右子树；</span></div><div class="line"><span class="comment">#并且在遍历左右子树的时候。仍然是先遍历左子树，然后访问根节点，最后遍历右子树。</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">midorder</span><span class="params">(self, root)</span>:</span></div><div class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">           <span class="keyword">return</span> []</div><div class="line">       left_result = self.midorder(root.left)</div><div class="line">       result = [root.val]</div><div class="line">       right_result = self.midorder(root.right)</div><div class="line">       <span class="keyword">return</span> left_result + result + right_result</div><div class="line"></div><div class="line">   <span class="comment">#后续遍历：先遍历左子树，然后遍历右子树，最后访问根节点；</span></div><div class="line"><span class="comment">#同样，在遍历左右子树的时候同样要先遍历左子树，然后遍历右子树，最后访问根节点。</span></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, root)</span>:</span></div><div class="line">       <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">           <span class="keyword">return</span> []</div><div class="line">       left_result = self.postorder(root.left)</div><div class="line">       right_result = self.postorder(root.right)</div><div class="line">       result = [root.val]</div><div class="line">       <span class="keyword">return</span> left_result  + right_result + result</div></pre></td></tr></table></figure>  <p>查找：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_node</span><span class="params">(self, root, value)</span>:</span></div><div class="line">    <span class="keyword">if</span> value <span class="keyword">in</span> self.postorder(root):</div><div class="line">        <span class="keyword">return</span> <span class="keyword">True</span></div></pre></td></tr></table></figure>  </p><p>最后，我们来看下大神回答不出来的那个问题， 交换二叉树的左右节点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">switch_node</span><span class="params">(self, root)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</div><div class="line">        <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">    root.left, root.right = root.right, root.left</div><div class="line">    self.switch_node(root.left)</div><div class="line">    self.switch_node(root.right)</div><div class="line">    <span class="keyword">return</span> self.preorder(root)</div></pre></td></tr></table></figure><br>由此可以看出， 二叉树的操作，最多的用到的是递归,递归的本质是自己调用自己，下面给一个函数来理解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#求阶乘</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></div><div class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> n*factorial(n<span class="number">-1</span>)</div><div class="line"></div><div class="line">如何理解呢？</div><div class="line">n = <span class="number">5</span>;    </div><div class="line">x = factorial (n);</div><div class="line">    x = factorial (<span class="number">5</span>);                         <span class="comment"># first call to function</span></div><div class="line">    x = (<span class="number">5</span> * factorial (<span class="number">4</span>));                   <span class="comment"># recursion starts, until logic requirement satisfied</span></div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * factorial (<span class="number">3</span>)));</div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * factorial (<span class="number">2</span>))));</div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * factorial (<span class="number">1</span>)))));</div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * (<span class="number">1</span>)))));           <span class="comment"># all calls made, logic ceases the recursion</span></div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * <span class="number">1</span>))));             <span class="comment"># returns start as resolutions/calculations begin</span></div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * <span class="number">2</span>)));</div><div class="line">    x = (<span class="number">5</span> * (<span class="number">4</span> * <span class="number">6</span>));</div><div class="line">    x = (<span class="number">5</span> * <span class="number">24</span>);</div><div class="line">    x = (<span class="number">120</span>);                                 <span class="comment"># final resolution/calculation before return</span></div><div class="line">    x = <span class="number">120</span>;</div></pre></td></tr></table></figure><br>递归的理解不尽相同， 不过读者大可不必去关心函数如何一层层调用的，因为</p><blockquote><p>Recursion is the process of solving a problem in terms of smaller versions of the same problem. Since the problem gets smaller each time, the process eventually terminates in a problem (the “base case”)  that can be solved directly. Be sure of three things:</p><ul><li>The problem gets smaller each time.</li><li>You include a solution for the base case.</li><li>Each case is handled correctly.</li></ul><p>That’s really all there is to it.<br>参考资料：<br>！<a href="https://www.reddit.com/r/learnprogramming/comments/135rdz/help_me_understand_recursion/" target="_blank" rel="external">递归理解1</a><br>！<a href="https://www.johndcook.com/blog/2010/03/30/understanding-recursion/" target="_blank" rel="external">递归理解2</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[web开发] Flask+Python开发个人博客（六）</title>
      <link href="/2017/12/24/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2017/12/24/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Flask开发中的一些技巧。<br><a id="more"></a></p><p>旧文五篇：<br><a href="http://helloqa.com/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（一）</a><br><a href="http://helloqa.com/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（二）</a><br><a href="http://helloqa.com/2017/04/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[web%E5%BC%80%E5%8F%91]%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（三）</a><br><a href="http://helloqa.com/2017/04/13/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[web%E5%BC%80%E5%8F%91]%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（四）</a><br><a href="http://helloqa.com/2017/04/14/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[web%E5%BC%80%E5%8F%91]%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%94%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（五）</a></p><p>在Flask开发中，我们常常会用到很多配置变量，这些变量一开始是我们的本地环境变量，等你开发好后，会替换成线上产品变量，这样就导致你经常需要把一个变量的值改来改去。<br>其实Flask提供了一个很好的方式来解决这个问题， 那就是instance。<br>正常情况下，我们的变量都存在config.py的文件里，当使用的时候，在__init__.py里，加入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__)</div><div class="line">app.config.from_object(<span class="string">'config'</span>)</div><div class="line"></div><div class="line"><span class="comment">#后面的代码中，如果需要用到某个变量，只需要：</span></div><div class="line">app.config[<span class="string">"variable"</span>] </div><div class="line">就可以访问了</div></pre></td></tr></table></figure></p><p>那么当你需要隔离某些变量时怎么办， 只需要在项目根目录下建立一个instance文件夹，然后里面建config文件，目录大概如下：<br><img src="/2017/12/24/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（六）/1.png" alt=""></p><p>使用方式是在__init__.py里，加入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__, instance_relative_config=<span class="keyword">True</span>)</div><div class="line">app.config.from_pyfile(<span class="string">'config.py'</span>)</div><div class="line"></div><div class="line"><span class="comment">#这样，如果你instance文件里定义了某个变量，系统就会从instance文件夹下面的config文件里寻找。 同时你可以把instance这个文件加入到git的ignore名单，这样就无需再频繁改动config文件了。</span></div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> dev-in-test </tag>
            
            <tag> 开发个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python算法分享系列 -- 查找，排序，递归</title>
      <link href="/2017/12/19/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%92%E5%BD%92/"/>
      <url>/2017/12/19/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>沉寂了一段时间，继续学习。<br>算法这个系列我想分享很久了，奈何本身对算法不是特别了解，又找不到合适的载体来分享。<br>最近看了本有趣的算法书， 文中通过图文并茂的讲解给我很大启发，尝试着分享下<br><a id="more"></a></p><p>需要注意的是， 文中各个算法的写法不是简单的拷贝，算理解思想后拿Python3重新写了遍，分享的代码和书中的例子也稍有不同，加了些日常工作中会做的处理，如有不适，请联系我。</p><h2 id="二分查找-–仅当列表是有序的时候才能用"><a href="#二分查找-–仅当列表是有序的时候才能用" class="headerlink" title="二分查找 –仅当列表是有序的时候才能用"></a>二分查找 –仅当列表是有序的时候才能用</h2><p>思想：</p><blockquote><p>1.目标是找数组中的某一个元素，暂叫item<br>2.找出整个数组中间的那个元素，它下标mid，数组被它一分为二<br>3.比较下标mid对应的元素和item，如果mid对应的元素大，查找范围缩小到mid前面的那一半数组，反之，缩小到mid后的那一半数组<br>4.重复3，直到item==mid</p></blockquote><p><img src="/2017/12/19/测试开发系列/算法/Python算法分享系列 -- 查找，排序，递归/二分查找法.PNG" alt=""></p><p>对于包含N个元素的列表，用二分查找最多需要log2 N 步。（对数是幂运算的逆运算）</p><p>大O表示法指出了算法有多快。例如，假设列表包含n 个元素。简单查找需要检查每个元素，因此需要执行n 次操作。使用大O表示法，这个运行时间为O (n )。单位秒呢？没有——大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速 。</p><p>再来看一个例子。为检查长度为n 的列表，二分查找需要执行log n 次操作。使用大O表示法，这个运行时间怎么表示呢？O (log n )。一般而言，大O表示法按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。</p><blockquote><p>O (log n )，也叫对数时间 ，这样的算法包括二分查找。<br>O (n )，也叫线性时间 ，这样的算法包括简单查找。<br>O (n * log n )，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。<br>O (n 2 )，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。<br>O (n !)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</p></blockquote><p>大O表示法指出了最糟情况下的运行时间.</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>思想：</p><blockquote><p>找出数组中最小的元素<br>把数组中最小的元素pop出来到新的数组里。<br>重复以上操作直到原数组为空</p></blockquote><p><img src="/2017/12/19/测试开发系列/算法/Python算法分享系列 -- 查找，排序，递归/selection_sort.PNG" alt=""></p><blockquote><p>需要存储多个元素时，可使用数组或链表。<br>数组的元素都在一起。<br>链表的元素是分开的，其中每个元素都存储了下一个元素的地址。<br>数组的读取速度很快。<br>链表的插入和删除速度很快。<br>在同一个数组中，所有元素的类型都必须相同（都为int、double等）</p></blockquote><p>数字和链表区别：<br>数组： 连续空间， 预留空间， 查找方便， 插入麻烦，必须移动后面的所有元素，如果没有空间，必须将数组复制到其他地方。<br>链表： 分散空间，查找麻烦，插入方便，只需移动前面元素指向的地址。</p><pre><code>数组             链表</code></pre><p>读取            O（1）                O（n）</p><p>插入            O（n）                O（1）</p><p>删除            O（n）                O(1)</p><p>访问            顺序访问            随机访问</p><p>O(n)=线性时间<br>O(1)=常量时间</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>每个递归函数都有两部分：基线条件 （base case）和递归条件 （recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(x)</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> x&lt;=<span class="number">1</span>:       <span class="comment">#----基线条件</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        fact(x<span class="number">-1</span>) <span class="comment">#---递归条件</span></div><div class="line"></div><div class="line">print(fact(<span class="number">6</span>))</div></pre></td></tr></table></figure></p><p>我们拿 <strong>最大公约数 </strong>来举例：</p><p>思想：</p><blockquote><p>假定x &gt; y（如果x &lt; y，则互换）<br>求x对y的余数，假定余数为z<br>求y与z的最大公约数即为x，与y的最大公约数<br>0没有公约数<br><img src="/2017/12/19/测试开发系列/算法/Python算法分享系列 -- 查找，排序，递归/GONGYUESHU.webp" alt=""></p></blockquote><p><strong> 最小公倍数  </strong>：<br>思想：</p><blockquote><p>两个数(x, y)的最小公倍数数的算法为：两个数相乘再除以他们的最大公约数<br>0没有公倍数<br><img src="/2017/12/19/测试开发系列/算法/Python算法分享系列 -- 查找，排序，递归/公倍数.PNG" alt=""></p></blockquote><p>公约数，公倍数，适用于自然数。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>思想：</p><blockquote><p>少于2个元素的数组不需要排序<br>找一个元素作为基数<br>小于基数的放一个数组<br>大于基数的放一个数组<br>针对小于基数的数组做快速排序，暂且叫low<br>针对大于基数的数组做快速排序, 暂且叫high<br>最终排序后的 low + 【基数】+ high，就是排好序的数组</p></blockquote><p><img src="/2017/12/19/测试开发系列/算法/Python算法分享系列 -- 查找，排序，递归/quicksort.PNG" alt=""></p><p>总结下：</p><blockquote><p>D&amp;C算法（divided and conqure）是递归的。使用D&amp;C解决问题的过程包括两个步骤。<br>(1) 找出基线条件，这种条件必须尽可能简单。<br>(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。</p></blockquote><h2 id="散列表（Hash-Table）"><a href="#散列表（Hash-Table）" class="headerlink" title="散列表（Hash Table）"></a>散列表（Hash Table）</h2><p>散列函数：</p><blockquote><p>散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。<br>散列函数总是将同样的输入映射到相同的索引。例如你每次输入iTesting，它返回你的总是同一个数字。<br>散列函数将不同的输入映射到不同的索引。比如iTesting对应6， python对于0. 如果散列函数将不同的键映射到同一个位置，就在这个位置存储一个链表。<br>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。</p></blockquote><p>结合使用散列函数和数组创建了一种被称为散列表 （hash table）的数据结构。<br>不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典 ，你可使用函数dict 来创建散列表。</p><blockquote><p>散列表被用于大海捞针式的查找，散列表适合用于：<br>模拟映射关系；<br>防止重复；<br>缓存/记住数据，以免服务器再通过处理来生成它们。</p></blockquote><p>总结：</p><blockquote><p>你可以结合散列函数和数组来创建散列表。<br>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。<br>散列表的查找、插入和删除速度都非常快。<br>散列表适合用于模拟映射关系。<br>一旦填装因子超过0.7，就该调整散列表的长度（通常将数组长度加倍）。<br>散列表可用于缓存数据（例如，在Web服务器上）。<br>散列表非常适合用于防止重复。<br>（填装因子是数组中被占用的位置，例如大小为3的数字，有2个被占用，则填装因子为2/3）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dev-in-test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python算法分享系列 -- 查找，排序，递归</title>
      <link href="/2017/12/19/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%92%E5%BD%92/"/>
      <url>/2017/12/19/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/%E7%AE%97%E6%B3%95/Python%E7%AE%97%E6%B3%95%E5%88%86%E4%BA%AB%E7%B3%BB%E5%88%97%20--%20%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>沉寂了一段时间，继续学习。<br>算法这个系列我想分享很久了，奈何本身对算法不是特别了解，又找不到合适的载体来分享。<br>最近看了本有趣的算法书， 文中通过图文并茂的讲解给我很大启发，尝试着分享下<br><a id="more"></a></p><p>需要注意的是， 文中各个算法的写法不是简单的拷贝，算理解思想后拿Python3重新写了遍，分享的代码和书中的例子也稍有不同，加了些日常工作中会做的处理，如有不适，请联系我。</p><h2 id="二分查找-–仅当列表是有序的时候才能用"><a href="#二分查找-–仅当列表是有序的时候才能用" class="headerlink" title="二分查找 –仅当列表是有序的时候才能用"></a>二分查找 –仅当列表是有序的时候才能用</h2><p>思想：</p><blockquote><p>1.目标是找数组中的某一个元素，暂叫item<br>2.找出整个数组中间的那个元素，它下标mid，数组被它一分为二<br>3.比较下标mid对应的元素和item，如果mid对应的元素大，查找范围缩小到mid前面的那一半数组，反之，缩小到mid后的那一半数组<br>4.重复3，直到item==mid</p></blockquote><p><img src="/2017/12/19/面试相关/算法/Python算法分享系列 -- 查找，排序，递归/二分查找法.PNG" alt=""></p><p>对于包含N个元素的列表，用二分查找最多需要log2 N 步。（对数是幂运算的逆运算）</p><p>大O表示法指出了算法有多快。例如，假设列表包含n 个元素。简单查找需要检查每个元素，因此需要执行n 次操作。使用大O表示法，这个运行时间为O (n )。单位秒呢？没有——大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速 。</p><p>再来看一个例子。为检查长度为n 的列表，二分查找需要执行log n 次操作。使用大O表示法，这个运行时间怎么表示呢？O (log n )。一般而言，大O表示法按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。</p><blockquote><p>O (log n )，也叫对数时间 ，这样的算法包括二分查找。<br>O (n )，也叫线性时间 ，这样的算法包括简单查找。<br>O (n * log n )，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。<br>O (n 2 )，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。<br>O (n !)，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。</p></blockquote><p>大O表示法指出了最糟情况下的运行时间.</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>思想：</p><blockquote><p>找出数组中最小的元素<br>把数组中最小的元素pop出来到新的数组里。<br>重复以上操作直到原数组为空</p></blockquote><p><img src="/2017/12/19/面试相关/算法/Python算法分享系列 -- 查找，排序，递归/selection_sort.PNG" alt=""></p><blockquote><p>需要存储多个元素时，可使用数组或链表。<br>数组的元素都在一起。<br>链表的元素是分开的，其中每个元素都存储了下一个元素的地址。<br>数组的读取速度很快。<br>链表的插入和删除速度很快。<br>在同一个数组中，所有元素的类型都必须相同（都为int、double等）</p></blockquote><p>数字和链表区别：<br>数组： 连续空间， 预留空间， 查找方便， 插入麻烦，必须移动后面的所有元素，如果没有空间，必须将数组复制到其他地方。<br>链表： 分散空间，查找麻烦，插入方便，只需移动前面元素指向的地址。</p><pre><code>数组             链表</code></pre><p>读取            O（1）                O（n）</p><p>插入            O（n）                O（1）</p><p>删除            O（n）                O(1)</p><p>访问            顺序访问            随机访问</p><p>O(n)=线性时间<br>O(1)=常量时间</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>每个递归函数都有两部分：基线条件 （base case）和递归条件 （recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(x)</span>:</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> x&lt;=<span class="number">1</span>:       <span class="comment">#----基线条件</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        fact(x<span class="number">-1</span>) <span class="comment">#---递归条件</span></div><div class="line"></div><div class="line">print(fact(<span class="number">6</span>))</div></pre></td></tr></table></figure></p><p>我们拿 <strong>最大公约数 </strong>来举例：</p><p>思想：</p><blockquote><p>假定x &gt; y（如果x &lt; y，则互换）<br>求x对y的余数，假定余数为z<br>求y与z的最大公约数即为x，与y的最大公约数<br>0没有公约数<br><img src="/2017/12/19/面试相关/算法/Python算法分享系列 -- 查找，排序，递归/GONGYUESHU.webp" alt=""></p></blockquote><p><strong> 最小公倍数  </strong>：<br>思想：</p><blockquote><p>两个数(x, y)的最小公倍数数的算法为：两个数相乘再除以他们的最大公约数<br>0没有公倍数<br><img src="/2017/12/19/面试相关/算法/Python算法分享系列 -- 查找，排序，递归/公倍数.PNG" alt=""></p></blockquote><p>公约数，公倍数，适用于自然数。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>思想：</p><blockquote><p>少于2个元素的数组不需要排序<br>找一个元素作为基数<br>小于基数的放一个数组<br>大于基数的放一个数组<br>针对小于基数的数组做快速排序，暂且叫low<br>针对大于基数的数组做快速排序, 暂且叫high<br>最终排序后的 low + 【基数】+ high，就是排好序的数组</p></blockquote><p><img src="/2017/12/19/面试相关/算法/Python算法分享系列 -- 查找，排序，递归/quicksort.PNG" alt=""></p><p>总结下：</p><blockquote><p>D&amp;C算法（divided and conqure）是递归的。使用D&amp;C解决问题的过程包括两个步骤。<br>(1) 找出基线条件，这种条件必须尽可能简单。<br>(2) 不断将问题分解（或者说缩小规模），直到符合基线条件。</p></blockquote><h2 id="散列表（Hash-Table）"><a href="#散列表（Hash-Table）" class="headerlink" title="散列表（Hash Table）"></a>散列表（Hash Table）</h2><p>散列函数：</p><blockquote><p>散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。<br>散列函数总是将同样的输入映射到相同的索引。例如你每次输入iTesting，它返回你的总是同一个数字。<br>散列函数将不同的输入映射到不同的索引。比如iTesting对应6， python对于0. 如果散列函数将不同的键映射到同一个位置，就在这个位置存储一个链表。<br>散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。</p></blockquote><p>结合使用散列函数和数组创建了一种被称为散列表 （hash table）的数据结构。<br>不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典 ，你可使用函数dict 来创建散列表。</p><blockquote><p>散列表被用于大海捞针式的查找，散列表适合用于：<br>模拟映射关系；<br>防止重复；<br>缓存/记住数据，以免服务器再通过处理来生成它们。</p></blockquote><p>总结：</p><blockquote><p>你可以结合散列函数和数组来创建散列表。<br>冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。<br>散列表的查找、插入和删除速度都非常快。<br>散列表适合用于模拟映射关系。<br>一旦填装因子超过0.7，就该调整散列表的长度（通常将数组长度加倍）。<br>散列表可用于缓存数据（例如，在Web服务器上）。<br>散列表非常适合用于防止重复。<br>（填装因子是数组中被占用的位置，例如大小为3的数字，有2个被占用，则填装因子为2/3）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[web开发] Flask+Python开发个人博客（五）</title>
      <link href="/2017/12/14/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2017/12/14/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>开发任意一个博客或者网页，如果不是静态的，你就绕不过一个问题，数据怎么存储？<br><a id="more"></a></p><p>今天是 [web开发] Flask+Python开发个人博客 第五篇，旧文四篇：<br><a href="https://helloqa.com/2018/12/13/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[web%E5%BC%80%E5%8F%91]%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（四）</a><br><a href="https://helloqa.com/2018/12/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[web%E5%BC%80%E5%8F%91]%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（三）</a><br><a href="https://helloqa.com/2018/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">[Web开发] Flask+Python 开发个人博客（二）</a><br><a href="https://helloqa.com/2018/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（一）</a></p><p>开发任意一个博客或者网页，如果不是静态的，你就绕不过一个问题，数据怎么存储？ 这个摊开来讲就是一个硕大的工程，今天仅就我的博客为例， 来讲下数据库设计。</p><p>我选择SQL Server2008 来存储我的数据， 我们看看都有什么内容要存？<br>1.有登录和注册模块，那必然要存用户的相关信息 — Members<br>2.要实现用户发帖和修改，那必须要有权限管理。 — Role， Privilege，RolePrivilege<br>3.要发布文章，文章必须要管理起来 –Categories， Posts。</p><p>再来看下这些表之间的关系：</p><ol><li>用户应该分组，所以Members表和Role表就有对应关系，具体表现为Members表每一个user有对应的RoleID。</li><li>分组不同，权限应该不同，RolePrivilege展示这个不同。</li><li>即使不是管理员用户，他自己发布的文章应该可以修改，删除，即每个用户对自己的文章有绝对权限，那么，文章Posts表应该有用户的Memerid。</li><li>每个文章应该都有一个类别，Posts表格和Categories应该有关联，同时Posts表应该表现这个不同。</li></ol><p>根据上述要求，数据库表关应该如下：<br><img src="/2017/12/14/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（五）/1.png" alt=""></p><p>最后，附上数据库设计的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">use kevin_forum</div><div class="line">go</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">create table Role(</div><div class="line">RoleId int <span class="keyword">not</span> null IDENTITY(<span class="number">1</span>,<span class="number">1</span>) primary key,</div><div class="line">RoleName varchar(<span class="number">50</span>) <span class="keyword">not</span> null, </div><div class="line">Description varchar(<span class="number">100</span>) </div><div class="line">)</div><div class="line"></div><div class="line">create table Privilege(</div><div class="line">PrivilegeId int <span class="keyword">not</span> null IDENTITY(<span class="number">1</span>,<span class="number">1</span>) primary key, </div><div class="line">PrivilegeName varchar(<span class="number">50</span>) <span class="keyword">not</span> null, </div><div class="line">Description varchar(<span class="number">100</span>)</div><div class="line">)</div><div class="line"></div><div class="line">create table RolePrivilege(</div><div class="line">RolePrivilegeId int <span class="keyword">not</span> null primary key,</div><div class="line">RoleId int <span class="keyword">not</span> null  foreign key references Role(RoleId),</div><div class="line">PrivilegeId int foreign key references Privilege(PrivilegeId)</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">create table Members(</div><div class="line">MemberId int <span class="keyword">not</span> null  IDENTITY(<span class="number">1</span>,<span class="number">1</span>) primary key, </div><div class="line">UserName varchar(<span class="number">50</span>) unique NOT NULL, </div><div class="line">PassWord varchar(<span class="number">50</span>) <span class="keyword">not</span> null, </div><div class="line">RoleId int <span class="keyword">not</span> null  default(<span class="number">2</span>) foreign key references Role(RoleId),</div><div class="line">PhoneNumber varchar(<span class="number">50</span>) unique NOT NULL</div><div class="line">)</div><div class="line"></div><div class="line"></div><div class="line">CREATE TABLE [dbo].[Categories](</div><div class="line">[CId] [int] IDENTITY(<span class="number">1</span>,<span class="number">1</span>) NOT NULL primary key,</div><div class="line">[CName] [varchar](<span class="number">100</span>) NOT NULL,</div><div class="line">)</div><div class="line"></div><div class="line">CREATE TABLE [dbo].[Posts](</div><div class="line">[PId] [int] IDENTITY(<span class="number">1</span>,<span class="number">1</span>) NOT NULL PRIMARY KEY,</div><div class="line">[Title] [varchar](<span class="number">100</span>) NULL,</div><div class="line">[Contents] [varchar](max) NULL,</div><div class="line">[MemberId] [int] NOT NULL foreign key references Members(MemberId),</div><div class="line">[CId] [int] NOT NULL,</div><div class="line">[Comments] [varchar](max) NULL,</div><div class="line">[InsertTime] [datetime]  DEFAULT(getdate()),</div><div class="line">[ModifyTime] [datetime]  DEFAULT(getdate()),</div><div class="line">[ModifyByMemberId] [int] NOT NULL</div><div class="line">)</div><div class="line"></div><div class="line">alter table [dbo].[Posts]</div><div class="line">add constraint posts_members_conn foreign key(MemberId) references [dbo].[Members](MemberId) </div><div class="line"></div><div class="line">alter table [dbo].[Posts]</div><div class="line">add foreign key(CId) references [dbo].[Categories](CId) </div><div class="line"></div></pre></td></tr></table></figure></p><p>如果要了解数据库设计的原则，请自行搜索。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> dev-in-test </tag>
            
            <tag> 开发个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[web开发] Flask+Python开发个人博客（四）</title>
      <link href="/2017/12/13/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2017/12/13/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Ckeditor， 最好的富文本编辑器之一。<br><a id="more"></a></p><p>这是[web开发] Flask+Python开发个人博客 系列 第四篇， 在线编辑器的使用。<br>旧文三篇：<br><a href="https://helloqa.com/2018/12/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[web%E5%BC%80%E5%8F%91]%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（三）</a><br><a href="https://helloqa.com/2018/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">[Web开发] Flask+Python 开发个人博客（二）</a><br><a href="https://helloqa.com/2018/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（一）</a></p><p>既然是博客，就免不了发布文章，而一个便利的，所见即所得的在线编辑器就显得至关重要，flask + WTF Forms 提供的textarea 功能太少，而且样式难以定制， 这个时候优秀的第3方控件就变成了我们的第一选择。经过比较，我选用了Ckeditor，今天我们来讲下<br>如何把它嵌入到我们的项目里去。<br>先看下嵌入到页面中的样子：<br><img src="/2017/12/13/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（四）/1.png" alt=""></p><blockquote><p>应用：</p><ol><li>从ckeditor.com下载文件，放到flask目录下的static文件夹内。</li><li>在要引用的HTML head里引入如下代码：<br>···python<pre><code>&lt;script src=&quot;{{ url_for('static', filename='ckeditor/ckeditor.js') }}&quot;&gt;&lt;/script&gt;</code></pre>···</li></ol></blockquote><ol><li>HTML页面嵌入ckeditor代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;textarea name=&quot;editor1&quot; id=&quot;editor1&quot; rows=&quot;10&quot; cols=&quot;80&quot;&gt;</div><div class="line">     This is my textarea to be replaced with CKEditor.</div><div class="line"> &lt;/textarea&gt;</div><div class="line"> &lt;script&gt;</div><div class="line">     // Replace the &lt;textarea id=&quot;editor1&quot;&gt; with a CKEditor</div><div class="line">     // instance, using default configuration.</div><div class="line">     CKEDITOR.replace( &apos;editor1&apos; );</div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure></li></ol><p>就这么简单，那么CKeditor如何跟flask结合起来呢？我写了一个sample project：</p><ol><li>项目目录如下：<br><img src="/2017/12/13/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（四）/2.png" alt=""></li><li>static文件夹就是我们下载下来的ckeditor源文件。</li><li>templates下面是我们的HTML页面， 代码如下：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line"></div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;title&gt;A Simple Page with CKEditor&lt;/title&gt;</div><div class="line">        &lt;!-- 请确保CKEditor文件路径正确 --&gt;</div><div class="line">        &lt;script src="&#123;&#123; url_for('static', filename='ckeditor/ckeditor.js') &#125;&#125;"&gt;&lt;/script&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;form method = 'post' action=''&gt;</div><div class="line">            &#123;&#123; form.csrf_token &#125;&#125;</div><div class="line">            title: &#123;&#123; form.title &#125;&#125;</div><div class="line">            category: &#123;&#123; form.category &#125;&#125;</div><div class="line">            &lt;textarea name="editor1" id="editor1" rows="10" cols="80"&gt;</div><div class="line">                &#123;&#123; content &#125;&#125;</div><div class="line">            &lt;/textarea&gt;</div><div class="line">            &lt;script&gt;</div><div class="line">                // 用CKEditor替换&lt;textarea id="editor1"&gt;</div><div class="line">                // 使用默认配置</div><div class="line">                CKEDITOR.replace('editor1');</div><div class="line">            &lt;/script&gt;</div><div class="line">            &#123;&#123; content &#125;&#125;</div><div class="line">            publish: &#123;&#123; form.publish &#125;&#125;</div><div class="line">        &lt;/form&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>4.run.py 是整个工程源码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template</div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm, validators</div><div class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostEditor</span><span class="params">(FlaskForm)</span>:</span></div><div class="line">    title = StringField(<span class="string">'标题'</span>, [validators.DataRequired(<span class="string">"Please enter your title"</span>)])</div><div class="line">    category = StringField(<span class="string">'类别'</span>, [validators.DataRequired(<span class="string">"Please enter your category"</span>)])</div><div class="line">    content = StringField(<span class="string">'内容'</span>, [validators.DataRequired(<span class="string">"Please enter your content"</span>)])</div><div class="line">    publish = SubmitField(<span class="string">'发布'</span>)</div><div class="line"></div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.secret_key = <span class="string">'iTesting'</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    form = PostEditor()</div><div class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span> <span class="keyword">or</span> form.validate_on_submit():</div><div class="line">        content = request.form.get(<span class="string">'editor1'</span>)</div><div class="line">        <span class="keyword">return</span> render_template(<span class="string">'ckeditor.html'</span>, content=content, form=form)</div><div class="line">    <span class="keyword">return</span> render_template(<span class="string">'ckeditor.html'</span>, form=form)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">   app.run(debug=<span class="keyword">True</span>)</div><div class="line"></div></pre></td></tr></table></figure></p><p>演示效果如下：<br>初始效果：<br><img src="/2017/12/13/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（四）/3.png" alt=""><br>提交以后效果：<br><img src="/2017/12/13/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（四）/4.png" alt=""></p><p>可以看到， 当点击提交时候，我们在CKeditor里的内容被记下来发给flask后端了，所以我们才能再次看见我们输入的内容。</p><p>以上就是CKEditor结合flask的简单使用， 但是缺点是只能接受文本内容，我们写博客肯定希望图文并茂，那么就需要配置ckeditor下的config.js了：<br><img src="/2017/12/13/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（四）/5.png" alt=""></p><ol><li><p>在config.js文件合适位置添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">config.filebrowserUploadUrl = <span class="string">'/ckupload/'</span>;</div></pre></td></tr></table></figure></li><li><p>在run.py 合适位置添加后台处理上传请求代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_rnd_filename</span><span class="params">()</span>:</span></div><div class="line">    filename_prefix = datetime.datetime.now().strftime(<span class="string">'%Y%m%d%H%M%S'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="string">'%s%s'</span> % (filename_prefix, str(random.randrange(<span class="number">1000</span>, <span class="number">10000</span>)))</div><div class="line"></div><div class="line"><span class="meta">@app.route('/ckupload/', methods=['POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ckupload</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""CKEditor file upload"""</span></div><div class="line">    error = <span class="string">''</span></div><div class="line">    url = <span class="string">''</span></div><div class="line">    callback = request.args.get(<span class="string">"CKEditorFuncNum"</span>)</div><div class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span> <span class="keyword">and</span> <span class="string">'upload'</span> <span class="keyword">in</span> request.files:</div><div class="line">        fileobj = request.files[<span class="string">'upload'</span>]</div><div class="line">        fname, fext = os.path.splitext(fileobj.filename)</div><div class="line">        rnd_name = <span class="string">'%s%s'</span> % (gen_rnd_filename(), fext)</div><div class="line">        filepath = os.path.join(app.static_folder, <span class="string">'upload'</span>, rnd_name)</div><div class="line">        <span class="comment"># 检查路径是否存在，不存在则创建</span></div><div class="line">        dirname = os.path.dirname(filepath)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dirname):</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                os.makedirs(dirname)</div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                error = <span class="string">'ERROR_CREATE_DIR'</span></div><div class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> os.access(dirname, os.W_OK):</div><div class="line">            error = <span class="string">'ERROR_DIR_NOT_WRITEABLE'</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> error:</div><div class="line">            fileobj.save(filepath)</div><div class="line">            url = url_for(<span class="string">'static'</span>, filename=<span class="string">'%s/%s'</span> % (<span class="string">'upload'</span>, rnd_name))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        error = <span class="string">'post error'</span></div><div class="line">    res = <span class="string">"""</span></div><div class="line"></div><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">  window.parent.CKEDITOR.tools.callFunction(%s, '%s', '%s');</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">""" % (callback, url, error)</div><div class="line">    response = make_response(res)</div><div class="line">    response.headers[<span class="string">"Content-Type"</span>] = <span class="string">"text/html"</span></div><div class="line">    <span class="keyword">return</span> response</div><div class="line"></div></pre></td></tr></table></figure></li></ol><p>这段代码获取上传的文件，并把它保存在项目static根目录下的ckupload文件夹内。<br>我们看下一个上传成功的例子：<br>通过运行python run.py,访问<a href="http://localhost:5000" target="_blank" rel="external">http://localhost:5000</a>, 填写相应内容提交：<br><img src="/2017/12/13/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（四）/6.png" alt=""><br>至此，项目结构变为：<br><img src="/2017/12/13/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（四）/7.png" alt=""></p><p>这样ckeditor和flask的集成就做好了，后续需要我们设计数据库表格来保存我们写的博客文章内容，这个放到下次讲。</p><p>如果你对ckeditor的配置有疑问，请留言给我或者直接访问官网<img src="http://docs.ckeditor.com/#!/guide" alt="ckedior官网"></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> dev-in-test </tag>
            
            <tag> 开发个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[web开发] Flask+Python开发个人博客（三）</title>
      <link href="/2017/12/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2017/12/10/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5Bweb%E5%BC%80%E5%8F%91%5D%20Flask+Python%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Blue print 蓝图应用指南<br><a id="more"></a></p><p>今天我们来讲讲flask里的blue print – 蓝图。<br>旧文两篇：<br><a href="https://helloqa.com/2018/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（一）</a><br><a href="https://helloqa.com/2018/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">[Web开发] Flask+Python 开发个人博客（二）</a></p><p>在前两篇的时候，大家还记得不同类型的账户，访问到的同一个页面元素有不同吗？这个是怎么做到呢？这就是蓝图的妙用了。<br>什么是蓝图，我们为什么要用蓝图？我们来看下exploreflask上的解释：</p><blockquote><p>What is a blueprint?<br>一个蓝图定义了可用于单个应用的视图，模板，静态文件等等的集合。举个例子，想象一下我们有一个用于管理面板的蓝图。这个蓝图将定义像/admin/login和/admin/dashboard这样的路由的视图。它可能还包括所需的模板和静态文件。你可以把这个蓝图当做你的应用的管理面板，管它是宇航员的交友网站，还是火箭推销员的CRM系统。</p><p>Why would you use blueprints?<br>蓝图的杀手锏是将你的应用组织成不同的组件。假如我们有一个微博客，我们可能需要有一个蓝图用于网站页面，比如index.html和about.html。然后我们还需要一个用于在登录面板中展示最新消息的蓝图，以及另外一个用于管理员面板的蓝图。站点中每一个独立的区域也可以在代码上隔绝开来。最终你将能够把你的应用依据许多能完成单一任务的小应用组织起来。</p><p>Where do you put them?</p></blockquote><p>以我的blog为例，对于同一篇文章，我希望不同权限的人看到的内容不同，但是我又想最大程度的重用一个模板，我的目录应该如下面的类似组织：<br><img src="/2017/12/10/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（三）/1.png" alt=""></p><p>How to use：</p><ol><li><p>前提条件，forms需要定义好， forum_app/forms.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask_wtf <span class="keyword">import</span> FlaskForm</div><div class="line"><span class="keyword">from</span> wtforms <span class="keyword">import</span> StringField, SubmitField, validators,</div><div class="line"><span class="keyword">from</span> wtforms.validators <span class="keyword">import</span> Regexp</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostEditor</span><span class="params">(FlaskForm)</span>:</span></div><div class="line">title = StringField(<span class="string">'标题'</span>, [validators.DataRequired(<span class="string">"Please enter your title"</span>)])</div><div class="line">category = StringField(<span class="string">'类别'</span>)</div><div class="line">publish = SubmitField(<span class="string">'发布'</span>)</div></pre></td></tr></table></figure></li><li><p>在views里定义好路由</p></li></ol><p>以admin_views为例：</p><p>views.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> render_template,request, Blueprint, redirect, url_for</div><div class="line"></div><div class="line"><span class="keyword">from</span> forum_app.db_helper.db_helper <span class="keyword">import</span> update_post</div><div class="line"><span class="keyword">from</span> forum_app.forms <span class="keyword">import</span> PostEditor</div><div class="line"></div><div class="line">blue_admin = Blueprint(<span class="string">'blue_admin'</span>, __name__, template_folder=<span class="string">'admin_forums'</span>)</div><div class="line"></div><div class="line"><span class="meta">@blue_admin.route('/detail_posts', methods =['GET', 'POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">posts_detail</span><span class="params">()</span>:</span></div><div class="line">form = PostEditor()</div><div class="line">pid = request.args.get(<span class="string">"id"</span>)</div><div class="line">post_title = request.args.get(<span class="string">"title"</span>)</div><div class="line">post_category = request.args.get(<span class="string">"category"</span>)</div><div class="line">post_author = request.args.get(<span class="string">"author"</span>)</div><div class="line">post_contents = request.args.get(<span class="string">"contents"</span>)</div><div class="line">post_create_time = request.args.get(<span class="string">"create_time"</span>)</div><div class="line">blue_print_name = <span class="string">"blue_admin"</span></div><div class="line">form.category.data = request.args.get(<span class="string">"category"</span>)</div><div class="line">form.title.data = request.args.get(<span class="string">"title"</span>)</div><div class="line">    <span class="keyword">if</span> request.method == <span class="string">"POST"</span> <span class="keyword">and</span> form.validate_on_submit():</div><div class="line">        <span class="keyword">if</span> request.form.get(<span class="string">'publish'</span>) == <span class="string">'发布'</span>:</div><div class="line">update_post(request.form.get(<span class="string">'title'</span>), request.form.get(<span class="string">'category'</span>),  request.form.get(<span class="string">'editor1'</span>), id=pid)</div><div class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">'forum'</span>))</div><div class="line">    <span class="keyword">return</span> render_template(<span class="string">'admin_forums/posts.html'</span>, post_title=post_title,\</div><div class="line">post_category=post_category, \</div><div class="line">post_author=post_author, post_contents=post_contents, \</div><div class="line">blue_print_name=blue_print_name, post_create_time=post_create_time, pid=pid, form=form)</div><div class="line"></div></pre></td></tr></table></figure></p><p>创建一个蓝图的语法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">blue_admin = Blueprint(<span class="string">'blue_admin'</span>, __name__, template_folder=<span class="string">'admin_forums'</span>)</div></pre></td></tr></table></figure></p><blockquote><p>To create a blueprint object, we import the Blueprint() class and initialize it with the arguments name and import_name. Usually import_name will just be <strong>name</strong>, which is a special Python variable containing the name of the current module.<br>The last parameter tell flask that the blueprint has its own template and static direcories.</p></blockquote><ol><li><p>定义好蓝图后，要把它注册到我们的程序上：<br>run.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> forum_app.views.admin_views.views <span class="keyword">import</span> blue_admin</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.register_blueprint(blue_admin, url_prefix=<span class="string">'/admin'</span>)</div><div class="line"></div><div class="line">app.run(debug=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></li><li><p>最后一步，构造URL，绑定路由和HTML template。<br>你只需要在 URL 的末端加上蓝图的名称和一个点（ . ）作为前缀即可完成绑定:<br>url_for(‘blue_admin.post_detail’)<br>templates/forum.html 部分代码<br><img src="/2017/12/10/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（三）/2.png" alt=""></p></li></ol><p>本例中我为了方便，user的post_detail路由和admin的post_detail路由所指向的html template我分开了：<br><img src="/2017/12/10/测试开发系列/个人博客开发系列/[web开发] Flask+Python开发个人博客（三）/3.png" alt=""><br>两个posts.html，在应用中你也可以用一个template，中间用if语句引导不同的路由渲染不同的templates。</p><p>到此就完成了所有blue print的应用，blueprint 给我们提供了一种类插件功能，我们可以利用它完成很多功能，比如admin用户的control panel功能，这样方便了我们定制功能。</p><p>更多内容，查看官方文文档： <a href="http://docs.jinkan.org/docs/flask/blueprints.html" target="_blank" rel="external">http://docs.jinkan.org/docs/flask/blueprints.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> dev-in-test </tag>
            
            <tag> 开发个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Web开发] Flask+Python 开发个人博客（二）</title>
      <link href="/2017/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5BWeb%E5%BC%80%E5%8F%91%5D%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2017/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5BWeb%E5%BC%80%E5%8F%91%5D%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Flask打造个人博客系列,今天是第一篇，我们详细讲解登录，注册模块。</p><a id="more"></a><p>旧文一篇：<br><a href="https://helloqa.com/2018/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/[Web%E5%BC%80%E5%8F%91]%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">[web开发] Flask+Python开发个人博客（一）</a></p><p>既然是Flask来开发，你得:</p><ol><li><p>安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Flask</div></pre></td></tr></table></figure></li><li><p>实现最简单的一个hello word：<br>views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello World!"</span></div></pre></td></tr></table></figure><p>run.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app.run(debug=<span class="keyword">True</span>)</div></pre></td></tr></table></figure><p>在terminal里输入python run.py, 现在在浏览器打开<a href="http://127.0.0.1:5000" target="_blank" rel="external">http://127.0.0.1:5000</a>, 看看发生了什么？：）</p></li></ol><p>很简单吧？貌似第2部分点陌生：<br>@app.route是什么鬼？它正是用于在Flask应用中给视图函数设定路由URL的装饰器。一头雾水？装饰器是什么？ WTF？<br><blockquote><p>Python装饰器让我们可以用其他函数包装特定函数。 当一个函数被一个装饰器”装饰”时，那个装饰器会被调用，接着会做额外的工作，修改变量，调用原来的那个函数.</p></blockquote><br>视图， 路由又是啥玩意，简单解释下：<br><blockquote><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（二）/1.png" alt=""></p></blockquote><br>上面的@app.route就等价于图中的Routes部分。@app.route（’/‘）就是注册了一个路由（注册路由就是建立URL规则和处理函数之间的关联。Flask框架依赖于路由 完成HTTP请求的分发）。这样当你访问“/”这个path的时候，python就自动把要它联系到hello（）这个function上，controller处理完后就会返还给你。</p><p>现在我们知道了，视图函数hello既然可以返回hello word， 那么我们也可以定义其他视图函数来返回注册和登录页面。<br>代码示意如下：<br>views.py<br><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（二）/2.png" alt=""></p><p>views.py这段代码作用就是你在url里输入 “127.0.0.1:5000/login后，flask会找到login对应的函数，处理后返回login.html中的内容。那么， login.html 里有哪些内容呢？<br>templates/login.html<br><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（二）/3.png" alt=""><br>HTML我们都会写一点, 但是{}是什么符号起什么作用呢？<br>因为Python直接写html太麻烦，于是Flask 内置了 Jinja2 模板引擎，帮你更方便的写html。你可以在这个模板里使用变量或者表达式，当这个页面显示的时候，变量或者表达式的值就会填充到你HTML页面相应的部分，这个变量或者表达式的值是从哪里取来的呢？当然是从你flask程序里.<br>一般Flask 会在 templates 文件夹里寻找模板。所以，你只需要用HTML写两个页面login.html 和signup.html，然后放到根目录下的templates文件夹下就可以了。flask会自己找到这两个页面并渲染。</p><p>下面简述下如何使用inja2模板来写html页面.<br>1.安装： <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Jinja2 </div></pre></td></tr></table></figure>2.使用：如上的HTML。 介绍两个常用的变量标志符：{% ... %} for Statements，例如上文的for循环语句。{{ ... }} for Expressions to print to the template output， 例如上文的{{ form.username }}，{{ form.password }}.我们知道登录的时候，需要输入用户名和密码，点击登录按钮，这个通常放到表单里来做，那么点击登录会发生什么呢？表单里用户名和密码的内容会提交到程序后端处理，对于Flask来说，它使用Flask-WTF来自动化表单的操作， 我们来看看如何处理表单：1. 安装<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Flask-WTF </div></pre></td></tr></table></figure></p><ol><li>forms.py<br><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（二）/4.png" alt=""><br>表单定义好后，需要配合视图使用， 也就是我们在views.py的文件头里，加上：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> forum_app.forms <span class="keyword">import</span> LoginForm </div></pre></td></tr></table></figure>这样你在浏览器里输入 http://127.0.0.1:5000/login，就会转到login页面，输入用户名密码，提交，就会走login这个视图函数的逻辑了。现在再回去看下views.py，你会发现<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get_member_id_by_username（username） </div></pre></td></tr></table></figure>这个是什么呢？就是后端的代码逻辑了，此处为了从数据库里根据用户名找到用户id。这个需要用到SQLAlchemy这个库，我之前写过相关的文章，点击这里查看SQLAlchemy用法。</li></ol><p>通过这种方法Jinja2 用来写前端页面templates， Views用来处理url绑定和视图，wtf-forms用来简化表单操作，Flask就这样实现了一个简单的注册登录。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> dev-in-test </tag>
            
            <tag> 开发个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[web开发] Flask+Python开发个人博客（一）</title>
      <link href="/2017/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5BWeb%E5%BC%80%E5%8F%91%5D%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/12/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%5BWeb%E5%BC%80%E5%8F%91%5D%20Flask+Python%20%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>纯flask实现的一个blog。</p><a id="more"></a><p>网站的整体效果：<br>登录页面（也是首页）：<br><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/1.png" alt=""></p><p>注册页面:</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/2.png" alt=""></p><p>这两个页面都实现了基本的验证，比如：<br>用户名密码为空</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/3.png" alt=""></p><p>密码不正确：</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/4.png" alt=""></p><p>正确登录后会跳转到系统主页面，长下面的样子：</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/5.png" alt=""></p><p>页面模块：</p><ul><li>Header</li><li>Footer</li><li>文章模块<br>点击主页上的模块，或者在任何文章的类别上点击，会进入下面的两个页面：<br>一个是列在Header上的类别，类别选中会高亮。：</li></ul><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/6.png" alt=""></p><p>一个是未列在Header上的类别，无高亮：</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/7.png" alt=""></p><ul><li>文章分类tag</li></ul><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/8.png" alt=""></p><ul><li>分页模块</li></ul><p>参考了Flask上的分页，加上用了Bootstrap的样式</p><ul><li>新建/修改/删除 文章模块。</li></ul><p>用了CK Editor，最好的编辑器之一。</p><p>新建：</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/9.png" alt=""> </p><p>修改：</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/10.png" alt=""> </p><p>删除：</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/11.png" alt=""> </p><ul><li>文章详页模块</li></ul><p>一个是对文章只有浏览权限，没有修改和删除按钮：</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/12.png" alt=""></p><p>一个是文章的作者或者Admin用户组的用户，对文章有full control权限</p><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/13.png" alt=""> </p><ul><li>权限控制模块（包括用户，权限，登录验证，管理员验证等）</li></ul><p><img src="/2017/12/05/测试开发系列/个人博客开发系列/[Web开发] Flask+Python 开发个人博客（一）/14.png" alt=""> </p><ul><li>项目配置（使用instance）</li></ul>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> dev-in-test </tag>
            
            <tag> 开发个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试往何处去 -- 新时期测试如何面对挑战</title>
      <link href="/2017/11/22/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%B5%8B%E8%AF%95%E5%BE%80%E4%BD%95%E5%A4%84%E5%8E%BB/"/>
      <url>/2017/11/22/%E6%B5%8B%E8%AF%95%E6%84%9F%E6%82%9F/%E6%B5%8B%E8%AF%95%E5%BE%80%E4%BD%95%E5%A4%84%E5%8E%BB/</url>
      
        <content type="html"><![CDATA[<p>本人一向务实，很少务虚，最近参与的讨论比较多，也有一些些感悟，分享给大家。<br>勉强算原创吧，标题起的比较大，恬不知耻，主要为了吸引更多从业人员参与讨论，请见谅。</p><a id="more"></a><p>软件测试从前些年的懵懂发展，大家摸着石头过河， 到大多高校设立软件测试专业， 再到近几年各种测试培训盛行，可谓学术与工程齐备，理论和实践并发展。<br>软件测试的进入门槛，也从真正零基础，各行各业拼命涌入，到现在的要求具备专业的计算机专业能力（包括不限于编程能力），软件测试在企业的受重视程度，特别是互联网行业，也从可有可无，到不可或缺。</p><p>随着近年来各行各业对软件的强需求，及大数据，云计算，AI的形成，发展， 各种开发模式被不断引进来解决开发中的问题，传统的瀑布模式几乎被淘汰殆尽，敏捷开发已成强弩之末，DevOps思想又从星星点火，到燎原之势。软件开发人员俨然超越了四个现代化，正寄语我们的征途是星辰大海。 但测试人员，还有很多处在石器时代，过着茹毛饮血，敲敲打打（点点点）的日子。</p><p><strong> 1. 软件测试的过去 </strong><br>远古时代的软件测试人员，严格遵守开发，测试，发布的瀑布流程，他们不知道，也不关心开发如何实现，严格按照需求说明书，来编写测试用例。等到开发把编译完成的版本送到他面前，他才慢条斯理的对着测试用例，一条条执行，看到跟期望结果不一致的地方，一股脑的当bug提上去， 根本不去想bug的出现原因，了不起把重现步骤，测试环境标记清楚。至于一个root cause提多个bug，按bug量论英雄，不在话下。</p><p><strong> 2. 软件测试的现在 </strong><br>大浪淘沙，现阶段的软件测试人员，大多认识到了测试及早介入的重要性，也有很多接受了敏捷思想，成了敏捷的脑残粉，特别在敏捷开发的项目中，他们大多主动的从需求分析中介入，努力提升软件的可测性，在Grooming大会，Planning大会上，发出测试的声音，让开发一开始就避免掉某些坑。在测试的形式上，不再拘泥于黑盒测试，把白盒测试，接口测试，性能测试，甚至静态代码分析，代码覆盖率测试也纳入测试的版图，测试在组织的话语权也越来越大。</p><p>对于有追求的测试来说，不再仅着眼于辅助开发保证软件的质量，他们把目光放到如何提升团队生产率，加快成功发布上，一系列的测试框架，代码build触发自动化测试，为其它测试提供测试工具，眼花缭乱，不胜枚举。<br>对于测试的先行者来说，他们关注测试人员这个职位存在的必要性，为测试行业摇旗呐喊，在各种开发模式中，布道测试的作用。</p><p><strong> 3. 软件测试的挑战 </strong><br>直到现在，大部分的测试还具有如下鲜明特点：</p><ul><li>“提前测试”。 即测试人员在软件发布前测试，软件发布后很少再去测试，Live环境上的测试和监控属于Ops的范畴。</li><li>期望结果明确。 即测试人员在一个操作之前，已经提前知道这个操作的结果应该是什么。对于同样的输入，一定会有同样的期望结果。</li></ul><p>随着云计算，大数据，人工智能的发展，越来越多的公司把自身业务部署在云上，产品也越来越依赖大数据和人工智能。 加上智能设备的发展，可穿戴设备，甚至裸眼屏幕，将会越来越多，在这个大环境下， 提前测试就不那么适用了。<br>测试遇到的挑战也会越来越大，软件的复杂度进一步增加，”提前测试” 开始力不从心。 Test in Production 势在必行。</p><p>对于复杂的提供service的产品来说，例如搜索引擎， 仅仅依靠测试人员设计的测试用例，肯定只能覆盖真实用户的少部分使用情况， 大部分用户如何使用，测试人员无法设计出来。这个时候就需要Test in Production。<br>即便是某一个特定的功能点，同样的输入，在不同的时间段，也不能期望实际输出不发生变化。举例来说，你今天输入 “百度 股票价格” 和明天输入 “百度 股票价格”， 得到的结果可能也不同，这个时候，明确的期望结果，也变得不适用。 测试人员就要把检查的重点，从一个固定的结果转化为观察一个 ”模式/趋势“， 就是说，如果你的输出是 百度今天的股票价格， 或者百度股票的趋势，都是可以接受的，但是出来的结果，如果只有百度，没有股票，就是不对的。 </p><p>还有，如果你们的服务部署在阿里云，腾讯云上，你的测试方法能跟传统的一样吗？如果你的产品基于大数据智能调整哪些功能展现给哪些用户，你的常规测试方法还有用吗？如果你在测试一个人工智能产品，<br>你还能设计出用户常用的case吗？</p><p><strong> 4. 软件测试的未来 </strong><br>新形势下，测试应该怎么做呢？</p><ul><li>某个功能的输入数据，将从测试人员准备变成直接导入真实用户数据，采取例如A/B Test， 金丝雀发布的方式来进行。</li><li>测试的结果， 将不在关注具体的确定值，转为记录观察输出的趋势，或者行为模式，即Pattern。 </li></ul><p>这客观要求测试紧跟新的开发模式/思想， 以DevOps为例， DevOps天然强调持续集成，自动化部署，急速部署，多次部署，那么测试，就要在这个上面发力，部署自触发的自动化测试就必不可少，这样对测试的要求将会越来越高，测试对系统的介入程度，将会越来越深，最终测试即开发，开发即测试。<br>未来， 测试应该会 </p><ul><li>Test in Production（紧随DevOps，自动化比重会加大）。 </li><li>测试的检查重点，也会从期望的Test Results 转变为Observed Data/pattern。这个已发生，随着技术的发展，比重将会越来越大。</li><li>生产环境的监控比重将越来越大，甚至变成新常态。 </li></ul><p><strong> 5. 软件测试的机遇 </strong><br>近几年发生在软件开发业内的新思想，新方法，主要以开发人员为主导。那么是不是就意味着其它角色生存空间被压缩呢？我认为也是也不是，被压缩的是精益思想本来就要去掉的，所谓的”减少浪费“的浪费部分，<br>如那些 “测试人员自主设计的模拟用户行为的测试” 功能测试部分， 还有手工配置测试环境，及”快速交付给客户“过程中因为运维的原因被常常被堵塞的部分。</p><p>对于测试人员来说， 困难和机遇并存，新的技术/思想固然层出不穷，但不必戚戚然，一个产品要顺利交付给客户，必不可少要把住质量关，测试人员（我们现在常叫QA，质量保证人员）只需牢记任何思想的演进都是为了快速成功的交付这个原则，测试人员应该通过各种手段，为这个目标增加测试的价值。</p><p>测试人员应该牢记，你不仅仅是测试，你是整个产品团队的一部分，你对团队的整体效率负责，你存在的价值是帮助组织快速交付。</p><p>测试这个职位有可能会消失，但是每一个组织，每一个客户对软件质量的要求不仅不会消失，还会不断增强，这将会是测试人员最好的时代，是属于我们测试的改革开放，每一个测试人员都应该趁着行业东风，努力做这个伟大时代的弄潮儿！</p><p>参考资料：<br><a href="http://blog.csdn.net/zhubaitian/article/details/50203263" target="_blank" rel="external">http://blog.csdn.net/zhubaitian/article/details/50203263</a><br><a href="http://www.infoq.com/cn/articles/detail-analysis-of-devops" target="_blank" rel="external">http://www.infoq.com/cn/articles/detail-analysis-of-devops</a><br><a href="https://dojo.ministryoftesting.com/lessons/the-future-of-software-testing-part-one" target="_blank" rel="external">https://dojo.ministryoftesting.com/lessons/the-future-of-software-testing-part-one</a><br><a href="https://dojo.ministryoftesting.com/lessons/the-future-of-software-testing-part-two" target="_blank" rel="external">https://dojo.ministryoftesting.com/lessons/the-future-of-software-testing-part-two</a></p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python自动化测试--关于datetime的一点思考2</title>
      <link href="/2017/10/30/Python%E7%9F%A5%E8%AF%86/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95--%E5%85%B3%E4%BA%8Edatetime%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%832/"/>
      <url>/2017/10/30/Python%E7%9F%A5%E8%AF%86/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95--%E5%85%B3%E4%BA%8Edatetime%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%832/</url>
      
        <content type="html"><![CDATA[<p>还记得我们前面讲过的<a href="http://helloqa.com/2017/08/23/Python%E7%9F%A5%E8%AF%86/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95--%E5%85%B3%E4%BA%8Edatetime%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" target="_blank" rel="external">Python自动化测试–关于datetime的一点思考</a>吗？<br>我们使用pytz来处理时间，最后还自己实现了一个时间类来更好的处理现实问题，今天我们介绍一个更加方便的方式：<br><a id="more"></a></p><blockquote><p>Arrow: better dates and times for Python。</p></blockquote><p>1.安装<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#url http://arrow.readthedocs.io/en/latest/</span></div><div class="line">pip install arrow</div></pre></td></tr></table></figure></p><p>2.简单使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> arrow</div><div class="line">utc = arrow.utcnow()</div><div class="line">print(utc)</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T05:<span class="number">59</span>:<span class="number">06.678566</span>+<span class="number">00</span>:<span class="number">00</span></div><div class="line"></div><div class="line">utc = arrow.now()</div><div class="line">print(utc)</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T13:<span class="number">59</span>:<span class="number">06.678566</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line"></div></pre></td></tr></table></figure></p><p>可以看到，qrrow带有时区信息。 还记得我们上次讲过的datetime类型吗？ 由此可见，arrow的时间是time clock aware的。 跟datetime的 naive类型不一样。<br>那么，如果我们想得到navie类型的时间，该怎么做呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> arrow</div><div class="line">utc = arrow.utcnow().naive</div><div class="line">print(utc)</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span> <span class="number">14</span>:<span class="number">29</span>:<span class="number">22.418641</span></div><div class="line"></div></pre></td></tr></table></figure><p>3.其它常用方法<br><strong> arrow.get(x) </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> arrow</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">&gt; ** Create <span class="keyword">from</span> timestamps (ints <span class="keyword">or</span> floats, <span class="keyword">or</span> strings that convert to a float): **</div><div class="line">print(arrow.get(<span class="number">1499900664</span>))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-07</span><span class="number">-12</span>T23:<span class="number">04</span>:<span class="number">24</span>+<span class="number">00</span>:<span class="number">00</span></div><div class="line"></div><div class="line">&gt; ** Use a naive <span class="keyword">or</span> timezone-aware datetime, <span class="keyword">or</span> flexibly specify a timezone: **</div><div class="line">print(arrow.get(datetime.utcnow()))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T06:<span class="number">39</span>:<span class="number">42.114556</span>+<span class="number">00</span>:<span class="number">00</span>                                    </div><div class="line"></div><div class="line">print(arrow.get(datetime(<span class="number">2017</span>, <span class="number">10</span>, <span class="number">30</span>), tz.gettz(<span class="string">'US/Pacific'</span>)))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T00:<span class="number">00</span>:<span class="number">00</span><span class="number">-07</span>:<span class="number">00</span></div><div class="line"></div><div class="line">print(arrow.get(datetime.now(tz.gettz(<span class="string">'Asia/Shanghai'</span>))))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T14:<span class="number">45</span>:<span class="number">44.807080</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line"></div><div class="line">&gt; ** Parse <span class="keyword">from</span> a string: **</div><div class="line">print(arrow.get(<span class="string">'2017-10-30 12:30:45'</span>, <span class="string">'YYYY-MM-DD HH:mm:ss'</span>))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T12:<span class="number">30</span>:<span class="number">45</span>+<span class="number">00</span>:<span class="number">00</span></div><div class="line"></div><div class="line">&gt; ** Search a date <span class="keyword">in</span> a string: **</div><div class="line">print(arrow.get(<span class="string">'iTesting is awesome October 2017'</span>, <span class="string">'MMMM YYYY'</span>))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-01</span>T00:<span class="number">00</span>:<span class="number">00</span>+<span class="number">00</span>:<span class="number">00</span></div><div class="line">arrow还可以自动识别字符串中的时间信息，并转为时间，不过这个功能不强大，例如字符串中有特殊符号或多个空格就会失败</div><div class="line"></div></pre></td></tr></table></figure><p><strong> Properties </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">** Get a naive datetime, <span class="keyword">and</span> tzinfo **</div><div class="line"><span class="keyword">import</span> arrow</div><div class="line">a = arrow.now(<span class="string">'US/Pacific'</span>)</div><div class="line">print(a.tzinfo)</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;tzfile(<span class="string">'US/Pacific'</span>)</div></pre></td></tr></table></figure><p><strong> Get any datetime value: </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> arrow</div><div class="line">a = arrow.now(<span class="string">'US/Pacific'</span>)</div><div class="line">print(a.year)</div><div class="line">print(a.month)</div><div class="line">print(a.day)</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span></div><div class="line"><span class="number">10</span></div><div class="line"><span class="number">30</span></div></pre></td></tr></table></figure></p><p><strong> Call datetime functions that return properties: </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(a.date())</div><div class="line">print(a.time())</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span></div><div class="line"><span class="number">00</span>:<span class="number">34</span>:<span class="number">14.689940</span></div></pre></td></tr></table></figure><p><strong> Replace&amp;Shift </strong> 更改时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> arrow</div><div class="line">a = arrow.now()</div><div class="line">print(a)</div><div class="line">print(a.replace(hour=<span class="number">1</span>, minutes=<span class="number">30</span>))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T15:<span class="number">38</span>:<span class="number">28.064605</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line"><span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T02:<span class="number">08</span>:<span class="number">28.064605</span>+<span class="number">08</span>:<span class="number">00</span></div></pre></td></tr></table></figure><p><strong> Format </strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> arrow</div><div class="line">print(arrow.now().format(<span class="string">'YYYY-MM-DD HH:mm:ss ZZ'</span>))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">55</span> +<span class="number">08</span>:<span class="number">00</span></div></pre></td></tr></table></figure><p><strong> Convert </strong> 时间转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> arrow</div><div class="line">print(arrow.utcnow().to(<span class="string">'Asia/Shanghai'</span>))</div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-10</span><span class="number">-30</span>T15:<span class="number">42</span>:<span class="number">30.510084</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line"></div><div class="line"><span class="comment">#arrow还帮我们实现了daylight saving的自动转换：</span></div><div class="line">t1 = arrow.get(datetime(<span class="number">2017</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">59</span>), <span class="string">'US/Eastern'</span>)</div><div class="line">print(t1)</div><div class="line"></div><div class="line">t1 = arrow.get(datetime(<span class="number">2017</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">00</span>), <span class="string">'US/Eastern'</span>)</div><div class="line">print(t1)</div><div class="line"></div><div class="line"><span class="comment">#输出：</span></div><div class="line">&gt;<span class="number">2017</span><span class="number">-11</span><span class="number">-05</span>T01:<span class="number">59</span>:<span class="number">00</span><span class="number">-04</span>:<span class="number">00</span></div><div class="line"><span class="number">2017</span><span class="number">-11</span><span class="number">-05</span>T02:<span class="number">00</span>:<span class="number">00</span><span class="number">-05</span>:<span class="number">00</span></div><div class="line">可以看到，时区信息自动切换了， 这个就比pytz里的方法方便，不需要再把时间给normize了。</div><div class="line"></div></pre></td></tr></table></figure><p>以上就是arrow的大致用法，是不是比pytz要简单些？ 对应到我们前面的问题，如何判断t1==t2呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#t1, &lt;class 'datetime.datetime'&gt;， 时区Eastern time</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-22</span> <span class="number">08</span>:<span class="number">49</span>:<span class="number">38</span></div><div class="line"><span class="comment">#t2, &lt;class 'datetime.datetime'&gt;， 无时区信息 </span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">49</span>:<span class="number">38</span></div></pre></td></tr></table></figure></p><p>答案不言而喻：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> arrow</div><div class="line"></div><div class="line">naive_t1 = arrow.get(<span class="string">'2017-11-05 02:00:00'</span>).naive</div><div class="line">t1 = arrow.get(naive_t1, <span class="string">'US/Eastern'</span>)</div><div class="line">print(t1.to(<span class="string">'local'</span>))</div><div class="line"></div><div class="line">navie_t2 = arrow.get(<span class="string">'2017-11-05 15:00:00'</span>).naive</div><div class="line">t2 = arrow.get(navie_t2, <span class="string">'Asia/Shanghai'</span>)</div><div class="line"><span class="keyword">assert</span> t1== t2</div></pre></td></tr></table></figure></p><p>总结一下， arrow是一个非常优秀的关于时间处理的第三方库，有了它，你可以更高效的处理时间参数了！</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> datetime </tag>
            
            <tag> Arrow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QA如何做静态代码分析</title>
      <link href="/2017/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/QA%E5%A6%82%E4%BD%95%E5%81%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2017/09/27/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/QA%E5%A6%82%E4%BD%95%E5%81%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>及早的介入测试已经成为软件测试界的共识，对逼格较高的QA（别有用心的人才会争论QA！=测试，）来说，已经不满足从从需求分析介入项目开发过程了。<br>如果我们能掌握一门技术，当开发提交代码的一刹那，我就知道这次代码改动的质量如何，是不是引进了新的bug，哪行代码写的不好，哪个功能需要重构， 你觉得开发会不会对你<br>更加佩服呢？（蜜汁微笑）<br><a id="more"></a></p><p>如果你发现你家厨房地上有一摊水，你是选择拿抹布擦掉就完了呢还是寻找下哪里在漏水？</p><p>静态代码检查可以使得我们在代码提交的一刹那就发现项目中的潜在问题，今天我就来讲讲如何使用SonarQube做静态代码检查。<br>Why SonarQube?</p><blockquote><p>SonarQube provides the capability to not only show health of an application but also to highlight issues newly introduced.<br>With a Quality Gate in place, you can fix the leak and therefore improve code quality systematically.<br>Supports multiple programming languages (20+)<br>Centrialize quality with reports and gates<br>Continuous inspection and DevOps integration<br>Follow standards: MISRA, CERT, CWE, OWASP…<br>Large user groups: 80,000+ organizations</p></blockquote><p>1.安装<br>如果你的代码以java开发，你需要事先安装：<br>Java JDK 8<br>DB（SQL Server， MySQL， Oracle， PostgreSQL）， Sonar需要一个数据库来存储结果,Apache Derby 是Sonar自带并且默认安装使用的数据库,它能很好的用于Sonar的演示.但在实际项目中推荐使用性能更好更强大的数据库。</p><p>以我的项目Python为例，我略过过JDK 和DB（使用sonar默认）的安装，直接：<br>从这个<a href="https://www.sonarqube.org/downloads/" target="_blank" rel="external">页面</a>下载SonarQube server.<br>从这个<a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner" target="_blank" rel="external">页面</a>下载Sonar Scanner.<br>下载完毕后解压，在目标文件夹下的sonarqube-6.5\bin 目录下，根据你机器的系统选择文件夹打开，这里选择windows-x86-64， 看到如下文件了吗？<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/sonar-bin.PNG" alt=""><br>依次以管理员身份运行前3个bat命令，然后通过web打开页面<a href="http://localhost:9000，" target="_blank" rel="external">http://localhost:9000，</a> 如果你看到了下述页面，说明安装成功：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/installsuccess.PNG" alt=""></p><p>2.配置<br>由于我使用默认的db，故略过DB配置部分，直接来看基本配置：<br>首先，点击右上角的Login， 使用默认密码，admin， admin登录， 系统引导你生成一个新的project：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/install1.png" alt=""><br>其次，看右边的提示，系统会让你去下载并安装配置sonarQube Scanner.<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/install2.png" alt=""><br>我们前面已经安装了，略过安装，直接配置，把scanner的bin目录加入你的环境变量：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/3scanner-config.png" alt=""><br>在scanner的bin目录下， 打开sonar-scanner.properties并配置如下：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/scanner2.PNG" alt=""><br>然后CMD命令执行 sonar-scanner， 你会看到：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/scanner1.PNG" alt=""><br>这样就说明 scanner配置成功了，我们来分析下我们的项目把！</p><p>3.使用<br>找到你要scann的项目目录的code repository，在根目录下建立并更新 <strong>sonar-project.properties</strong> 文件：<br>举例来说，我有一个ASD_API的项目，我在这个项目根目录下建立文件并修改如下：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/config.PNG" alt=""><br>需要注意的是projectName就是显示在网页上的项目，一般跟你的项目名称一致。<br>sources就是项目所在的文件夹。<br>其它按提示。</p><p>最后CMD, <strong>定位到你项目所在的文件夹</strong> ，在命令行中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sonar-scanner</div></pre></td></tr></table></figure><br>成功后你会看到：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/scanresults.PNG" alt=""></p><p>此时切换到 <a href="http://localost:9000" target="_blank" rel="external">http://localost:9000</a>, 你将会看到：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/results1.PNG" alt=""><br>可以看出来，此次代码改动是passed的，代码的Reliability， Security， Maintainability都很好，质量还不错嘛～ 我们点击项目名称ASD_API查看详细信息。<br>细节处有魔鬼呀，看来此次改动还有不少问题，主要集中在code smell上：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/results2.PNG" alt=""><br>从图中可以看出技术债务需要偿还，大约会花费1小时左右，另外还有21处不符合代码规范的地方，我们点击debt看细节：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/results3.PNG" alt=""><br>SonarQube贴心的列出来了需要改动的地方，高亮显示并给出了修改建议：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/results4.PNG" alt=""><br>点击我标红的部分，可以看到详细需要改动的地方，有一个分支我没有写完：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/results5.PNG" alt=""></p><p>如果代码质量太差，你会看到：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/fail.PNG" alt=""></p><p>想象一下，你直接告诉开发，你某个文件的某一行写的简直像个粑粑，他看后大呼，原来刘项也读书呀！是不是非常刺激？是不是非常惊喜？<br>根据Sonar Scanner的扫描结果，依次review每次code change，是不是感觉对质量的把控更加有自信了?</p><p>SonarQube可以从以下几个维度来分析代码质量：<br><img src="/2017/09/27/自动化测试系列/QA如何做静态代码分析/metrics.PNG" alt=""></p><p>我们可以根据SonarQube 扫描出来的结果，结合项目实际，建议开发修改. 如果你们的项目跟jenkins集成，还可以添加SonarQube插件，这样每一个build生成后都会有相应的代码分析结果参考。<br>利用SonarQube进行静态代码分析， 真正做到了从源头解决问题，也使得我们测试人员对代码改动更有信心，怎么样？ 赶快用起来吧！</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code-analysis </tag>
            
            <tag> white box </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python自动化测试--关于datetime的一点思考</title>
      <link href="/2017/08/23/Python%E7%9F%A5%E8%AF%86/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95--%E5%85%B3%E4%BA%8Edatetime%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
      <url>/2017/08/23/Python%E7%9F%A5%E8%AF%86/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95--%E5%85%B3%E4%BA%8Edatetime%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>在测试自动化特别是API测试当中，经常遇见这样的case，一个API的返回值是另外一个API的入参，虽然入参和返回值都是一个时间，但入参是datetime类型的变量，返回值是个str类型的变量。 那么如何处理这些时间变量呢？如果这些时间变量跟时区， 夏令时结合在一起时候，如何处理呢？</p><a id="more"></a><p>在我的测试过程中，我遇见这样一个问题<br>1.一个页面的Book API需要传入一个课的开始时间，这个时间格式要求是string，例如”2017-08-22 08:49:38”<br>2.Book成功后的返回值包含了一个字典，其中包含时间，也是string格式，但是这个值带时区属性，例如 “starttime_est”:”2017-08-22 08:49:38”.<br>3.另外一个显示已定课的booked API，也包含一个string格式的时间，但是不带时区信息，默认是local time， 格式如下：”2017-08-22 20:49:38”<br>那么我现在定了一节eastern的开始时间是”2017-08-22 08:49:38”的课，我页面上看到的是”2017-08-22 20:49:38”, 我如何来验证这节课就是我定的课呢？</p><p>Python中对时间的处理，我们一般用datetime模块，datetime对于string和datetime的转换，我们一般用strptime， strftime来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="comment">#类型&lt;class 'datetime.datetime'&gt;， 时区Eastern time</span></div><div class="line">t1 = datetime.now()  <span class="comment"># 这里假设我们当前时间是Eastern time的2017-08-22 08:49:38</span></div><div class="line"></div><div class="line"><span class="comment">#类型&lt;class 'str'&gt;</span></div><div class="line">t2 = <span class="string">"2017-08-22 20:49:38"</span></div><div class="line"></div><div class="line"><span class="comment">#由日期格式转化为字符串格式</span></div><div class="line">t1.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"></div><div class="line"><span class="comment">#由字符串格式转换为日期格式</span></div><div class="line">datetime.strptime(t2, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line"></div></pre></td></tr></table></figure><p>其中，时间格式定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># datetime. strftime (format)  </div><div class="line"></div><div class="line"># %a   星期的简写。如 星期三为Web  </div><div class="line"># %A   星期的全写。如 星期三为Wednesday  </div><div class="line"># %b   月份的简写。如4月份为Apr  </div><div class="line"># %B   月份的全写。如4月份为April   </div><div class="line"># %c:  日期时间的字符串表示。（如： 08/22/17 10:00:00 local：us）  </div><div class="line"># %d:  日在这个月中的天数（是这个月的第几天）  </div><div class="line"># %f:  微秒（范围[0,999999]）  </div><div class="line"># %H:  小时（24小时制，[0, 23]）  </div><div class="line"># %I:  小时（12小时制，[0, 11]）  </div><div class="line"># %j:  日在年中的天数 [001,366]（是当年的第几天）  </div><div class="line"># %m:  月份（[01,12]）  </div><div class="line"># %M:  分钟（[00,59]）  </div><div class="line"># %p:  AM或者PM  </div><div class="line"># %S:  秒（范围为[00,61]）  </div><div class="line"># %U:  周在当年的周数当年的第几周），星期天作为周的第一天  </div><div class="line"># %w:  今天在这周的天数，范围为[0, 6]，6表示星期天  </div><div class="line"># %W:  周在当年的周数（是当年的第几周），星期一作为周的第一天  </div><div class="line"># %x:  日期字符串（如：08/22/17）  </div><div class="line"># %X:  时间字符串（如：10:00:00  </div><div class="line"># %y:  2个数字表示的年份  </div><div class="line"># %Y:  4个数字表示的年份  </div><div class="line"># %z:  与utc时间的间隔 （如果是本地时间，返回空字符串）  </div><div class="line"># %Z:  时区名称（如果是本地时间，返回空字符串）  </div><div class="line"></div></pre></td></tr></table></figure><p>看起来很简单嘛，字符串类型的t2直接用strptime就转换成时间了呀，等等，t1本来是等于t2的，这样转换后t1和t2分别为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#t1, &lt;class 'datetime.datetime'&gt;， 时区Eastern time</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-22</span> <span class="number">08</span>:<span class="number">49</span>:<span class="number">38</span></div><div class="line"><span class="comment">#t2, &lt;class 'datetime.datetime'&gt;， 无时区信息 </span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">49</span>:<span class="number">38</span></div></pre></td></tr></table></figure></p><p>assert t1==t2的结果是False， 为什么呢？因为 t1是aware的时间， t2是naive的时间。 他们的详细区别如下：</p><blockquote><p>There are two kinds of date and time objects: “naive” and “aware”.</p><p>An aware object has sufficient knowledge of applicable algorithmic and political time adjustments, such as time zone and daylight saving time information, to locate itself relative to other aware objects. An aware object is used to represent a specific moment in time that is not open to interpretation</p><p>A naive object does not contain enough information to unambiguously locate itself relative to other date/time objects. Whether a naive object represents Coordinated Universal Time (UTC), local time, or time in some other timezone is purely up to the program, just like it’s up to the program whether a particular number represents metres, miles, or mass. Naive objects are easy to understand and to work with, at the cost of ignoring some aspects of reality.</p></blockquote><p>很不幸运的是，datetime模块模式生成的是naive类型的datetime对象，例如now（），  utcnow（）。要想生成aware类型的，可以使用now()接受一个tzinfo对象来生成，但是标准库并不提供任何已实现的tzinfo类。 那么自己实现一个了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#注意，一个tzinfo类需要实现utcoffset、dst和tzname这3个方法</span></div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">tzinfo是关于时区信息的类</div><div class="line">tzinfo是一个抽象类，所以不能直接被实例化</div><div class="line">"""</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UTC</span><span class="params">(tzinfo)</span>:</span></div><div class="line">    <span class="string">"""UTC"""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,offset = <span class="number">0</span>)</span>:</span></div><div class="line">        self._offset = offset</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">utcoffset</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> timedelta(hours=self._offset)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tzname</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"UTC +%s"</span> % self._offset</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dst</span><span class="params">(self, dt)</span>:</span></div><div class="line">        <span class="keyword">return</span> timedelta(hours=self._offset)</div><div class="line"></div></pre></td></tr></table></figure><p>回到本题中来，我eastern time的时间就解决了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">t2 = datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">22</span>,<span class="number">8</span>,<span class="number">49</span>,<span class="number">38</span>, tzinfo=UTC(<span class="number">-5</span>))</div><div class="line"></div></pre></td></tr></table></figure><br>看似没毛病对不对？那是我们没考虑daylight saving啊！ 今天Eastern time跟UTC时间相差是-4，到夏令时结束时候，那么就是-5，再有，我国不实行夏令时，<br>有些国家只有某些地区用夏令时，有些不用。这样我传入的参数-5，-4，都是Eastern time，那我怎么知道这个offset是多少呢？再写个函数判断这些？要累死吧，说不定还写不出来。<br>这时候就需要巨人的肩膀了， pytz这个第3方库保证了时间的精准性和解决了daylight saving时间切换的问题， 来看看它怎么用。<br>1.安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#url https://pypi.python.org/pypi/pytz</span></div><div class="line">python setup.py install</div></pre></td></tr></table></figure><p>2.设定时区：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</div><div class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</div><div class="line"><span class="keyword">import</span> pytz</div><div class="line"></div><div class="line">   <span class="comment">#给定一个国家代码，拿到这个国家的时区列表</span></div><div class="line">print(pytz.country_timezones(<span class="string">'CN'</span>))</div><div class="line"><span class="comment">#选择一个时区</span></div><div class="line">   c = pytz.country_timezones(<span class="string">'CN'</span>)[<span class="number">0</span>]</div><div class="line"><span class="comment">#设定时区</span></div><div class="line">   tz = pytz.timezone(c)</div><div class="line">   print(tz)</div><div class="line"><span class="comment">#生成当前时区的时间，这个时间带时区信息</span></div><div class="line">   <span class="keyword">print</span> (datetime.now(tz))</div></pre></td></tr></table></figure><p>3.使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#设定正八时区</span></div><div class="line">    tz = pytz.timezone(pytz.country_timezones(<span class="string">'CN'</span>)[<span class="number">0</span>])</div><div class="line">    dt = datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">45</span>, tzinfo=tz)</div><div class="line"><span class="comment">#生成当前时区的时间，这个时间带时区信息</span></div><div class="line">    <span class="keyword">print</span> (dt)</div><div class="line"></div><div class="line"><span class="comment">#### 打印结果如下：</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">45</span>+<span class="number">08</span>:<span class="number">06</span></div></pre></td></tr></table></figure><p>大家发现问题了没有。默认的正八区，跟UTC的差距不是+8：00，而是+8：06， 这个是构造时区时没有使用naive的时间。pytz构造本地时间只支持两种方式,且都只能localize naive datetime：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</div><div class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</div><div class="line"><span class="keyword">import</span> pytz</div><div class="line">tz = pytz.timezone(pytz.country_timezones(<span class="string">'CN'</span>)[<span class="number">0</span>])</div><div class="line"><span class="comment">#方法1：</span></div><div class="line">local_dt = tz.localize(datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">22</span>,<span class="number">20</span>,<span class="number">45</span>,<span class="number">45</span>))</div><div class="line">print(local_dt)</div><div class="line"><span class="comment">#打印结果如下：</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">45</span>:<span class="number">45</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line"></div><div class="line"><span class="comment">#方法2：</span></div><div class="line">tz2 = timezone(<span class="string">"US/Eastern"</span>)</div><div class="line">eastern = local_dt.astimezone(tz2)</div><div class="line"><span class="keyword">print</span> (eastern)</div><div class="line"><span class="comment">#打印结果如下：</span></div><div class="line"><span class="number">2017</span><span class="number">-08</span><span class="number">-22</span> <span class="number">08</span>:<span class="number">45</span>:<span class="number">45</span><span class="number">-04</span>:<span class="number">00</span></div></pre></td></tr></table></figure></p><p>pytz建议我们处理时间一律用UTC的方式， 只有你需要看输出的结果时，才把它转为本地时间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pytz</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">print(datetime(<span class="number">2002</span>, <span class="number">10</span>, <span class="number">27</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, tzinfo=pytz.utc))</div><div class="line"></div></pre></td></tr></table></figure></p><p>4.要注意的问题：</p><p>如果你需要处理夏令时和时区的转换，pytz推荐我们使用normalize（）这个方法, 举例来说，东部时间2017-03-12 日凌晨2点是夏令时起效时间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pytz</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">eastern = pytz.timezone(<span class="string">'US/Eastern'</span>)</div><div class="line"></div><div class="line">dt4 = datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">00</span>)</div><div class="line">dt4 = eastern.localize(dt4)</div><div class="line"><span class="keyword">print</span> (dt4)</div><div class="line"><span class="keyword">print</span> (dt4.tzinfo)</div><div class="line"><span class="comment">#打印结果如下：</span></div><div class="line"><span class="number">2017</span><span class="number">-03</span><span class="number">-12</span> <span class="number">02</span>:<span class="number">00</span>:<span class="number">00</span><span class="number">-05</span>:<span class="number">00</span></div><div class="line">US/Eastern</div><div class="line"></div><div class="line">dt6 = eastern.normalize(dt4)</div><div class="line"><span class="keyword">print</span> (dt6)</div><div class="line"><span class="keyword">print</span> (dt6.tzinfo)</div><div class="line"><span class="comment">#打印结果如下：</span></div><div class="line"><span class="number">2017</span><span class="number">-03</span><span class="number">-12</span> <span class="number">03</span>:<span class="number">00</span>:<span class="number">00</span><span class="number">-04</span>:<span class="number">00</span></div><div class="line">US/Eastern</div><div class="line"></div><div class="line">可以看到，如果不用normalize（），到夏令时起效时，不会自动帮我们转换时间。</div><div class="line"></div><div class="line">如果把dt4的值改为dt4 = datetime(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">00</span>)</div><div class="line">那么<span class="number">2</span>此的结果一致，均为 <span class="number">2017</span><span class="number">-03</span><span class="number">-12</span> <span class="number">03</span>:<span class="number">00</span>:<span class="number">00</span><span class="number">-04</span>:<span class="number">00</span></div></pre></td></tr></table></figure></p><p>到此，我们就掌握了对datetime的如下操作：<br>1.string 和datetime的转换  –strftime， strptime<br>2.时区的转换。 –timezone（tz）， tz.localize(dt)<br>3.夏令时的转换。 – tz.normalize(dt)</p><p>最后再来看看我们的问题如何解决：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line">tz1 = timezone(<span class="string">'US/Eastern'</span>)</div><div class="line"></div><div class="line">t1 =datetime(<span class="number">2017</span>,<span class="number">8</span>,<span class="number">22</span>,<span class="number">8</span>,<span class="number">49</span>,<span class="number">38</span>)</div><div class="line">t1 = tz1.localize(t1)</div><div class="line">print(t1)</div><div class="line"></div><div class="line">tz2 = timezone(<span class="string">'Asia/Shanghai'</span>)</div><div class="line">t2 = datetime.strptime(<span class="string">'2017-08-22 20:49:38'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</div><div class="line">t2 = tz2.localize(t2)</div><div class="line">print(t2)</div><div class="line"></div><div class="line"><span class="keyword">assert</span> t1==t2</div></pre></td></tr></table></figure></p><p>文章的最后，放出我自己封装的一个datetime处理类,以后处理datetime，直接使用即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#datetime_helper.py</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone</div><div class="line"><span class="keyword">import</span> pytz</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeZone</span>:</span></div><div class="line"></div><div class="line">    UTC = pytz.utc</div><div class="line">    Eastern = timezone(<span class="string">'US/Eastern'</span>)</div><div class="line">    ChinaZone = timezone(<span class="string">'Asia/Shanghai'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeHelper</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    There are two kinds of date and time objects: “naive” and “aware”.</div><div class="line"></div><div class="line">    An aware object has sufficient knowledge of applicable algorithmic and political time adjustments,</div><div class="line">    such as time zone and daylight saving time information</div><div class="line"></div><div class="line">    A naive object does not contain enough information to unambiguously locate</div><div class="line">    itself relative to other date/time objects.</div><div class="line">    Whether a naive object represents Coordinated Universal Time (UTC),</div><div class="line">    local time, or time in some other timezone is purely up to the program</div><div class="line"></div><div class="line">    """</div><div class="line"></div><div class="line">    Format = <span class="string">"%Y-%m-%d %H:%M:%S"</span></div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">utc_time</span><span class="params">(naive_dt)</span>:</span></div><div class="line">        dt = TimeZone.UTC.localize(naive_dt)</div><div class="line">        <span class="keyword">return</span> TimeZone.UTC.normalize(dt)</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eastern_time</span><span class="params">(naive_dt)</span>:</span></div><div class="line">        dt = TimeZone.Eastern.localize(naive_dt)</div><div class="line">        <span class="keyword">return</span> TimeZone.Eastern.normalize(dt)</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">china_time</span><span class="params">(naive_dt)</span>:</span></div><div class="line">        dt = TimeZone.ChinaZone.localize(naive_dt)</div><div class="line">        <span class="keyword">return</span> TimeZone.ChinaZone.normalize(dt)</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">switch_timezone</span><span class="params">(aware_dt, tz)</span>:</span></div><div class="line">        <span class="keyword">return</span> aware_dt.astimezone(tz)</div><div class="line"></div><div class="line"><span class="meta">    @staticmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dt_strf</span><span class="params">(dt, fmt=Format)</span>:</span></div><div class="line">        <span class="keyword">return</span> dt.strftime(fmt)</div><div class="line"></div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> datetime </tag>
            
            <tag> pytz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效组织自动化测试用例</title>
      <link href="/2017/07/06/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%BB%84%E7%BB%87%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
      <url>/2017/07/06/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%BB%84%E7%BB%87%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>自动化测试用例写多了，不可避免会遇到这个问题,每次运行无需运行所有的用例，那么如何把要运行的用例挑出来并高效组织它们呢？<br>一般说来，通用的做法都是<br><a id="more"></a><br>把要运行的用例用特殊标记Mark出来，然后框架运行时，自动寻找这些带标记的case，并把它们装到一个新的test suite里。<br>所以高效组织测试用例的关键就是两部分：</p><h5 id="1-如何标记待测试用例"><a href="#1-如何标记待测试用例" class="headerlink" title="1. 如何标记待测试用例."></a>1. 如何标记待测试用例.</h5><h5 id="2-运行时如何收集这些带标记的用例。"><a href="#2-运行时如何收集这些带标记的用例。" class="headerlink" title="2. 运行时如何收集这些带标记的用例。"></a>2. 运行时如何收集这些带标记的用例。</h5><p>以下列出来我经历过的方法：</p><h5 id="1-给所有的测试用例编号，把测试用例按照-编号，-summary，-Path，-ClassName，-测试运行与否的flag等等，写到一个外部文件里，通常是Excel，"><a href="#1-给所有的测试用例编号，把测试用例按照-编号，-summary，-Path，-ClassName，-测试运行与否的flag等等，写到一个外部文件里，通常是Excel，" class="headerlink" title="1.给所有的测试用例编号，把测试用例按照 编号， summary， Path， ClassName， 测试运行与否的flag等等，写到一个外部文件里，通常是Excel，"></a>1.给所有的测试用例编号，把测试用例按照 编号， summary， Path， ClassName， 测试运行与否的flag等等，写到一个外部文件里，通常是Excel，</h5><p>每次测试框架运行时，先去这个文件里，一行一行的读文件，如果发现“测试运行与否的flag”的值是True， 就把这条case拿出来放到一个临时变量里，读完整个文件，就拿到了<br>所有要运行的case， 这个时候，导入这个case需要的所有依赖，运行这个case，并把运行结果写回到一个results的文件里。 那么，改动老的case，增加新的case，怎么办呢？<br>勤快一点的，每写一个/更改一个自动化用例，手工更新这个外部表格。 懒一点的，写一段代码，每写/改一个case，手工运行这段代码，把更改写进去。</p><h5 id="2-利用装饰器，经典的如TestNG，可以在测试用例前加-BeforeSuite，-今天要讲的也是这个。如何在python里实现。"><a href="#2-利用装饰器，经典的如TestNG，可以在测试用例前加-BeforeSuite，-今天要讲的也是这个。如何在python里实现。" class="headerlink" title="2.利用装饰器，经典的如TestNG，可以在测试用例前加@BeforeSuite， 今天要讲的也是这个。如何在python里实现。"></a>2.利用装饰器，经典的如TestNG，可以在测试用例前加@BeforeSuite， 今天要讲的也是这个。如何在python里实现。</h5><p>先说下思想： 我期望自动化测试运行时候，可以根据我提供的不同的tag，运行不同的测试用例。 前提是我写自动化用例的时需给每个测试用例，都加上tag并赋值。<br>在运行时候，框架通过我提供的不同的tag，去找这些被标记的case，然后组织起来运行。</p><p>要实现这个，我们需要接收用户参数，可以用：</p><h5 id="1-sys-argv-1-来自己写代码处理，也可以用标准库argparse来，我们用后者。"><a href="#1-sys-argv-1-来自己写代码处理，也可以用标准库argparse来，我们用后者。" class="headerlink" title="1.sys.argv[1:]来自己写代码处理，也可以用标准库argparse来，我们用后者。"></a>1.sys.argv[1:]来自己写代码处理，也可以用标准库argparse来，我们用后者。</h5><p>argparse 的用法很直观, 先看段代码：：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span> 先创建一个parser： </div><div class="line">parser = argparse.ArgumentParser(prog=<span class="string">'para'</span>)</div><div class="line"><span class="number">2.</span> 加入一些参数：</div><div class="line">parser.add_argument(<span class="string">'-w'</span>, action=<span class="string">'store'</span>, default=<span class="string">'.'</span>, help=<span class="string">'specify the work space'</span>)</div><div class="line">parser.add_argument(<span class="string">'-target'</span>, action=<span class="string">'store'</span>, help=<span class="string">'specify the run target file'</span>)</div><div class="line">parser.add_argument(<span class="string">'-tag'</span>, action=<span class="string">'store'</span>, help=<span class="string">'run by tag'</span>)</div><div class="line">parser.add_argument(<span class="string">'-n'</span>, action=<span class="string">'store'</span>, help=<span class="string">'concurrent user'</span>)</div><div class="line"><span class="number">3.</span> Parseing 这些参数</div><div class="line">options = parser.parse_args()</div><div class="line"><span class="keyword">print</span> （options）</div></pre></td></tr></table></figure><p>这个时候，如在command line里输入<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python __init__.py -target test -tag smoke -n <span class="number">3</span> </div></pre></td></tr></table></figure>就会得到如下结果：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">Namespace(n=<span class="string">'3'</span>, tag=<span class="string">'smoke'</span>, target=<span class="string">'test'</span>, w=<span class="string">'.'</span>)</div></pre></td></tr></table></figure><br>使用argparse就可以方便的获取用户参数，并处理。关于argparse的用法，请参考官网。</p><h5 id="2-用户输入的参数我们接收处理了-那么如何处理这些tag呢，这就要用到装饰器："><a href="#2-用户输入的参数我们接收处理了-那么如何处理这些tag呢，这就要用到装饰器：" class="headerlink" title="2.用户输入的参数我们接收处理了,那么如何处理这些tag呢，这就要用到装饰器："></a>2.用户输入的参数我们接收处理了,那么如何处理这些tag呢，这就要用到装饰器：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">TestCase</span><span class="params">(enabled=True, tags=None, **kwargs)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tracer</span><span class="params">(cls)</span>:</span></div><div class="line">        cls.__type__ = <span class="string">'Test'</span></div><div class="line">        cls.__enabled__ = enabled</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tags:</div><div class="line">            cls.__tags__ = <span class="keyword">None</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">                <span class="comment"># 想想看，如果tag有好几个，这块代码应该怎么改</span></div><div class="line">                cls.__tags__ = tags</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line">    <span class="keyword">return</span> tracer</div></pre></td></tr></table></figure><p>上面的代码呢，我们定义了一个装饰器，这个装饰器唯一的作用，是接收传入的类，然后给这些类增加一些属性，这些属性后续用来判断是否要执行。 使用时在新建立测试类上加上@Testcase即可。</p><h5 id="3-测试用例类，这些测试类或者测试类中的函数实现了一个个的功能。"><a href="#3-测试用例类，这些测试类或者测试类中的函数实现了一个个的功能。" class="headerlink" title="3.测试用例类，这些测试类或者测试类中的函数实现了一个个的功能。"></a>3.测试用例类，这些测试类或者测试类中的函数实现了一个个的功能。</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealTest</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">    @TestCase(tags='smoke')</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></div><div class="line">        logging.info(<span class="string">"this is test 1"</span>)</div><div class="line">        time.sleep(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="meta">    @TestCase(enabled=True, tags='smoke')</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(self)</span>:</span></div><div class="line">        logging.info(<span class="string">"this is test2"</span>)</div><div class="line">        time.sleep(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="meta">    @TestCase(enabled=False, tags='smoke')</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">(self)</span>:</span></div><div class="line">        logging.info(<span class="string">"this is test3"</span>)</div><div class="line">        time.sleep(<span class="number">5</span>)</div></pre></td></tr></table></figure><p>我们可以利用装饰器里的tag参数， enable参数来实现测试用例的筛选。</p><h5 id="4-我们再定义一个类，这个类作为一个test-case的执行器，把要运行的测试用例装进来，并发，或者顺序执行。"><a href="#4-我们再定义一个类，这个类作为一个test-case的执行器，把要运行的测试用例装进来，并发，或者顺序执行。" class="headerlink" title="4.我们再定义一个类，这个类作为一个test case的执行器，把要运行的测试用例装进来，并发，或者顺序执行。"></a>4.我们再定义一个类，这个类作为一个test case的执行器，把要运行的测试用例装进来，并发，或者顺序执行。</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cls, worker)</span>:</span></div><div class="line">         threading.Thread.__init__(self)</div><div class="line">         self.cls = cls</div><div class="line">         self.workers = worker</div><div class="line">         self._lock = threading.RLock()</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">         self.workers.acquire()</div><div class="line">         logging.info(<span class="string">"Thread &#123;threadname&#125;"</span>.format(threadname=self.current_executor()))</div><div class="line">         self.cls(self)</div><div class="line">         self.workers.release()</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">current_executor</span><span class="params">(self)</span>:</span></div><div class="line">         <span class="keyword">return</span> threading.current_thread()</div></pre></td></tr></table></figure><h5 id="5-利用threading-Semaphore实现线程并发限制。"><a href="#5-利用threading-Semaphore实现线程并发限制。" class="headerlink" title="5.利用threading.Semaphore实现线程并发限制。"></a>5.利用threading.Semaphore实现线程并发限制。</h5><h5 id="6-实现："><a href="#6-实现：" class="headerlink" title="6.实现："></a>6.实现：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> argparse</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> logging</div><div class="line"></div><div class="line">logging.basicConfig(level=logging.INFO , format=<span class="string">'%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">TestCase</span><span class="params">(enabled=True, tags=None, **kwargs)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tracer</span><span class="params">(cls)</span>:</span></div><div class="line">        cls.__type__ = <span class="string">'Test'</span></div><div class="line">        cls.__enabled__ = enabled</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> tags:</div><div class="line">            cls.__tags__ = <span class="keyword">None</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">                <span class="comment"># 想想看，如果tag有好几个，这块代码应该怎么改</span></div><div class="line">                cls.__tags__ = tags</div><div class="line">        <span class="keyword">return</span> cls</div><div class="line">    <span class="keyword">return</span> tracer</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cls, worker)</span>:</span></div><div class="line">         threading.Thread.__init__(self)</div><div class="line">         self.cls = cls</div><div class="line">         self.workers = worker</div><div class="line">         self._lock = threading.RLock()</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">         self.workers.acquire()</div><div class="line">         logging.info(<span class="string">"Thread &#123;threadname&#125;"</span>.format(threadname=self.current_executor()))</div><div class="line">         self.cls(self)</div><div class="line">         self.workers.release()</div><div class="line"></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">current_executor</span><span class="params">(self)</span>:</span></div><div class="line">         <span class="keyword">return</span> threading.current_thread()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealTest</span><span class="params">()</span>:</span></div><div class="line"><span class="meta">    @TestCase(tags='smoke')</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></div><div class="line">        logging.info(<span class="string">"this is test 1"</span>)</div><div class="line">        time.sleep(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="meta">    @TestCase(enabled=True, tags='smoke')</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(self)</span>:</span></div><div class="line">        logging.info(<span class="string">"this is test2"</span>)</div><div class="line">        time.sleep(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="meta">    @TestCase(enabled=True, tags='smoke')</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">(self)</span>:</span></div><div class="line">        logging.info(<span class="string">"this is test3"</span>)</div><div class="line">        time.sleep(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    s = threading.Semaphore(<span class="number">2</span>)</div><div class="line"></div><div class="line">    parser = argparse.ArgumentParser(prog=<span class="string">'para'</span>)</div><div class="line">    parser.add_argument(<span class="string">'-w'</span>, action=<span class="string">'store'</span>, default=<span class="string">'.'</span>, help=<span class="string">'specify the work space'</span>)</div><div class="line">    parser.add_argument(<span class="string">'-target'</span>, action=<span class="string">'store'</span>, help=<span class="string">'specify the run target file'</span>)</div><div class="line">    parser.add_argument(<span class="string">'-tag'</span>, action=<span class="string">'store'</span>, help=<span class="string">'run by tag'</span>)</div><div class="line">    parser.add_argument(<span class="string">'-n'</span>, action=<span class="string">'store'</span>, help=<span class="string">'concurrent user'</span>)</div><div class="line">    options = parser.parse_args()</div><div class="line"></div><div class="line">    real_cases = []</div><div class="line">    <span class="keyword">for</span> module_element <span class="keyword">in</span>  dir(RealTest):  </div><div class="line">        pre_test_class = getattr(RealTest,module_element) <span class="comment"># @Mark</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> options.tag:</div><div class="line">            <span class="keyword">if</span> hasattr(pre_test_class, <span class="string">"__type__"</span>) <span class="keyword">and</span> \</div><div class="line">                    hasattr(pre_test_class, <span class="string">"__enabled__"</span>) \</div><div class="line">                    <span class="keyword">and</span> pre_test_class.__enabled__\</div><div class="line">                    <span class="keyword">and</span> hasattr(pre_test_class, <span class="string">"__tags__"</span>)\</div><div class="line">                    <span class="keyword">and</span> pre_test_class.__tags__ \</div><div class="line">                    <span class="keyword">and</span> pre_test_class.__tags__.lower() == options.tag.lower():</div><div class="line">                real_cases.append(pre_test_class)</div><div class="line"></div><div class="line">    threads = []</div><div class="line"></div><div class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> real_cases:</div><div class="line">        threads.append(TestExecutor(item, s))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.start()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</div><div class="line">        t.join()</div><div class="line"></div></pre></td></tr></table></figure><p>这里重点讲下标记为 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#@Mark </div></pre></td></tr></table></figure>的语句，实际上这个就是如何把标记的case挑选出来的核心方法。<br>我们使用了反射机制</p><blockquote><p>反射： 有时候我们会碰到这样的需求，需要执行对象的某个方法，或是需要对对象的某个字段赋值，而方法名或是字段名在编码代码时并不能确定，需要通过参数传递字符串的形式输入。举个具体的例子：当我们需要实现一个通用的DBM框架时，可能需要对数据对象的字段赋值，但我们无法预知用到这个框架的数据对象都有些什么字段，换言之，我们在写框架的时候需要通过某种机制访问未知的属性。这个机制被称为反射（反过来让对象告诉我们他是什么），或是自省</p><p>dir([obj]):<br>调用这个方法将返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。</p><p>hasattr(obj, attr):<br>这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。</p><p>getattr(obj, attr):<br>调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为’bar’，则返回obj.bar。</p></blockquote><p>对于所有的测试类，我们会逐个把他们导入（示例里无这段代码，关于case class的导入可以根据 -target这个参数的值来代码实现，此处未展示。）<br>对于每一个类，我们通过dir（）， getattr（）拿到测试类所有的可用方法，然后这些方法因为有装饰器TestCase的加持，我们可以顺利的根据参数-tags拿到要运行的测试用例。<br>然后我们根据拿到的每一个测试用例,判断它们是否有需要的属性（ <strong>enabled</strong>，<strong>type</strong>）， 然后对于每个有这个属性的用例，我们在放到真正运行的测试用例list里。<br>最后对测试用例list的用例，每一个都放入TestExecutor里执行，TestExecutor 实现了多线程及多线程限制。</p><p>我们来看下运行效果：<br>输入：<br>python Android/<strong>init</strong>.py -target test -tag smoke -n 3<br>输出：<br>因为我们限制了并发线程数为2， 所以我们先看到以下输出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Namespace(n=<span class="string">'3'</span>, tag=<span class="string">'smoke'</span>, target=<span class="string">'test'</span>, w=<span class="string">'.'</span>)</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-07</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">25</span>,<span class="number">009</span> - __init__.py[line:<span class="number">31</span>] - INFO: Thread &lt;TestExecutor(Thread<span class="number">-1</span>, started <span class="number">11284</span>)&gt;</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-07</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">25</span>,<span class="number">009</span> - __init__.py[line:<span class="number">42</span>] - INFO: this <span class="keyword">is</span> test <span class="number">1</span></div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-07</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">25</span>,<span class="number">009</span> - __init__.py[line:<span class="number">31</span>] - INFO: Thread &lt;TestExecutor(Thread<span class="number">-2</span>, started <span class="number">10196</span>)&gt;</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-07</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">25</span>,<span class="number">010</span> - __init__.py[line:<span class="number">47</span>] - INFO: this <span class="keyword">is</span> test2</div></pre></td></tr></table></figure><br>5秒后，又看到如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-07</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">30</span>,<span class="number">010</span> - __init__.py[line:<span class="number">31</span>] - INFO: Thread &lt;TestExecutor(Thread<span class="number">-3</span>, started <span class="number">14156</span>)&gt;</div><div class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-07</span> <span class="number">20</span>:<span class="number">01</span>:<span class="number">30</span>,<span class="number">011</span> - __init__.py[line:<span class="number">52</span>] - INFO: this <span class="keyword">is</span> test3</div></pre></td></tr></table></figure></p><p>如此一来，我们仅需要写测试用例时，添加合适的tag，然后运行时用参数区分，就可以不修改代码的的情况下运行不同的case了。</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Appium自动化框架入门实践</title>
      <link href="/2017/06/14/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Appium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/06/14/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Appium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>如何在Windows上搭建Appium测试框架？<br><a id="more"></a></p><h5 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h5><ol><li>Download latest <a href="https://nodejs.org/dist/v6.10.0/" target="_blank" rel="external">node and npm</a> tools MSI (version &gt;= 6.0). The npm and nodejs paths should be in your PATH environment variable.</li><li>Open admin cmd prompt,  Run the command <strong> npm install -g appium </strong> which will install Appium from NPM</li><li>To start Appium, you can now simply run appium from the prompt.<br> 3.1 On Windows run Appium.exe as an administrator, or when running from source you need to run cmd as an administrator.<br> 3.2 You must supply the <strong> –no-reset </strong> or <strong> –full-reset </strong> flags for Android to work on Windows, all other flags are <a href="http://appium.io/slate/en/master/?python#server-flags" target="_blank" rel="external">here</a></li><li>Follow the directions below for setup for either Android or Windows app testing.<br> 4.1 Download the latest <a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">Java JDK</a>. Set <strong> ‘JAVA_HOME’ </strong> to be your JDK path. The bin in that directory should be added to your <strong> PATH </strong> variable.<br> 4.2 Install the <a href="http://developer.android.com/sdk/index.html" target="_blank" rel="external">Android SDK</a>. Set the <strong> ANDROID_HOME  </strong> environment variable to be your Android SDK path and add the tools and platform-tools folders to your PATH variable.<br> 4.3 To run tests on Windows, you will need to have the Android Emulator booted or an Android Device connected that is running an AVD with API Level 17 or greater. Then run Appium on the command line (via the appium command)<br> 4.4 Your test script should ensure that the <strong> platformVersion </strong> capability corresponds to the emulator or device version you are testing, and that the app capability is an absolute path to the .apk file of the Android app.</li><li>Install the Python client library <strong> pip install Appium-Python-Client </strong></li><li>Run a test from any Appium client.<br> 6.1 real device<br> 6.2 simulator–Genymotion</li></ol><h5 id="元素识别"><a href="#元素识别" class="headerlink" title="元素识别"></a>元素识别</h5><p>我们用真机来测试，windows平台上appium只有android配置项，首先打开appium， 配置如下：<br><img src="/2017/06/14/移动测试系列/Appium自动化框架入门实践/1.png" alt="Appium配置"></p><p>解释如下：<br>Application path: apk路径<br>Capabilities:<br>    automationName    Which automation engine to use    Appium (default) or Selendroid<br>    platformName    Which mobile OS platform to use    iOS, Android, or FirefoxOS<br>    platformVersion    Mobile OS version    e.g., 7.1, 4.4<br>    deviceName:   command line 运行 <strong> adb devices  </strong> 得到的结果。<br>    noReset    Don’t reset app state before this session. See here for more details    true, false<br>    fullReset    Perform a complete reset. See here for more details    true, false<br>注意，在windows平台上， fullreset 和noreset一定要选一个。</p><p>点击右上角的launch the appium node启动appium，点击inpect图标，等server起来后，在device上打开要测试的app。<br><img src="/2017/06/14/移动测试系列/Appium自动化框架入门实践/2.png" alt="Appium配置"></p><p>这个就列出来当前页面的各个元素，方便我们识别元素。 对于Android来说，android SDK 有个自带的ui automation viewer也同样可以用，打开来如下（同样要求连接设备）<br><img src="/2017/06/14/移动测试系列/Appium自动化框架入门实践/3.png" alt="Appium配置"></p><h5 id="元素识别-1"><a href="#元素识别-1" class="headerlink" title="元素识别"></a>元素识别</h5><p>对于mobile的元素识别，参看我之前文章：<br><a href="http://helloqa.com/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/UIAutomation%20Viewer%E5%AE%9A%E4%BD%8DAndroid%20APP%E5%85%83%E7%B4%A0/" target="_blank" rel="external">UIAutomation Viewer定位Android APP元素</a><br><a href="http://helloqa.com/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Android%20UiSelector%EF%BC%88%EF%BC%89%E7%B1%BB%E6%9D%A5%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0/" target="_blank" rel="external">利用Android UiSelector（）类来定位元素</a><br><a href="http://helloqa.com/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D/" target="_blank" rel="external">iOS自动化测试之元素定位</a></p><h5 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h5><p>我们以我司的一个app为例，测试下内容：<br>1.Launch app，输入错误的用户名和密码<br>2.点击登录<br>3.验证弹出错误对话框中的text为Username or password incorrect。示例如下：<br><img src="/2017/06/14/移动测试系列/Appium自动化框架入门实践/4.png" alt="app截屏"></p><p>保持上一步appium的配置，启动launch the appium node后， 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestAPP</span><span class="params">()</span>:</span></div><div class="line">    desired_caps = &#123;&#125;</div><div class="line">    desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></div><div class="line">    desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.0'</span></div><div class="line">    desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'a92e11aa'</span></div><div class="line">    desired_caps[<span class="string">'app'</span>] = <span class="string">r"D:/_Automation/Mobile_FrameWork/EvcMobile/apps/evc.apk"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, self.desired_caps)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_username_or_email</span><span class="params">(self, username)</span>:</span></div><div class="line">        time.sleep(<span class="number">10</span>)</div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/username']"</span>).click()</div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/username']"</span>).send_keys(username)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, password)</span>:</span></div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/password']"</span>).click()</div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/password']"</span>).send_keys(password)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click_login_button</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/login']"</span>).click()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    test = TestAPP()</div><div class="line">    test.set_username_or_email(<span class="string">"iTesting"</span>)</div><div class="line">    test.set_password(<span class="number">1</span>)</div><div class="line">    test.click_login_button()</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="keyword">print</span> (test.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/notificationText']"</span>).get_attribute(<span class="string">'text'</span>))</div><div class="line">    <span class="keyword">assert</span> test.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/notificationText']"</span>).get_attribute(<span class="string">'text'</span>) == <span class="string">"Username or password incorrect"</span></div></pre></td></tr></table></figure></p><p>正常运行，代码没有问题，appium自动化的第一步就算完成了。</p><h5 id="框架优化step-1-，分离测试代码和被测试app，-并添加测试框架unittest，："><a href="#框架优化step-1-，分离测试代码和被测试app，-并添加测试框架unittest，：" class="headerlink" title="框架优化step 1 ，分离测试代码和被测试app， 并添加测试框架unittest，："></a>框架优化step 1 ，分离测试代码和被测试app， 并添加测试框架unittest，：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> unittest</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EFAPP</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, driver)</span>:</span></div><div class="line">        self.browser = driver</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_username_or_email</span><span class="params">(self, username)</span>:</span></div><div class="line">        time.sleep(<span class="number">10</span>)</div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/username']"</span>).click()</div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/username']"</span>).send_keys(username)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, password)</span>:</span></div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/password']"</span>).click()</div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/password']"</span>).send_keys(password)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click_login_button</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/login']"</span>).click()</div><div class="line">        time.sleep(<span class="number">2</span>)</div><div class="line">        <span class="keyword">assert</span> self.browser.find_element_by_xpath(<span class="string">"//*[@resource-id='com.ef.evc2015:id/notificationText']"</span>).get_attribute(<span class="string">'text'</span>) == <span class="string">"Username or password incorrect"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EFAPPTests</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        desired_caps = &#123;&#125;</div><div class="line">        desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></div><div class="line">        desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.0'</span></div><div class="line">        desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'a92e11aa'</span></div><div class="line">        desired_caps[<span class="string">'app'</span>] = <span class="string">r"D:/_Automation/Mobile_FrameWork/EvcMobile/apps/evc.apk"</span></div><div class="line"></div><div class="line">        self.browser = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login_failure</span><span class="params">(self)</span>:</span></div><div class="line">        ef_app = EFAPP(self.browser)</div><div class="line">        ef_app.set_username_or_email(<span class="string">"iTesting"</span>)</div><div class="line">        ef_app.set_password(<span class="number">1</span>)</div><div class="line">        ef_app.click_login_button()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser.quit()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    suite = unittest.TestLoader().loadTestsFromTestCase(EFAPPTests)</div><div class="line">    unittest.TextTestRunner(verbosity=<span class="number">2</span>).run(suite)</div></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/2017/06/14/移动测试系列/Appium自动化框架入门实践/5.png" alt="运行结果"></p><p>看起来像大功告成了，不过还有一个问题，所有的待测元素全都写在方法内部，不利于管理和重用，每次xpath改动，都需要改动每个方法。</p><h5 id="框架优化step-2，-加入page-object模式。"><a href="#框架优化step-2，-加入page-object模式。" class="headerlink" title="框架优化step 2， 加入page_object模式。"></a>框架优化step 2， 加入page_object模式。</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> unittest</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</div><div class="line"><span class="keyword">from</span> DateTime <span class="keyword">import</span> DateTime</div><div class="line"><span class="keyword">from</span> assertpy <span class="keyword">import</span> assert_that</div><div class="line"><span class="keyword">from</span> page_objects <span class="keyword">import</span> PageObject, PageElement</div><div class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</div><div class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span><span class="params">(PageObject)</span>:</span></div><div class="line">    __metaclass__ = ABCMeta</div><div class="line"></div><div class="line">    WAIT_FOR_SCROLL_TIME = <span class="number">2</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, driver)</span>:</span></div><div class="line">        <span class="comment"># Don't change the variable name w. it's used by PageObject</span></div><div class="line">        self.w = driver</div><div class="line">        self.driver = driver</div><div class="line">        assert_that(self.has_loaded()).is_true()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_loaded</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self.is_target_page()</div><div class="line">        <span class="keyword">except</span> NoSuchElementException:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="comment"># This function will be implement by sub class</span></div><div class="line"><span class="meta">    @abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_target_page</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_element_displayed</span><span class="params">(self, by, value, timeout=<span class="number">60</span>)</span>:</span></div><div class="line">        <span class="keyword">return</span> WebDriverWait(self.driver, timeout).until(</div><div class="line">            <span class="keyword">lambda</span> driver: driver.find_element(by, value).is_displayed())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EFAPP</span><span class="params">(BasePage)</span>:</span></div><div class="line"></div><div class="line">    EMAIL_OR_USERNAME_TEXT_FIELD_XPATH =<span class="string">"//*[@resource-id='com.ef.evc2015:id/username']"</span></div><div class="line">    PASSWORD_TEXT_FIELD_XPATH = <span class="string">"//*[@resource-id='com.ef.evc2015:id/password']"</span></div><div class="line">    LOGIN_BUTTON_XPATH = <span class="string">"//*[@resource-id='com.ef.evc2015:id/login']"</span></div><div class="line">    LOGIN_ERROR_XPATH = <span class="string">"//*[@resource-id='com.ef.evc2015:id/notificationText']"</span></div><div class="line"></div><div class="line">    email_or_username_text_field = PageElement(xpath=EMAIL_OR_USERNAME_TEXT_FIELD_XPATH)</div><div class="line">    password_text_field = PageElement(xpath=PASSWORD_TEXT_FIELD_XPATH)</div><div class="line">    login_button = PageElement(xpath=LOGIN_BUTTON_XPATH)</div><div class="line">    error_message = PageElement(xpath=LOGIN_ERROR_XPATH)</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, driver)</span>:</span></div><div class="line">        BasePage.__init__(self, driver)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_target_page</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.is_element_displayed(By.XPATH, self.EMAIL_OR_USERNAME_TEXT_FIELD_XPATH)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_username_or_email</span><span class="params">(self, username)</span>:</span></div><div class="line">        self.email_or_username_text_field.click()</div><div class="line">        self.email_or_username_text_field.send_keys(username)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, password)</span>:</span></div><div class="line">        self.password_text_field.click()</div><div class="line">        self.password_text_field.send_keys(password)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">click_login_button</span><span class="params">(self)</span>:</span></div><div class="line">        self.login_button.click()</div><div class="line">        time.sleep(<span class="number">2</span>)</div><div class="line">        <span class="keyword">assert</span> self.error_message.get_attribute(<span class="string">'text'</span>) == <span class="string">"Username or password incorrect"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EFAPPTests</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        desired_caps = &#123;&#125;</div><div class="line">        desired_caps[<span class="string">'platformName'</span>] = <span class="string">'Android'</span></div><div class="line">        desired_caps[<span class="string">'platformVersion'</span>] = <span class="string">'5.0'</span></div><div class="line">        desired_caps[<span class="string">'deviceName'</span>] = <span class="string">'a92e11aa'</span></div><div class="line">        desired_caps[<span class="string">'app'</span>] = <span class="string">r"D:/_Automation/Mobile_FrameWork/EvcMobile/apps/evc.apk"</span></div><div class="line"></div><div class="line">        self.browser = webdriver.Remote(<span class="string">'http://localhost:4723/wd/hub'</span>, desired_caps)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_login_failure</span><span class="params">(self)</span>:</span></div><div class="line">        ef_app = EFAPP(self.browser)</div><div class="line">        ef_app.set_username_or_email(<span class="string">"iTesting"</span>)</div><div class="line">        ef_app.set_password(<span class="number">1</span>)</div><div class="line">        ef_app.click_login_button()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser.quit()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    suite = unittest.TestLoader().loadTestsFromTestCase(EFAPPTests)</div><div class="line">    unittest.TextTestRunner(verbosity=<span class="number">2</span>).run(suite)</div><div class="line"></div></pre></td></tr></table></figure><p>等等，是不是少了点什么？ 一旦你关闭了appium，所有的测试都会失败，</p><h5 id="框架优化step-3，-监测，启动，关闭appium。"><a href="#框架优化step-3，-监测，启动，关闭appium。" class="headerlink" title="框架优化step 3， 监测，启动，关闭appium。"></a>框架优化step 3， 监测，启动，关闭appium。</h5><p>在代码里添加如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppiumUtils</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment">#start adb</span></div><div class="line">        os.system(<span class="string">'taskkill /F /IM adb.exe'</span>)</div><div class="line">        os.system(<span class="string">'adb devices'</span>)</div><div class="line">        <span class="comment">#launch appium</span></div><div class="line">        os.system(<span class="string">'taskkill /F /IM node.exe'</span>)</div><div class="line">        command = <span class="string">''' start /b "" "&#123;node_exe_path&#125;" "&#123;appium_js_path&#125;" --address "&#123;server_ip&#125;" --port "&#123;port&#125;" --command-timeout "&#123;command_timeout&#125;" --platform-name "&#123;platform_name&#125;" --platform-version "&#123;platform_version&#125;" --device-name "&#123;device_name&#125;" --app "&#123;app&#125;" --no-reset --log-no-color &gt; "&#123;log_path&#125;" '''</span></div><div class="line">        os.system(<span class="string">"%s"</span> % command)</div><div class="line">        time.sleep(<span class="number">60</span>) <span class="comment"># wait appium start completely.</span></div></pre></td></tr></table></figure><br>这段代码目的是为了每次自动化开始时候，杀掉所有影响启动的appium服务，以确保每次appium都能正确启动，其中，大括号包起来的是你自己需要配置的各个配置项，最后一个sleep语句我简化了，其实可以动态判断appium有没有启动，这个不深入了。</p><p>改动EFAPPTests这个类，在setUp里添加如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EFAPPTests</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        AppiumUtils()</div><div class="line">。。。</div></pre></td></tr></table></figure></p><p>至此， 一个简单的appium测试框架就搭建成功了， 你还可以优化如下：</p><ol><li>所有配置项单独分开放到config.py 里， 比如device信息， apk信息等。</li><li>为每一个待测的case添加一个page，page里为所有这个页面测试需要用到的元素及方法。</li><li>利用unittest这个框架，添加新的case，skip掉(@unittest.skip）不需要跑的case。</li><li>添加logging模块，记录运行信息。</li><li>添加Test Report模块，记录每次运行的结果，划分饼图，等等。</li><li>可以利用之前我讲过的ptest自动化框架组织你的用例，这样整个android自动化框架都搭建起来了。</li><li>。。。。<br>不断优化，最终会生成最合适的移动端测试框架。</li></ol>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mobile-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PageObject 模式浅谈</title>
      <link href="/2017/05/18/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/PageObject%20%E6%A8%A1%E5%BC%8F%E6%B5%85%E8%B0%88/"/>
      <url>/2017/05/18/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/PageObject%20%E6%A8%A1%E5%BC%8F%E6%B5%85%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>PageObject 模式是什么？它如何起到到减少冗余代码，提升测试效率的目的？<br><a id="more"></a><br>先想象下这个例子：<br>在自动化测试过程中，特别是基于UI的功能自动化，我们经常要进行查找元素，操作元素的操作，一般来说，代码是如下这个样子的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">        </div><div class="line">self.driver.find_element_by_xpath(<span class="string">"//option[@value='10']"</span>)</div></pre></td></tr></table></figure><br>如果这个元素会被多个method用到，那么当元素变化时（例如XPATH变了）， 我们就不得不更新每个引用到这个元素的代码,非常麻烦。</p><p>有没有好的办法解决这个问题呢？ PageObject 应运而生</p><blockquote><p>Page Objects</p><p>Within your web app’s UI there are areas that your tests interact with. A Page Object simply models these as objects within the test code. This reduces the amount of duplicated code and means that if the UI changes, the fix need only be applied in one place.</p></blockquote><p>简单来说就是：</p><blockquote><p>PageObject是一种程序设计模式，将面向过程转变为面向对象(页面对象)，将测试对象及单个的测试步骤封装在每个Page对象中，以page为单位进行管理。可以使代码复用，降低维护成本，提高程序可读性和编写效率。<br>PageObject可以将页面定位和业务操作分开，分离测试对象（元素对象）和测试脚本（用例脚本），提高用例的可维护性。</p></blockquote><p>记住，PageObject是一种程序设计模式，是一种思想，</p><p>PageObject 的好处是：</p><blockquote><p>Creating reusable code that can be shared across multiple test cases<br>Reducing the amount of duplicated code<br>If the user interface changes, the fix needs changes in only one place</p></blockquote><p>PageObject应该怎么使用呢？基于测试实践，我们一般这样应用：</p><ol><li>把每个要测试的对象封装在一个page内， 这个page里包含这个对象可能的所有操作。</li><li>创建一个BasePage，这个BasePage包含所有待测page都能用到的公用方法，这个BasePage对应的类应该是个抽象类。</li><li>测试脚本自由引用page及page里的方法。</li></ol><p>python里有个第三方库page-objects， 基于python实现了PageObject模式，并且封装了很多有用的方法。我们以它为例，举例如下（例子基于我的Github项目）：</p><h5 id="abstract-base-page-py"><a href="#abstract-base-page-py" class="headerlink" title="abstract_base_page.py"></a>abstract_base_page.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</div><div class="line"><span class="keyword">from</span> DateTime <span class="keyword">import</span> DateTime</div><div class="line"><span class="keyword">from</span> assertpy <span class="keyword">import</span> assert_that</div><div class="line"><span class="keyword">from</span> page_objects <span class="keyword">import</span> PageObject, PageElement</div><div class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</div><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</div><div class="line"></div><div class="line"><span class="keyword">import</span> settings</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBasePage</span><span class="params">(PageObject)</span>:</span></div><div class="line"></div><div class="line">    __metaclass__ = ABCMeta</div><div class="line"></div><div class="line">    WAIT_FOR_SCROLL_TIME = <span class="number">2</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, driver)</span>:</span></div><div class="line">        <span class="comment"># Don't change the variable name w. it's used by PageObject</span></div><div class="line">        self.w = driver</div><div class="line">        self.driver = driver</div><div class="line">        assert_that(self.has_loaded()).is_true()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_loaded</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self.is_target_page()</div><div class="line">        <span class="keyword">except</span> NoSuchElementException:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="comment"># This function will be implement by sub class</span></div><div class="line"><span class="meta">    @abstractmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_target_page</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_element_displayed_on_page</span><span class="params">(self, ele, timeout=settings.TIME_OUT)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            WebDriverWait(self.driver, timeout).until(<span class="keyword">lambda</span> driver: ele.is_displayed())</div><div class="line">            result = <span class="keyword">True</span></div><div class="line">        <span class="keyword">except</span> Exception:</div><div class="line">            result = <span class="keyword">False</span></div><div class="line">        <span class="keyword">return</span> result</div><div class="line"></div><div class="line"><span class="comment">#...其它的公用方法.....</span></div></pre></td></tr></table></figure><p>解释如下：<br>1.abc 模块用来创建抽象类。<br>2.page_objects模块用来实现pageobject模式。<br>语法请自行google。</p><h5 id="baidu-py"><a href="#baidu-py" class="headerlink" title="baidu.py"></a>baidu.py</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span>  time</div><div class="line"></div><div class="line"><span class="keyword">from</span> page_objects <span class="keyword">import</span> page_element</div><div class="line"></div><div class="line"><span class="keyword">import</span> settings</div><div class="line"><span class="keyword">from</span> settings.test_config <span class="keyword">import</span> DEFAULT_SLEEP_TIME</div><div class="line"><span class="keyword">from</span> page.abstract_base_page <span class="keyword">import</span> AbstractBasePage</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BAI_DU</span><span class="params">(AbstractBasePage)</span>:</span></div><div class="line">    SEARCH_DIALOG_ID = <span class="string">"kw"</span></div><div class="line">    SEARCH_ICON_ID = <span class="string">"su"</span></div><div class="line">    MEMBER_COUNT_XPATH = <span class="string">"//option[@value='10']"</span></div><div class="line">    SAVE_XPATH = <span class="string">".//*[@id='save']"</span></div><div class="line"></div><div class="line">    csearch_input_dialog = page_element(id_=SEARCH_DIALOG_ID)</div><div class="line">    search_icon = page_element(id_=SEARCH_ICON_ID)</div><div class="line">    member_count = page_element(xpath=MEMBER_COUNT_XPATH)</div><div class="line">    save_button = page_element(xpath=SAVE_XPATH)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, browser)</span>:</span></div><div class="line">        self.browser = browser</div><div class="line">        AbstractBasePage.__init__(self, browser)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_target_page</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser.get(settings.BAI_DU_HOME + <span class="string">"/"</span>)</div><div class="line">        <span class="keyword">return</span> self.is_element_displayed_on_page(self.search_icon)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, search_string)</span>:</span></div><div class="line">        self.search_input_dialog.send_keys(search_string)</div><div class="line">        self.search_icon.click()</div><div class="line">        time.sleep(DEFAULT_SLEEP_TIME)</div><div class="line">        self.browser.close()</div></pre></td></tr></table></figure><p>解释如下：<br>1.page_objects封装了Selenium的一些方法，我们不需要通过driver.find_element_by_xpath()等来查找元素，转而用<br>page<em>element（locator</em>）这样的方式来定位， page-objects支持的locator如下：</p><table><thead><tr><th>keyword Arg</th><th>Description</th></tr></thead><tbody><tr><td>id_</td><td>Element ID attribute</td></tr><tr><td>css</td><td>CSS Selector</td></tr><tr><td>name</td><td>Element name attribute</td></tr><tr><td>class_name</td><td>Element class name</td></tr><tr><td>tag_name</td><td>Element HTML tag name</td></tr><tr><td>link_text    Anchor</td><td>Element text content</td></tr><tr><td>partial_link_text</td><td>Anchor Element partial text content</td></tr><tr><td>xpath</td><td>XPath</td></tr></tbody></table><p>2.每个子类，都应该实现抽象类里的抽象方法， 在本例中是is_target_page().</p><h5 id="test-py-测试用例"><a href="#test-py-测试用例" class="headerlink" title="test.py(测试用例)"></a>test.py(测试用例)</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> ptest.assertion <span class="keyword">import</span> assert_that, assert_equals</div><div class="line"><span class="keyword">from</span> ptest.decorator <span class="keyword">import</span> TestClass, BeforeMethod, Test, AfterMethod</div><div class="line"><span class="keyword">from</span> ptest.plogger <span class="keyword">import</span> preporter</div><div class="line"></div><div class="line"><span class="keyword">from</span> common.selenium_helper <span class="keyword">import</span> SeleniumHelper</div><div class="line"><span class="keyword">from</span> page.baidu <span class="keyword">import</span> BAI_DU</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@TestClass(run_mode='parallel')</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBaidu</span>:</span></div><div class="line"><span class="meta">    @BeforeMethod(description="prepare test data")</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before</span><span class="params">(self)</span>:</span></div><div class="line">        preporter.info(<span class="string">"Test is about to start"</span>)</div><div class="line">        self.browser = SeleniumHelper.open_browser(<span class="string">"chrome"</span>)</div><div class="line"></div><div class="line"><span class="meta">    @Test(tags =["regression", "smoke"])</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_baidu_search</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Test search"""</span></div><div class="line">        baidu = BAI_DU(self.browser)</div><div class="line">        baidu.search(<span class="string">"test"</span>)</div><div class="line">        assert_equals(<span class="number">1</span>, <span class="number">1</span>)</div></pre></td></tr></table></figure><p>测试脚本，可以任何组合各个page的任意方法。</p><p>由此可以见， 使用了page_objects 后， 测试对象， 测试方法， 测试脚本全部解耦， 测试对象的任何改变，只需要更改相应的page对应的类就好了。 </p><p>最后附上:<br><a href="https://pypi.python.org/pypi/page-objects/1.1.0" target="_blank" rel="external">Page_objects的pypi地址</a></p><p><a href="https://page-objects.readthedocs.io/en/latest/index.html" target="_blank" rel="external">Page_objects文档</a></p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号开发系列--Flask+SAE新浪云部署微信公众号</title>
      <link href="/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--Flask+SAE%E6%96%B0%E6%B5%AA%E4%BA%91%E9%83%A8%E7%BD%B2%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
      <url>/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--Flask+SAE%E6%96%B0%E6%B5%AA%E4%BA%91%E9%83%A8%E7%BD%B2%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>近期，腾讯公布了2016年业绩报告，其中显示微信活跃用户数已达5.49亿， 如果你还不明白这代表什么，来看看</p><a id="more"></a><p>国内三大电信运营商的表现：</p><blockquote><p>2016年6月20日, 中国移动用户总数达8.35亿， 其中4G用户达4.09亿。<br>2016年2月， 中国联通移动用户数2.57亿，4G用户5480.2万。<br>2016年上半年，电信移动用户数2.07亿，其中4G用户数9010万户。</p></blockquote><p>三者的4G用户相加为 5.53亿上下。 也就是说，全中国每一个用4G网络的人几乎都是微信的客户！！！</p><p>为什么要说这个，同志们，技术人员不能只低头干活，不抬头看路啊！</p><p>加上微信近期将会推出公众号–企业应用号。什么意思呢，就是说以后我们手机里，只需要微信一个APP就可以了， 其它所有的APP都将以web App的方式嵌入到微信中，用户像关注公众号一样的使用。那么开发者怎么办？当然是做公众号开发嵌入微信了。</p><p>细思极恐啊，同志们，微信就是未来，你不懂微信你就没有未来啊！</p><hr><p>好的，装逼结束，我们来看如何开发公众号：</p><ol><li>申请服务器</li><li>搭建服务</li><li>申请公众号</li><li>开发者基本配置</li><li>提供服务<br>如果你不知道如何在本地搭建并发布你的服务， 请参考旧文&lt;利用Apache+Flask+python部署网页应用&gt;</li></ol><p>今天我们来尝试用比较流行的新浪云来部署我们的应用，好处是有了一个外部域名，可以直接被微信服务器访问。</p><p>1.登录新浪云，进入 我的首页 ，点击 创建新应用 ，创建一个新的应用 itesting。运行环境选择 Python2.7<br>2.编辑应用代码<br>要想让微信和新浪云通信，以下下文件不可缺少：<br>index.wsgi<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sae</div><div class="line"><span class="keyword">from</span> main <span class="keyword">import</span> app</div><div class="line">application = sae.create_wsgi_app(app)</div></pre></td></tr></table></figure><br>新浪云上的 Python 应用的入口为index.wsgi:application，也就是index.wsgi这个文件中名为application的 callable object。在 我的应用中，该 application 为一个 wsgi callable object。</p><p>config.yaml 。在目录下创建应用配置文件 config.yaml ，内容如下：  </p><blockquote><ol><li>name: itesting</li><li>version: 1</li></ol></blockquote><p>main.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response</div><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.debug = <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/welcome')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Welcome to Kevin's website!"</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/',  methods=['GET', 'POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wechat</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</div><div class="line">            <span class="keyword">if</span> len(request.args) &gt; <span class="number">0</span>:</div><div class="line">                temparr = []</div><div class="line">                <span class="comment">#此处为公众号里设置的token</span></div><div class="line">                token = settings.token </div><div class="line">                signature = request.args[<span class="string">"signature"</span>]</div><div class="line">                timestamp = request.args[<span class="string">"timestamp"</span>]</div><div class="line">                nonce = request.args[<span class="string">"nonce"</span>]</div><div class="line">                echostr = request.args[<span class="string">"echostr"</span>]</div><div class="line">                temparr.append(token)</div><div class="line">                temparr.append(timestamp)</div><div class="line">                temparr.append(nonce)</div><div class="line">                temparr.sort()</div><div class="line">                newstr = <span class="string">""</span>.join(temparr)</div><div class="line">                sha1str = hashlib.sha1(newstr)</div><div class="line">                temp = sha1str.hexdigest()</div><div class="line">                <span class="keyword">if</span> signature == temp:</div><div class="line">                    <span class="keyword">return</span> make_response(echostr)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> make_response(<span class="string">"Access denied"</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> make_response(<span class="string">"Wrong args received"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">             <span class="keyword">return</span> make_response(<span class="string">"Welcome to iTesting"</span>) </div></pre></td></tr></table></figure><br>这里面有微信的逻辑，开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带参数如下表所示：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>signature</td><td>微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</td></tr><tr><td>timestamp</td><td>时间戳</td></tr><tr><td>nonce</td><td>随机数</td></tr><tr><td>echostr</td><td>随机字符串</td></tr></tbody></table><p>开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：<br>1）将token、timestamp、nonce三个参数进行字典序排序<br>2）将三个参数字符串拼接成一个字符串进行sha1加密<br>3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</p><p>3.上传到新浪云<br>切换到项目目录，用git命令在你应用的git代码目录里，添加一个新的git远程仓库 sae。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git remote add sae https://git.sinacloud.com/itesting</div><div class="line"><span class="comment">#编辑代码并将代码部署到 `sae` 的版本1。</span></div><div class="line">$ git add .</div><div class="line">$ git commit -m <span class="string">'Init my first app'</span></div><div class="line">$ git push sae master:<span class="number">1</span></div></pre></td></tr></table></figure><br>成功后输入 http://itesting.applinzi.com/  测试，如果返回 “Wrong args received”， 说明配置成功。</p><p>4.进入公众号， 左侧菜单选择开发-》基本配置，配置URL为上述地址，然后其它选项填好， 保存，当显示保存成功则说明配置成功。</p><p>配置好后，所有用户发给你的消息都将通过新浪云服务器处理，你需要自己写处理的代码逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号开发系列--自动回复实现天气预报查询</title>
      <link href="/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%9F%A5%E8%AF%A2/"/>
      <url>/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>上次我们讲了微信公众号的部署，今天我们来实现一个小功能，自动回复天气预报的播报。</p><a id="more"></a><p>使用方法如下： 在iTesting公众号里直接回复 “城市 天气”，将会把上海最近的天气信息返回给你， 例如输入上海  天气 ， 会返回给你上海的天气情况。</p><p>通过仔细阅读微信开发文档，我们知道：</p><blockquote><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p></blockquote><p>简单来说，当你输入信息要求微信服务器返回你一个信息时，是在做一个Post请求，这个post请求是text格式的，微信收到会转给你自己的服务器，你的服务器处理好后，按照微信的要求把内容返回，然后你就可以看到回复了。<br>原理知道了，那么如何开发？步骤如下：</p><ol><li><p>首先把回复的xml准备好，放在文件里，例如 txt_message.xml.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&#123;to_user&#125;]]&gt;&lt;/ToUserName&gt;</div><div class="line">&lt;FromUserName&gt;&lt;![CDATA[&#123;from_user&#125;]]&gt;&lt;/FromUserName&gt;</div><div class="line">&lt;CreateTime&gt;&#123;c_time&#125;&lt;/CreateTime&gt;</div><div class="line">&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</div><div class="line">&lt;Content&gt;&lt;![CDATA[&#123;content_value&#125;]]&gt;&lt;/Content&gt;</div><div class="line">&lt;/xml&gt;</div></pre></td></tr></table></figure></li><li><p>调用天气预报API生成天气。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">"utf-8"</span>)</div><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line"><span class="keyword">import</span> settings</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetWeather</span><span class="params">(object)</span>:</span></div><div class="line">    headers = &#123;<span class="string">'apikey'</span>: settings.baidu_apikey&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_city_code</span><span class="params">(self, city)</span>:</span></div><div class="line">        url = <span class="string">'http://apis.baidu.com/apistore/weatherservice/citylist?cityname=%s'</span>%city</div><div class="line"></div><div class="line">        r = requests.get(url, headers=self.headers)</div><div class="line">        j =  r.json()[<span class="string">'retData'</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j:</div><div class="line">            <span class="keyword">if</span> i[<span class="string">'name_cn'</span>] == city:</div><div class="line">                <span class="keyword">return</span> i[<span class="string">'area_id'</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_weather</span><span class="params">(self, city)</span>:</span></div><div class="line">        city_code = self.get_city_code(city)</div><div class="line">        url = <span class="string">'http://apis.baidu.com/apistore/weatherservice/recentweathers?cityname=&#123;&#125;&amp;cityid=&#123;&#125;'</span>.format(city, city_code)</div><div class="line">        r = requests.get(url, headers=self.headers)</div><div class="line">        raw_data = r.json()</div><div class="line"></div><div class="line">        <span class="keyword">if</span> raw_data.has_key(<span class="string">"retData"</span>):</div><div class="line"></div><div class="line">            <span class="keyword">if</span> type(raw_data[<span class="string">'retData'</span>]) == dict:</div><div class="line">                j = raw_data[<span class="string">'retData'</span>][<span class="string">'today'</span>]</div><div class="line">                content = <span class="string">"今日&#123;city&#125;的天气情况如下：\n"</span> \</div><div class="line">                          <span class="string">"日期：&#123;date&#125;,"</span>  \</div><div class="line">                          <span class="string">"&#123;week&#125;, "</span>  \</div><div class="line">                          <span class="string">"当前温度：&#123;curTemp&#125;, "</span>  \</div><div class="line">                          <span class="string">"&#123;type&#125;, &#123;fengxiang&#125;, &#123;fengli&#125;"</span>  \</div><div class="line">                          <span class="string">"最高气温：&#123;hightemp&#125;, "</span> \</div><div class="line">                          <span class="string">"最低气温：&#123;lowtemp&#125;, "</span> \</div><div class="line">                          <span class="string">"PM值：&#123;aqi&#125;"</span> .format(city=city, date=j[<span class="string">'date'</span>], week=j[<span class="string">'week'</span>], curTemp=j[<span class="string">'curTemp'</span>],type=j[<span class="string">'type'</span>],\</div><div class="line">                                             fengxiang=j[<span class="string">'fengxiang'</span>], fengli=j[<span class="string">'fengli'</span>], hightemp=j[<span class="string">'hightemp'</span>],\</div><div class="line">                                              lowtemp=j[<span class="string">'lowtemp'</span>], aqi=j[<span class="string">'aqi'</span>])</div><div class="line">                <span class="keyword">return</span> content</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="string">"您输入的城市有误，请重新输入."</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">"您输入的城市有误，请重新输入."</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    w = GetWeather()</div><div class="line">    <span class="keyword">print</span> w.get_weather(<span class="string">'上海'</span>)</div></pre></td></tr></table></figure></li><li><p>把上述步骤里得到的返回值，嵌入到step1的变量里，返回给微信Server。具体做法: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@app.route('/',  methods=['GET', 'POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wechat</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</div><div class="line">            <span class="keyword">if</span> len(request.args) &gt; <span class="number">0</span>:</div><div class="line">                temparr = []</div><div class="line">                token = settings.token</div><div class="line">                signature = request.args[<span class="string">"signature"</span>]</div><div class="line">                timestamp = request.args[<span class="string">"timestamp"</span>]</div><div class="line">                nonce = request.args[<span class="string">"nonce"</span>]</div><div class="line">                echostr = request.args[<span class="string">"echostr"</span>]</div><div class="line">                temparr.append(token)</div><div class="line">                temparr.append(timestamp)</div><div class="line">                temparr.append(nonce)</div><div class="line">                temparr.sort()</div><div class="line">                newstr = <span class="string">""</span>.join(temparr)</div><div class="line">                sha1str = hashlib.sha1(newstr)</div><div class="line">                temp = sha1str.hexdigest()</div><div class="line">                <span class="keyword">if</span> signature == temp:</div><div class="line">                    <span class="keyword">return</span> make_response(echostr)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> make_response(<span class="string">"Access denied"</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> make_response(<span class="string">"Wrong args received"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            raw_data = request.stream.read()</div><div class="line">            xml_raw = ET.fromstring(raw_data)</div><div class="line">            msg = &#123;&#125;</div><div class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> xml_raw:</div><div class="line">                msg[child.tag] = child.text</div><div class="line"></div><div class="line">            msgtype = msg[<span class="string">'MsgType'</span>]</div><div class="line">            tou = msg[<span class="string">'ToUserName'</span>]</div><div class="line">            fromu = msg[<span class="string">'FromUserName'</span>]</div><div class="line">            time_str = str(int(time.time()))</div><div class="line"></div><div class="line">            <span class="keyword">if</span> msgtype == <span class="string">"event"</span>:</div><div class="line">                event_msg = xml_raw.find(<span class="string">'Event'</span>).text</div><div class="line">                <span class="keyword">print</span> event_msg</div><div class="line">                <span class="keyword">if</span> event_msg == <span class="string">"subscribe"</span>:</div><div class="line">                    sub_content = settings.welcome_message</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    sub_content = <span class="string">"error"</span></div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"txt_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=sub_content))</div><div class="line">            <span class="keyword">elif</span> msgtype == <span class="string">"image"</span>:</div><div class="line">                media_id = msg[<span class="string">'MediaId'</span>]</div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"img_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id))</div><div class="line">            <span class="keyword">elif</span> msgtype == <span class="string">"voice"</span>:</div><div class="line">                media_id = msg[<span class="string">'MediaId'</span>]</div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"voice_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id))</div><div class="line">            <span class="keyword">elif</span> msgtype == <span class="string">'text'</span>:</div><div class="line">                <span class="comment"># co = xml_raw.find('Content').text.strip().split(' ')</span></div><div class="line">                <span class="comment"># if co[len(co)-1] == '天气':</span></div><div class="line">                <span class="comment">#     weather = GetWeather()</span></div><div class="line">                <span class="comment">#     auto_response_content = weather.get_weather(co[:-1][0])</span></div><div class="line">                <span class="comment"># else:</span></div><div class="line">                r = RobotHelper()</div><div class="line">                auto_response_content = r.get_robot(xml_raw.find(<span class="string">'Content'</span>).text)</div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"txt_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=auto_response_content))</div><div class="line"></div><div class="line">            <span class="keyword">elif</span> msgtype <span class="keyword">in</span> [<span class="string">"video"</span>,<span class="string">"shortvideo"</span>]:</div><div class="line">                title = <span class="string">"My video"</span></div><div class="line">                description = <span class="string">"Check out my video"</span></div><div class="line">                media_id = msg[<span class="string">'MediaId'</span>]</div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"video_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id, title=title, description=description))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                unknown_content = <span class="string">u"""我不知道你在干什么,无法回复你"""</span></div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"txt_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=unknown_content))</div><div class="line"></div><div class="line">            response.content_type = <span class="string">'application/xml'</span></div><div class="line">            <span class="keyword">return</span> response</div></pre></td></tr></table></figure></li></ol><p>这样就实现了基于文本格式的天气预报功能，是不是没有那么难？</p><p>其实，如果你仔细研究下微信开发文档你就发现，微信开发的本质是接口测试，不过接口测试的结果被我们的服务器拿来使用，变成了一个个功能而已。</p><p>怎么理解呢？我们开发一个个功能时，实际上就是一次次对微信接口发起请求，微信通过开放给我们一个个接口，接收按照固定格式的post数据，处理后返回结果，我们收到结果后，自己写代码处理完毕，再按照微信要求的格式传给我们的服务器，服务器接收后，展示或者返回相应结果。</p><p>到现在为止，我们基本解锁了微信开发，高大上的微信开发也不过是接口测试而已。。。</p><p>我相信通过上述解释大家肯定可以实现更多好玩的功能了， 大家可以尝试下我写的自动回复机器人功能，有问题直接留言给我， 我会答疑解惑：）</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号开发系列--本地调试环境搭建</title>
      <link href="/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>上次我们讲了如何利用Flask + 新浪云部署微信开发，在开发的过程中我们发现如下问题：</p><a id="more"></a><p>1.程序出现问题，调试比较麻烦，log保存需要自己写代码。<br>2.每次更改都需要发布到应用服务器，一旦有问题，立刻影响公众号正常使用。<br>3.服务器无效代码太多，这对于有代码洁癖的完全不能忍好吗！<br>如果能本地调试就好了，我们只发布正确的版本到应用服务器，最好调试简单，方便，log即开即看，那么有没有可能呢？</p><p>必须有，今天我们就来介绍一款内网传透神器– ngrok.</p><p>ngrok 是一个反向代理，通过在公共的端点和本地运行的Web 服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析和重放.<br>下面以我们本地的服务器为例《利用Apache+Flask+python部署网页应用》，来介绍下如何使用：<br>1.下载：<a href="https://ngrok.com/" target="_blank" rel="external">https://ngrok.com/</a><br>2.安装：<br>下载好后cmd命令进入到解压的目录，然后运行命令如下：</p><blockquote><p>ngrok http 8088 –authtoken “ your token,get from ngrok.com”</p></blockquote><p>当你看到如下信息说明运行成功，Forwarding里的地址就是外网能访问的地址。<br>这里需注意，你注册号后会有一个唯一的token，用作绑定地址。<br>Tunnel Status                 online<br>Version                       2.0/2.0<br>Web Interface                 <a href="http://127.0.0.1:4040" target="_blank" rel="external">http://127.0.0.1:4040</a><br>Forwarding                    <a href="http://92832de0.ngrok.io" target="_blank" rel="external">http://92832de0.ngrok.io</a> -&gt; localhost:80<br>Forwarding                    <a href="https://92832de0.ngrok.io" target="_blank" rel="external">https://92832de0.ngrok.io</a> -&gt; localhost:80</p><p>Connnections                  ttl     opn     rt1     rt5     p50     p90<br>                              0       0       0.00    0.00    0.00    0.00</p><p>3.使用上述地址访问确应用服务器保配置正确，然后去微信-》开发-》开发者工具，里申请公众平台测试帐号，然后在配置里，填写上述url 和token。保存成功后，所有的用户消息都将通过微信转往我们的外网服务器。<br>4.以我们的应用为例, 在浏览器输入 <a href="http://localhost:4040，等我们的程序运行，无论成功与否，所有的get，" target="_blank" rel="external">http://localhost:4040，等我们的程序运行，无论成功与否，所有的get，</a> post请求都可以在这个地址看到，如果有错误你可以可以直接看到具体出错信息，因为我们用的是apache，出错后也可以直接去Apache文件夹下面的log里看error，是不是超级方便？<br>5.那么你修改好错误后，如何生效呢？重启apache server即可。然后去往测试公众号里发送请求，就可以看到最新的反馈了。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dev-in-test </tag>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Apache+Flask+python部署网页应用</title>
      <link href="/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Apache+Flask+python%E9%83%A8%E7%BD%B2%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8/"/>
      <url>/2017/04/05/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Apache+Flask+python%E9%83%A8%E7%BD%B2%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>当你开发好一个网页程序后，除了本地浏览，你当然期望把它发布出去供大家欣赏。我们今天就来讲下如何用Apache 部署你的应用程序（注：发布后只能通过ip访问，你需注册域名才能通过域名访问）。</p><a id="more"></a><p>重要的事情说三遍：<br>for i in range（3）:<br>“以下所有的安装要么全部安装32bit，要么全部安装64bit，否则运行不起来。”</p><p>1.安装 Python<br>唯一注意的是安装选项需选择应用于所有用户。</p><p>2.安装Apache:<br>地址：https://httpd.apache.org/download.cgi <br>以window为例，我们选择Files for Microsoft Windows， 然后安装Apache Haus下所有的相应版本，例如：<br><img src="/2017/04/05/测试开发系列/微信开发系列/利用Apache+Flask+python部署网页应用/1.png" alt=""><br>注意看, 竖排的软件为兼容的组合，如果你安装vc11，那么vc11这一列的都要安装，安装好后根据文件里的 readme进行配置，其中要注意的是主要是mod_wsgi 的安装，这个是用来和python通信的。</p><p>注意：<br>× 根据需要配置你的SRVROOT文件路径（apache安装文件conf下的httpd.conf），这里为”C:\Apache24”.<br>× 根据需要更改你的端口号。（可以在command line下用netstat -ao的方式看端口号有没有被占用。）<br>× 注意需成功配置mod_wsgi, 提示：<br>在apache安装目录下 启用 LoadModule wsgi_module modules/mod_wsgi.so 并将mod_wsgi 文件copy到modules目录。</p><p>全部安装好后，command line进入apache的bin目录，输入httpd来看安装是否正确，然后输入httpd -k install 来安装windows service，然后启动。</p><p>3.安装flask<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Flask </div></pre></td></tr></table></figure>4.开发你的app我们写一个welcome页面，需要2个文件：main.py<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__)</div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">   <span class="keyword">return</span> <span class="string">"Welcome to Kevin's website!"</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">   app.run()</div></pre></td></tr></table></figure></p><p>main.wsgi （这个文件用做网关跟apache通信，记住文件名称，apache配置要用）<br><blockquote><p>To run your application you need a yourapplication.wsgi file. This file contains the codemod_wsgi is executing on startup to get the application object. The object calledapplication in that file is then used as application.</p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys, os</div><div class="line">sys.path.insert(<span class="number">0</span>, os.path.dirname(__file__))</div><div class="line"><span class="keyword">from</span> main <span class="keyword">import</span> app <span class="keyword">as</span> application</div></pre></td></tr></table></figure></p><p>5.配置 Apache。</p><p>在httpd.conf里，配置如下：</p><ul><li>去掉前面的#号。<br>Include conf/extra/httpd-vhosts.conf</li><li>在conf的extra下，配置httpd-vhosts.conf 如下：<virtualhost *:8088="">DocumentRootD:\wechat_test\wechatServerNamelocalhostWSGIScriptAlias / D:\wechat_test\wechat\main.wsgi<directory d:\wechat_test="">Require all granted</directory></virtualhost>注意：</li><li>端口号跟httpd.conf的Listen端口一致。</li><li>wsgi目录， Directory跟你app里定义的一致。</li><li>把文件里原有的不需要的配置command out掉。</li></ul><p>6.重启下Apache services，然后浏览器里输入http://localhost:8088看你开发的app首页有没有正确load：<br><img src="/2017/04/05/测试开发系列/微信开发系列/利用Apache+Flask+python部署网页应用/2.png" alt=""><br>成功，下面你可以继续完善你的app了 ：）</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dev-in-test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口测试自动化框架实践</title>
      <link href="/2017/04/04/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/"/>
      <url>/2017/04/04/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>接口测试自动化框架实践<br><a id="more"></a><br>之前介绍过一个接口测试的框架 Jmeter + Ant + Jenkins，分为了2期介绍。现在把它们总结在一篇文章中，方便大家学习。</p><p>对接口测试概念还不甚理解的同学，请移步iTesting的历史文章《接口（API）测试》。<br>简要来说，这个框架有两部分组成，可以直接点击链接进入：<br>1.Jmeter的脚本生成及参数化<br>如果上述链接失效：<br>请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/04/接口测试/接口测试自动化框架实践/1.jpg" alt=""><br>2.Ant + Jenkins集成<br>如果上述链接失效：<br>请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/04/接口测试/接口测试自动化框架实践/2.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试框架 </tag>
            
            <tag> API-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web自动化框架实践指南</title>
      <link href="/2017/04/04/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/Web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
      <url>/2017/04/04/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/Web%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>我们今天来看看一个成熟的Web自动化框架是什么样子的，如果你还对测试框架的概念有所疑惑，请移步iTesting公众号的历史文章测试框架之我见。<br><a id="more"></a><br>以下是Web自动化框架实践正文：<br>贴一个图，是iTesting现在所在项目用的框架，我们来一步步分析说明：<br><img src="/2017/04/04/测试框架/Web自动化框架实践指南/1.jpg" alt=""></p><p>注意观察图中每一个小方格右上方的数字，从1 到7，代表了测试框架的不同部分，我们来逐一介绍：</p><h4 id="0：-Core-Framework。"><a href="#0：-Core-Framework。" class="headerlink" title="0： Core Framework。"></a>0： Core Framework。</h4><p>这个是测试框架的灵魂，我们可以看出它又分为几个部分，最底层就是Selenium， Webdriver，包括它们支持的原生库。倒数第二层是支持最底层的第3方库，二次开发生成的自定义库，API还有自己定义的Keywords。再上一层是一些公共的方法，这些方法普遍应用倒数第2层的API或者Mehod，这一层的方法实现了具体的功能，微信搜索iTesting，关注本公众号，比如说连接数据库，并进行增删改查的功能；连接Web Service并调用相应接口的功能；自动生成要运行的所有测试用例的功能；自动注释掉一些测试用例的功能。最上一层是解耦的测试脚本，每一个测试脚本完成一项特定的功能，比如，登录，定课，注销等。</p><h4 id="1：-Config-File"><a href="#1：-Config-File" class="headerlink" title="1： Config File"></a>1： Config File</h4><p>Config  file用来提供测试运行时的各种参数，配置。<br>这个文件或者文件夹存放了测试需要的precondition，settings，运行环境参数，还有运行每一个具体case时候需要的测试数据。<br>测试所需的共同的配置可以放到一个文件里（例如Timeout，多线程支持标志位），环境运行参数可以放到另外一个文件里（例如UAT， LIVE），测试数据可以保存在Excel， XML，或者直接写在文件里，以环境运行参数为分隔符（例如UAT和Live下都有同一个变量名username）。</p><h4 id="2：-AUT-application-under-test"><a href="#2：-AUT-application-under-test" class="headerlink" title="2： AUT   application under test"></a>2： AUT   application under test</h4><p>这个模块就是我们要测试的application。它分为2个部分：<br>一个部分是Pages（2-2）， 即各个待测试页面。Pages里包含了页面上所有的待测元素，以及这个页面上的所有用户能做的操作，我们通常把这些操作封装成一个个的函数，以使它们来实现特定的功能，例如book_pl_class(class_info)函数，这个函数接受一个入参，入参是一个Entity 类，包括了一节课所有必要信息，函数本身实现了pl class的预订（通过接收参数，点击相应元素等操作）。函数返回值是一节课的所有信息。应注意的是Pages里不应该包含测试用例逻辑，所有的特定测试逻辑应该与页面具体操作解耦。</p><p>Pages我们引用了Page Object模式（将测试对象及单个的测试步骤封装在每个Page对象中，以page为单位进行管理），这个模式的好处是将测试方法和测试对象完全解耦，我们举个例子， 在使用page object模式之前我们的代码可能是这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self, user_name, password)</span>:</span></div><div class="line">    user_element = self.browser.find_element_by_id(<span class="string">"username"</span>)</div><div class="line">    user_element.send_keys(user_name)</div><div class="line">    password_element = elf.browser.find_element_by_id(<span class="string">"password"</span>)</div><div class="line">    password_element.send_keys(password +Keys.RETURN)</div></pre></td></tr></table></figure><br>login方法和各个element对象（这里只有username 和password这两个element）耦合在一起，当UI改变导致element的定位方式改变后，我们不得不去方法内部更改元素定位的方法，另外当某个元素在不同方法重复使用时，还需要反复查找。这样引发的问题是，当一个方法需要很多页面元素操作才完成时， 定位元素的大量代码和方法实现的功能代码耦合在一起，不仅更改起来困难，而且方法不直观，不便于用户理解。</p><p>我们来看引入了page obejct后代码变成了什么：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">USER_NAME_XPATH = <span class="string">"//input[@id='UserName']"</span></div><div class="line">PASSWORD_XPATH = <span class="string">"//input[@id='Password']"</span></div><div class="line">LOGIN_XPATH = <span class="string">"//a[@class='et-btn-submit']"</span>)</div><div class="line"></div><div class="line">user_name_textbox = PageElement(xpath=USER_NAME_XPATH)</div><div class="line">password_textbox = PageElement(xpath=PASSWORD_XPATH)</div><div class="line">login_button = PageElement(xpath=LOGIN_XPATH）</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self, user_name, password)</span>:</span> </div><div class="line">     self.user_name_textbox.send_keys(user_name)</div><div class="line">     self.password_testbox.send_keys(password)</div><div class="line">     self.login_button.click()</div></pre></td></tr></table></figure><br>你看，只要login的功能逻辑不变，就无需更改login方法，任凭UI如果改变，我们只需要在方法外更改element的locator，无论username这个元素需要多少函数中引用，我们只需定义一次就好了，是不是很方便维护又一目了然啊。</p><p>还有，测试过程中经常发现这样的问题，页面一开始就redirect到了非目标页面，因为我们没有针对目标页面本身做断言，导致代码继续执行，这样浪费了大量时间。我们可以通过验证目标页面正确与否的方法来避免这个问题。代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginPage</span><span class="params">(AbstractBasePage)</span>:</span></div><div class="line">   Target_XPATH = <span class="string">"//a[@class='et-btn-submit']"</span></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, driver)</span>:</span></div><div class="line">        AbstractBasePage.__init__(self, driver)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_target_page</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.is_element_displayed(By.XPATH, self.Target_XPATH)</div></pre></td></tr></table></figure><br>这里我们利用了一个BasePage的类，里面定义了 is_target_page的抽象方法，然后子类继承过来实现。<br>关于Pages还要很多好的优化方法，可以使我们的代码看起来简单可重用，这里不详细介绍细节了。</p><p>另一部分就是Test scenarios（2-1），即具体的测试suite和测试用例，Test scenarios由一个个test case组成，每一个test case 通过引用相应的Pages类/函数，和Core framework 里面的test scripts，来实现具体的功能， 而Test scenarios通过组合不同的test cases来覆盖不同的业务需求.<br>其中， Test Scenarios/Test case 里均会用到 config file的各种参数配置。<br>所有的Test Scenarios创建好后（我们把每个test scenario封装成一个测试类）， 就要决定如何执行这些测试类了。那么，这些测试类每次运行都需要全部执行吗？如果不需要，哪些是需要执行的，哪些是要ignore的呢？这个时候Core framework里的common method的具体Method派上了用场，common里实现了generate_test_scenarios的方法和ignore_test_scenarios方法，利用ignore_test_scenarios方法，我们会在tests文件夹下面的ignore_testcase_lists文件里列出所有要ignore的test scenarios，然后利用generate_test_scenarios方法我们最终把所有要执行的scenarios都放到<strong>init</strong>  里。</p><h4 id="3：-Main-file。-测试主函数。"><a href="#3：-Main-file。-测试主函数。" class="headerlink" title="3： Main file。 测试主函数。"></a>3： Main file。 测试主函数。</h4><p>测试主函数用来执行生成的各种Test Suites， 包括实现多线程支持和错误处理机制。它也是测试的入口函数。需要注意的是， Main 函数会装载 Test下面的<strong>init</strong>文件，所有在<strong>init</strong>文件里的用例都会被执行（是顺序还是同时要看函数中对多线程的支持及实现）。</p><h4 id="4：-Test-Report模块。"><a href="#4：-Test-Report模块。" class="headerlink" title="4： Test Report模块。"></a>4： Test Report模块。</h4><p>Main 函数同时也会包含生成test report的方式，测试完成后，会根据需要生成txt格式，html格式test report并保持到系统本地。</p><h4 id="5：-Error-Handling模块。"><a href="#5：-Error-Handling模块。" class="headerlink" title="5： Error Handling模块。"></a>5： Error Handling模块。</h4><p>测试运行中，如果发现错误，会根据Error handling规则触发相应的错误处理机制，同时会触发screen shots函数和log函数，把所有错误截图和log信息保存在系统本地。</p><h4 id="6：Email-Reports。"><a href="#6：Email-Reports。" class="headerlink" title="6：Email Reports。"></a>6：Email Reports。</h4><p>测试报告Email发送模块，这个模块可以在第7步里开发配置，也可以直接把代码写在Main 函数里，运行完随机发送测试报告。</p><h4 id="7：Jenkins持续集成。"><a href="#7：Jenkins持续集成。" class="headerlink" title="7：Jenkins持续集成。"></a>7：Jenkins持续集成。</h4><p>利用Jenkins，驱动Main 函数，实现每日构建，代码改动构建。并集成Test report模块，Email Report模块，实现测试框架的闭环。</p><p>我们再来看一下这个框架的文件结构：<br><img src="/2017/04/04/测试框架/Web自动化框架实践指南/2.jpg" alt=""><br>其中，a<strong>20,  common, </strong>_common对应  0：core framework，pages，entity , tests对应2：AUT，setings，对应 1：config file。Main函数及report，screenshots等位于 **_common下。</p><p>以上就是iTesting项目组测试框架的使用情况，由于种种原因，恕不能放出源代码，请见谅。</p><p>为了更好的理解测试框架，iTesting利用Python里的unittest和前文中测试框架设计思想，重新设计了一个简化版的测试框架，可以帮助你快速上手测试框架，请关注github。<br>地址：<a href="https://github.com/Light07/AutomationFrameWork.git" target="_blank" rel="external">Github地址</a></p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试框架之我见</title>
      <link href="/2017/04/04/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%88%91%E8%A7%81/"/>
      <url>/2017/04/04/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%88%91%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<p>什么是框架？<br>框架可以是被重用的基础平台；框架也可以是组织架构类的东西。我认为，框架就是一系列基础设施，这些设施起到一个基础工具的作用，是一个创建别的工具的工具。<br><a id="more"></a></p><p>其次，什么是自动化测试呢？<br>自动化测试是用软件（通常指有一系列测试配置前提下）去执行测试并且判断实际结果和期望结果是否一致的一种测试方法。</p><p>那么，什么是自动化测试框架呢？<br>自动化测试框架由一个或多个自动化测试基础模块、自动化测试管理模块、自动化测试统计模块等组成的工具集合。这些模块集合组合到一块，应具备以下特质：<br>· 测试框架与被测应用程序独立。即一套框架可以服务多种程序的自动化。<br>· 测试框架应被高度模块化，易于扩展、维护。各个模块之间应解耦，独立。<br>· 测试脚本所使用的测试语言应该是与框架独立的。不同的测试框架可能在不同的应用领域有不同的表现，有些适用于Java应用程序的测试， 有些可能适用于Web应用程序的测试，那么当需要从一个测试框架迁移到另外一个测试框架时，所有的测试脚本应该不需要重写。<br>·  测试框架应该简单易用。</p><p>最后，如何创建一个自动化测试框架呢？首先，你要有“自动化测试框架思想”，什么是“自动化测试框架思想”？<br>·模块化思想<br>·库思想<br>·数据驱动思想<br>·关键字驱动思想</p><p>我们举例说明：<br>譬如一个英文学习网站，有登录，学习页面（由PL, GL, 自我学习页面等组成），还有退出页面。<br>假设我要分别自动化测试测试PL， GL页面，那么我们应该怎么做呢？手工测试步骤是先登录，然后跳转到我要测试的页面，测试，然后退出。那么自动化测试就是分别写登录，跳转页面，测试，退出页面的代码，然后把它们按顺序组合到一起。我的代码看起来可能是这个样子的（）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">…代码块1…</div><div class="line">…打开登录页面…</div><div class="line">…输入用户名…</div><div class="line">…输入密码…</div><div class="line">…点击登录按钮…</div><div class="line">…跳转后检查是否进入到首页…</div><div class="line"></div><div class="line">…代码块2…</div><div class="line">…找到Menu…</div><div class="line">…找到PL/GL页面的链接…</div><div class="line">…点击连接进入…</div><div class="line">…判断是否进入目标页面…</div><div class="line">…是，进行目标界面的测试，不是，报错退出…</div><div class="line"></div><div class="line">…代码块3…</div><div class="line">…具体的测试代码，断言等…</div><div class="line"></div><div class="line">…代码块4…</div><div class="line">…找到退出按钮…</div><div class="line">…点击退出…</div></pre></td></tr></table></figure><p>模块化思想就是将一个测试用例中的几个不同的测试点拆分并且将其单个点的测试步骤进行了封装，形成了一个模块。<br>举例来说：<br>对于PL 和GL， 我的代码块及代码顺序都是1，2，3，4. 唯一不同的是3里的具体实现，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PL: 1, 2, 3(for PL), 4</div><div class="line">GL: 1, 2, 3(for GL), 4</div></pre></td></tr></table></figure><br>如果代码块1有改动，我需要把 PL 和GL测试代码里对应的模块也更改一遍，如果我有100个case，那么就要改100遍，太不make sense了。</p><p>模块化就是把1， 2， 4， 这些共用的操作分别封装，可以形成登录模块（login（）），跳转模块（redirect（）），退出模块（logout（））.<br>封装后我的代码看起来是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PL: login（）, redirect（）, 3(for GL), logout（）</div><div class="line">GL: login（）, redirect（）, 3(for GL), logout（）</div></pre></td></tr></table></figure><br>这样的话，当一个模块有变化，你只需单独维护那个模块即可，不再需要更改PL， GL的测试代码了， 是不是效率瞬间提升啊？</p><p>你肯定看出来了，模块化之后，redirect（）函数没有提供入参，这样我分别测试PL和GL的时候，需要更改redirect（）这个模块里的跳转url目标地址。还有如果我想针对特定账户测试PL， GL该怎么做呢？每次测试前再去修改模块化函数login（）的账户信息吗？如果我需要针对不同账户同时测试PL， GL该怎么办？</p><p>测试库思想，就是模块化思想的升华，其为应用程序的测试创造了库文件（可以是APIs、DLLs等），这些库文件为一系列函数的集合。其与模块化思想不同的是，其拓展了接口思想，即可以通过接口去传递参数，而不是一个封死的模块，可以说是一个多了一个“门”的交互型模块。<br>我们根据测试库思想来设计一个api，把login（）， redirect（）更改成 login（username, password）, redirect(url),是不是就解决了啊！<br>我们的代码变成了 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PL: login（username, password）, redirect(url), 3(for GL), logout（）</div><div class="line">GL: login（username, password）, redirect(url), 3(for GL), logout（）</div></pre></td></tr></table></figure><br>另外，针对login 和redirect模块里的跳转检查和目标页面确认检查，我们也可以封装成一个函数 target_check（target）， 这样我们的代码是不是又少了很多，且方便维护扩展了呢 ：）</p><p>这样，我们的测试脚本开发人员，只需要focus在具体的测试页面上（例如PL或者GL页面）就可以了，不需要关心通用模块的开发维护了，这样是不是有了测试框架的雏形了？：）</p><p>我们满足的把这个框架运行了一段时间，忽然有一天，老板说，我们新开发了100个市场，我们需要这100个市场的用户从登录界面登录后，根据用户country把用户redirect到不同的domain上去，这个需求很紧急，你多久能搞定？<br>创建100个test case，更改这100个case里login模块的username， password? 你傻不傻？</p><p>我们弄一个Excel，封装一个读写Excel的api，然后只写一个测试用例，循环100次，每次读取不同的username和password，我们的代码变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">For i in range(0,100):</div><div class="line">login（username[i], password[i]）, redirect(url), 3(for GL), logout（）</div></pre></td></tr></table></figure><br>老板开心死了，再来100个市场，你也分秒搞定！这个时候你让他加工资，你说他‘滋瓷’不‘滋瓷’?</p><p>这就是所谓数据驱动思想。利用数据驱动结果，不同的数据导致了不同的结果的产生。而对于数据的导入，可以通过很多方式，例如：EXCLE表、XML（用在WEB中）、数据库（DB）、CSV文件、TXT等都可以。</p><p>时光如梭，你带了个新人妹子，你来手把手教她如何新写自动化代码如何维护自动化框架，她很笨，代码写的慢，而且调用的api一多她就头晕，经常拖着你加班，一加就到晚上十点多，你还得送她回家，每次送到家她还请你上去坐坐，坐个头啊，已经十点多了，回到家就要12点了, 回去不要打游戏了？回去不要看球赛了？回去不要老婆孩子热炕头了？第二天上不上班了？叔可忍婶不可忍，你鼓捣出这个来：<br><img src="/2017/04/04/测试框架/测试框架之我见/1.png" alt=""><br>你告诉妹子，她只要在Excel里按格式更新就可以了，不需要再去调用API了，妹子讪讪的去了，世界清静多了，一切都很美好，并没有哪里不对～</p><p>这就是关键字思想。就是不仅把测试数据放到文件里，还把关键指令（用来决定做什么操作，做这个操作要执行哪个测试脚本）也放到外部文件里， 这就叫关键字驱动。<br>上面的例子中， MethodName 这一列是关键字，代码会根据这一列里的方法名调用相应的代码。<br>我们给出一个关键字的实现例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_browser</span><span class="params">(browser_name)</span>:</span></div><div class="line">    browser_name = browser_name.lower()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> browser_name <span class="keyword">in</span> &#123;<span class="string">'chrome'</span>, <span class="string">'firefox'</span>, <span class="string">'ff'</span>, <span class="string">'ie'</span>&#125;:</div><div class="line">        browser_name = <span class="string">'chrome'</span></div><div class="line">    <span class="keyword">if</span> browser_name == <span class="string">'ie'</span>:</div><div class="line">        browser = webdriver.Ie()</div><div class="line">    <span class="keyword">elif</span> browser_name <span class="keyword">in</span> (<span class="string">'firefox'</span>, <span class="string">'ff'</span>):</div><div class="line">        binary = <span class="keyword">None</span>   </div><div class="line">        profile = <span class="keyword">None</span></div><div class="line">        <span class="keyword">if</span> settings.FIREFOX_BINARY:</div><div class="line">            binary = FirefoxBinary(settings.FIREFOX_BINARY)</div><div class="line">        <span class="keyword">if</span> settings.FIREFOX_PROFILE:</div><div class="line">            profile = webdriver.FirefoxProfile(settings.FIREFOX_PROFILE)</div><div class="line">        browser = webdriver.Firefox(firefox_profile=profile, firefox_binary=binary)</div><div class="line">    <span class="keyword">else</span>：</div><div class="line">          options = webdriver.ChromeOptions()</div><div class="line">          options.add_argument(<span class="string">"--use-fake-device-for-media-stream"</span>)</div><div class="line">          options.add_argument(<span class="string">"--use-fake-ui-for-media-stream"</span>)</div><div class="line">          browser = webdriver.Chrome(chrome_options=options)</div><div class="line">    browser.maximize_window()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> browser</div></pre></td></tr></table></figure><br>这个例子实现好后，你在代码里写open_browser(‘chrome’)这个关键字, 系统就会自动知道如何执行，执行什么， 以什么配置。<br>以上你都明白了吗？自动化测试框架，不过是一系列文件，代码，组件的集合，这些集合放到一起，方便了我们自动化测试代码的编写，大大的提升了工作效率。<br>后面我们来看看如何根据以上思想实现Web自动化测试框架和Mobile自动化测试框架。</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试框架 </tag>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter 运用JDBC连接数据库</title>
      <link href="/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/Jmeter%20%E8%BF%90%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/Jmeter%20%E8%BF%90%E7%94%A8JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>上次我们讲了如何利用User Parameters来使用外部Json文件，今天我们讲下一个知识点：如何使用Jmeter连接数据库并且验证数据？<br><a id="more"></a></p><p>仍以我们之前的例子来说，最后教师给学生打分完毕后，会有一条数据存在数据库中，那么我们就需要去验证这个数据。</p><ol><li><p><font color="#FF0000">下载最新的JDBC Driver:</font></p><blockquote><p>下载最新的JDBC Driver（我们以SQL SERVER为例）<br><a href="https://msdn.microsoft.com/en-us/library/mt683464.aspx" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/mt683464.aspx</a><br>解压并copy你需要的jar 文件到 jmeter/lib 目录 (重启后生效)</p></blockquote></li><li><p>选中你需的Test plan， 把jar文件引入：<br><img src="/2017/04/03/接口测试/Jmeter 运用JDBC连接数据库/1.jpg" alt=""></p></li><li>右键Thread Group-&gt;Add-&gt;Config Element-&gt;JDBC Connection Configuration<br><img src="/2017/04/03/接口测试/Jmeter 运用JDBC连接数据库/2.jpg" alt=""></li><li><p>配置如下：<br><img src="/2017/04/03/接口测试/Jmeter 运用JDBC连接数据库/3.jpg" alt=""><br>Variable Name:  写个名字，这个名字后面JDBC Request要用。<br>Database URL:  jdbc:sqlserver://localhost:port;DatabaseName=mydb;  (localhost，port，mydb自行替换)<br>JDBC Driver Class: com.microsoft.sqlserver.jdbc.SQLServerDriver<br>Username：数据库连接用户名<br>Password: 数据库连接密码</p></li><li><p>在ThreadGroup上右键，Add-&gt;Sampler-&gt;JDBC Request:<br><img src="/2017/04/03/接口测试/Jmeter 运用JDBC连接数据库/4.jpg" alt=""></p></li><li>配置如下：<br><img src="/2017/04/03/接口测试/Jmeter 运用JDBC连接数据库/5.jpg" alt=""></li></ol><p><strong> Variable Name Bound to Pool：配置成与JDBC Connection Configuration里一样的值。<br>SQL Query：<br>                      QueryType：看自己需求选择（本例用Prepared Select Statement）。<br>                       下面input text就填写自己需要的SQl语句。其中“？”代表变量，它的值定义在Parameter values里， 如果有多个，用逗号隔开。</strong> Parameter values：SQL 语句里？对应的变量，如果有多个，名称以逗号隔开。<br><strong> Parameter types：INTEGER, DATE, VARCHAR, DOUBLE</strong> Variable names: 这个参数用来保存Select 语句返回的值。引用方法参考下扩展阅读。<br>** Result variable name：创建一个对象变量，保存所有返回的结果</p><ol><li>配置好后，run一下看结果：<br><img src="/2017/04/03/接口测试/Jmeter 运用JDBC连接数据库/6.jpg" alt=""><br>All passed.</li></ol><p>扩展知识：</p><blockquote><p>Variable names: 如果给这个参数设置了值，它会保存sql语句返回的数据和返回数据的总行数。假如，sql语句返回2行，3列，且variables names设置为A,,C，那么如下变量会被设置为：　　A_#=2 (总行数)　　A_1=第1列, 第1行　　A_2=第1列, 第2行 　　C_#=2 (总行数) 　　C_1=第3列, 第1行　　C_2=第3列, 第2行如果返回结果为0，那么A_#和C_#会被设置为0，其它变量不会设置值。如果第一次返回6行数据，第二次只返回3行数据，那么第一次那多的3行数据变量会被清除。可以使用${A_#}、${A_1}...来获取相应的值</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter利用User Parameters读取外部文件</title>
      <link href="/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/Jmeter%E5%88%A9%E7%94%A8User%20Parameters%E8%AF%BB%E5%8F%96%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6/"/>
      <url>/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/Jmeter%E5%88%A9%E7%94%A8User%20Parameters%E8%AF%BB%E5%8F%96%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>上次我们讲了如何最优化的重用变量，我们使用了User Defined Variables，这些变量一般都是全局的，或者是常量， 假设我们用到的变量来自上一个请求，那么我们如何使用呢？（还记得前面的分享&lt; Jmeter 正则表达式提取器传参&gt;吗？）另外，我们发送的HTTP Request bodydata里，经常需要发送一大串的Json数据,我们之前是写到每一个请求的body里，那么有没有办法写到外部文件里以重用呢？<br><a id="more"></a><br>今天我们来讲如何使用User Parameters读取外部文件。<br>仍以我们之前的例子来说：</p><blockquote><p>假设我们的整个测试共有3个HTTP请求，第一步是用户登录，第二步是发送一个query string请求，获取服务器返回的memberid，token，tokentime， 第三步步就是把第二步返回的请求填入上述request body，然后发送请求，最终完成打分。</p></blockquote><p>第二步和第三步之间的参数传递我们已经在文章&lt; Jmeter 正则表达式提取器传参&gt;里实现了，第三部分的request body Data我们之前是放到一个个具体的HTTPRequest Sampler里的，这种方法的一个常见问题是，如果 JSON 结构（或数据）发现变化（也许是因为 API 参数的更改），那么您必须进入 JMeter 测试，找到 HTTP 请求的主体，并修改 JSON 结构（和数据），以满足新的要求。</p><p>那么如何解决这个问题呢？</p><p>我们以前的body data如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;SurveyResult&quot; : &#123;</div><div class="line">        &quot;SurveyTitle&quot; : &quot;ClassTechnicalSurvey&quot;,</div><div class="line">        &quot;SurveyId&quot; : 104,</div><div class="line">        &quot;MemberId&quot; : &quot;$&#123;m_id_g1&#125;&quot;,</div><div class="line">     &quot;ClassId&quot; : &quot;1422994&quot;,</div><div class="line">        &quot;Token&quot; :  $&#123;m_id_g2&#125;,</div><div class="line">        &quot;TokenTime&quot; : $&#123;m_id_g3&#125;</div><div class="line">    &#125;,</div><div class="line">&quot;Detail&quot; : [&#123;…&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ol><li><p>我们新建立一个json文件，名称customizejson.json，保存在目录..\ _testcase\jsontemplates下，<br>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;SurveyResult&quot; : &#123;</div><div class="line">        &quot;SurveyTitle&quot; : &quot;ClassTechnicalSurvey&quot;,</div><div class="line">        &quot;SurveyId&quot; : 104,</div><div class="line">        &quot;MemberId&quot; : &quot;$&#123;__eval($&#123;m_id_g1&#125;)&#125;&quot;,</div><div class="line">        &quot;ClassId&quot; : &quot;1422994&quot;,</div><div class="line">        &quot;Token&quot; : $&#123;__eval($&#123;m_id_g2&#125;)&#125;,</div><div class="line">        &quot;TokenTime&quot; : $&#123;__eval($&#123;m_id_g3&#125;)&#125;</div><div class="line">    &#125;,</div><div class="line">&quot;Detail&quot; : [&#123;…&#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述文件中的 JSON 为每个已定义的替代变量调用了 JMeter __eval() 函数。增加的这一步骤使得在运行时执行 JMeter 脚本的时候可以对变量进行计算。</p></li><li><p>在HTTP Request Smapler里，设置如下：<br><img src="/2017/04/03/接口测试/Jmeter利用User Parameters读取外部文件/1.png" alt=""><br>可以看到以前我们写在BodyData里的JSON数据被 ${__eval(${CUSTOMIZE_JSON})代替。</p></li><li><p>在这个Sampler上，右键点击Add-&gt;Pre processors-&gt;User Parameters<br><img src="/2017/04/03/接口测试/Jmeter利用User Parameters读取外部文件/2.png" alt=""></p></li><li><p>配置User Parameters 如下：<br><img src="/2017/04/03/接口测试/Jmeter利用User Parameters读取外部文件/3.png" alt=""><br>以上定义的CUSTOMIZE_JSON 变量就是前面步骤里在BodyData里填写的变量，它被设置为 FileToString()，并使用指向 JSON 模板文件的路径作为参数。JSON 实体模板文件的所有内容都被读入 CUSTOMIZE_JSON变量。因此，JSON 实体模板文件的内容是在运行时计算的，所定义的所有替代字符串都被翻译成为它们定义的数据。</p></li></ol><p>另外两个变量定义在myuser.properties文件里：</p><blockquote><p>#–Json template（路径不需要用引号括起来）<br>JSONTEMPLATE_ROOT=C:\apache-jmeter-2.13\_testcase\jsontemplates<br>CSVDATA_ROOT=C:\apache-jmeter-2.13\_testcase\jmeter_config.txt</p></blockquote><p>按上述步骤设置好，run一下，我们看看结果：<br><img src="/2017/04/03/接口测试/Jmeter利用User Parameters读取外部文件/4.png" alt=""><br>全部pass，并且相应的动态变量也被正确获取替换，成功！</p><p>扩展知识：</p><blockquote><p>__FileToString¶<br>The FileToString function can be used to read an entire file. Each time it is called it reads the entire file.<br>If an error occurs opening or reading the file, then the function returns the string “<strong>ERR</strong>“</p><p><strong>eval<br>The eval function returns the result of evaluating a string expression.<br>This allows one to interpolate variable and function references in a string which is stored in a variable. For example, given the following variables:<br>name=Smith<br>column=age<br>table=birthdays<br>SQL=select ${column} from ${table} where name=’${name}’<br>then ${</strong>eval(${SQL})} will evaluate as “select age from birthdays where name=’Smith’”.<br>This can be used in conjunction with CSV Dataset, for example where the both SQL statements and the values are defined in the data file. </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter 利用User Defined Variables实现变量重用</title>
      <link href="/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/Jmeter%20%E5%88%A9%E7%94%A8User%20Defined%20Variables%E5%AE%9E%E7%8E%B0%E5%8F%98%E9%87%8F%E9%87%8D%E7%94%A8/"/>
      <url>/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/Jmeter%20%E5%88%A9%E7%94%A8User%20Defined%20Variables%E5%AE%9E%E7%8E%B0%E5%8F%98%E9%87%8F%E9%87%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>我们上次讲了如何在不同的HTTP Request之间传递参数，今天来看下，如何优化 HTTP Request本身及如何高效使用变量<br><a id="more"></a><br>我们仍然以下述为例：</p><blockquote><p>假设我们的整个测试共有3个HTTP请求，第一步是用户登录，第二步是发送一个query string请求，获取服务器返回的memberid，token，tokentime， 第三步步就是把第二步返回的请求填入上述request body，然后发送请求，最终完成打分。</p></blockquote><p>对于我们的每一个HTTP请求，都需要用到Web Server。我们以前是把它们写在不同的请求中间，如果有变化我们需要一个个修改。其实我们可以把它们定义在一个自定义properties文件里读取，方法如下：</p><ol><li>在 jmeter.properties 文件中，取消对 user.properties 设置的注释，并 user.properties的值设置为所创建的文件的名称<br>在 jmeter.properties 文件中指定一个用户属性文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Should JMeter automatically load additional JMeter properties?</div><div class="line"># File name to look for (comment to disable)</div><div class="line">user.properties=myuser.properties</div></pre></td></tr></table></figure></li><li>更改myuser.properties文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#----------------------------------------------------------------</div><div class="line"># FVT API Test Environment parameters</div><div class="line">#----------------------------------------------------------------</div><div class="line">#</div><div class="line"># --- Login Credentials</div><div class="line">USER =test</div><div class="line">PASSWORD=test</div><div class="line">#</div><div class="line"># --- Application Server</div><div class="line">APP_SERVER=*.englishtown.com</div><div class="line">APP_PORT=80</div></pre></td></tr></table></figure></li><li><p>右键ThreadGroup-&gt;Add-&gt; Config Element-&gt;User Defined Variables<br><img src="/2017/04/03/接口测试/Jmeter 利用User Defined Variables实现变量重用/1.png" alt=""></p></li><li><p>配置Name 和Value如下：<br><img src="/2017/04/03/接口测试/Jmeter 利用User Defined Variables实现变量重用/2.png" alt=""><br>控制面板的 Value 列中的每个项目的格式为：</p><blockquote><p>${<strong>property(VARIABLE_NAME,VARIABLE_NAME)}<br>例如，来自用户属性文件myuser.properties的 APP_SERVER变量被读取为脚本中的 ${</strong>property(APP_SERVER, APP_SERVER)} 函数。</p></blockquote></li><li><p>引用时，在每一个HTTP Request的Server or IP里，填写 ${APP_SERVER}就可以了。<br>user_defined_variable3.png<br>扩展知识：</p><blockquote><p>在 JMETER_HOME/bin 目录下的三个文件中定义 JMeter 的属性和变量。在启动 JMeter 时，它会按以下顺序加载这些文件：<br>jmeter.properties<br>一个可选的用户定义的属性文件<br>system.properties<br>当 JMeter 正在运行的时候，如果要添加任何新属性或改变现有的属性，则必须先关闭 JMeter，然后重新启动它，使更改生效。<br>jmeter.properties 文件存储与 JMeter 应用程序本身有关的属性。这个文件中仅 保留了特定于 JMeter 程序的属性或特定于框架的属性。创建一个单独的文件（文件名由您选择），用该文件来存储测试环境特定的属性和变量，它们对于和接受测试的应用程序有关联的所有脚本来说是全局的属性和变量 — 例如，管理员的用户名/密码。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jmeter 正则表达式提取器传参</title>
      <link href="/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/Jmeter%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E5%99%A8%E4%BC%A0%E5%8F%82/"/>
      <url>/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/Jmeter%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E5%99%A8%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<p>上次我们讲了如何利用Jmeter做接口测试，讲的比较浅，今天来补充一点细节，如何在不同的HTTP Request间传递参数，即前一个请求的输出部分是后一个请求的输入时，应该怎么办<br><a id="more"></a></p><p>拿上次的教师打分API为例：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">POST: /survey/evc/EVCSurvey/Save</div><div class="line">UAT URL: http://**.englishtown.com/***/Survey/Save</div><div class="line">Save Survey Result Request </div><div class="line">&#123;</div><div class="line">    "SurveyResult" :   &#123;</div><div class="line">        "SurveyTitle" : "ClassTechnicalSurvey",</div><div class="line">        "SurveyId" :   1000000,</div><div class="line">        "MemberId" :   12345678,</div><div class="line">        "ClassId" : "987654321",</div><div class="line">        "Token" : "dd556a9d36c1984bbab94f37483f484f",</div><div class="line">        "TokenTime" : "2016-07-26T08:56:32.8807460Z"</div><div class="line">    &#125;,</div><div class="line">    "Detail" :   [&#123;</div><div class="line">            "Key" :   764, </div><div class="line">            "Value" :   1, </div><div class="line">            "Type" :   3, </div><div class="line">            "Order" :   1</div><div class="line">        &#125;,&#123;...&#125;</div><div class="line">   ]</div><div class="line">&#125;</div><div class="line">Save   Survey Result Response </div><div class="line">&#123;</div><div class="line">    "IsSuccess" : true,</div><div class="line">    "Description" : "",</div><div class="line">    "StatusCode" :   200 //200-&gt;Success, 0-&gt;None, -300-&gt;Invalid Parameter,</div><div class="line">  -400-&gt;Invalid Token,   -500-&gt;Unhandled Exception</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要使用这个API，我们发送的HTTP Request Body需要一些特定的信息，例如memberid， token， tokenTime等，上次的例子里我们把它们当作一个个变量保存在外部文件里，但显然不太合适，因为不同用户登录后用到的值都不相同，我们最后动态的获取他们。<br>下面来看看怎么做：<br>假设我们的整个测试共有3个HTTP请求，第一步是用户登录，第二步是发送一个query string请求，获取服务器返回的memberid，token，tokentime， 第三步就是把第二步返回的请求填入上述request body，然后发送请求，最终完成打分。<br>显然我们的传参行为发生在第二步和第三部， 我们先看参数获取，在第二步的HTTP Request请求下，右键点击Add-&gt;Post Processors-&gt;Regular  Expression Extractor<br><img src="/2017/04/03/接口测试/Jmeter 正则表达式提取器传参/1.png" alt=""><br>添加后可以看到正则表达式抽取器，我们看如何配置：<br><img src="/2017/04/03/接口测试/Jmeter 正则表达式提取器传参/2.png" alt=""><br>位置1：名称及注释<br>位置2：正则表达式提取内容的范围。（关于各字段的详细说明请查阅协议的相关说明）<br>位置3：正则表达式提取的相关设置<br>3.1引用名称：其他地方引用提取值的变量名称，如填写的是：m_id，具体的引用方式是${m_id}<br>3.2正则表达式：提取内容的正则表达式, 此例中我们需要提取3个参数【稍注意一下： () 表示提取，对于你要提前的内容需要用小括号括起来】。需要注意的是，这3个参数的正则表达式需要是一个，不能分割（就是一个正则匹配所有变量，我本来以为会有分隔符来分割）。<br>3.3模板：用$$引用起来，如果在正则表达式中有多个提取表达式（多个括号括起来的东东），则可以是$1$，$2$等等，表示解析到的第几个值给m_id，正则表达式的提取模式，值从1开始，值0对应的是整个匹配的表达式<br>3.4缺省值：正则匹配失败时取缺省值</p><p>下面我们给出第二步server的返回值的部分关键内容，结合上图3.2正则表达式的说明，来看下如何填写这个正则表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[&#123;&quot;member_id&quot;:23803871,</div><div class="line">                ...</div><div class="line">&quot;token&quot;:&quot;9c0ed9431545dfc3dbaf1e5c7c0ae9ee&quot;,</div><div class="line">&quot;tokenTime&quot;:&quot;2016-07-25T14:41:17.2994676Z&quot;,</div><div class="line">.....&#125;]</div></pre></td></tr></table></figure><br>由上可以看出，3.2正则表达式我们书写的”member<em>id”:([0-9]<em>).</em>“token”:(“[A-Za-z0-9</em>]<em>“).</em>“tokenTime”:(“[0-9A-Za-z-:.]*”) 可以全部匹配merberid，token， tokenTime的内容。<br>小技巧：可以google在线正则先去确保正则表达式书写正确，然后再按Jmeter语法写入。</p><p>拿到参数值后，如何传入下一个HTTP Request呢，非常简单，直接用第二步正则表达式里我们定义的引用名称（Reference Name）就可以了。本例用${m_id_g1}, ${m_id_g2}, ${m_id_g3} 来分别表示不同的参数。如图所示。<br><img src="/2017/04/03/接口测试/Jmeter 正则表达式提取器传参/3.png" alt=""><br>我们只定义了m_id一个引用变量，那么m_id_g1, m_id_g2是什么鬼？看下Jmeter语法：</p><blockquote><p>Suppose you want to match the following portion of a web-page:<br>name=”file.name” value=”readme.txt” and you want to extract both file.nameand readme.txt.<br>A suitable regular expression would be:<br>name=”([^”]+)” value=”([^”]+)”<br>This would create 2 groups, which could be used in the JMeter Regular Expression Extractor template as $1$ and $2$.<br>The JMeter Regex Extractor saves the values of the groups in additional variables.<br>For example, assume:<br>Reference Name: MYREF<br>Regex: name=”(.+?)” value=”(.+?)”<br>Template: $1$$2$<br>Do not enclose the regular expression in / /<br>The following variables would be set:<br>MYREF<br>file.namereadme.txt<br>MYREF_g0<br>name=”file.name” value=”readme.txt”<br>MYREF_g1<br>file.name<br>MYREF_g2<br>readme.txt<br>These variables can be referred to later on in the JMeter test plan, as ${MYREF},${MYREF_g1} etc.</p></blockquote><p>明白了吧，对于本例，tempalte用了$0$, 即取所有匹配的表达式，m_id_g1,则表示匹配的表达式里第一个匹配上的内容，m_id_g2就表示第2个，因为我们有正则匹配上3个符合的内容，g1,g2,g3分别表示这3个。<br>以上就是如何应用jmeter传参，更多内容敬请关注iTesting。</p>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口测试自动化框架实践指南（二）</title>
      <link href="/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接口测试自动化框架实践指南（二）<br><a id="more"></a></p><p>上次我们分享了接口自动化框架的第一部分Jmeter的脚本生成及参数化，今天我们来看第二部分：<br>Ant + Jenkins集成：</p><ol><li>通过ant一键执行一个或多个jmeter脚本，并批量生成html格式的报告。</li><li>通过Jenkins自动化构建，完成测试框架搭建并生成测试报告。<br>在此之前我们需正确安装并配置如下软件：</li></ol><p>验证java</p><blockquote><p>C:>Java -version<br>java version “1.8.0_06”</p></blockquote><p>验证ant</p><blockquote><p>C:>ant -version<br>Apache Ant(TM) version 1.9.6 compiled on June 29 2015</p></blockquote><p>使用Ant运行jmeter脚本。：<br>1、首先我们默认Jmeter脚本已经录制好了，并测试通过，存在（查询模块.jmx）脚本<br>2、为了能够在ant中使用jmeter task，必须将“ant-jmeter-1.1.1.jar”这个jar包放到ant的classpath中去。这个jar包位置 jmeter的安装目录下的 extras 目录中。<br>也可直接将这个jar拷贝至ant安装目录下的lib目录中。这样Ant运行时才能找到”org.programmerplanet.ant.taskdefs.jmeter.JMeterTask”这个类，从而成功触发JMeter脚本 。<br>3、jmeter默认保存的是.csv格式的文件，所以我们先要设置一下bin/jmeter.properties文件内容，保存    jmeter.save.saveservice.output_format=xml<br>4、使用Ant运行所有的*.jmx脚本，生成.jtl文件放入 ..\resultLog\jtl文件中，ant再将相应的文件转换为对应的html文件放入..\resultLog\html中.</p><p>build.xml文件中的内容如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line">&lt;project name="ant-jmeter-test" default="run" basedir="."&gt;</div><div class="line">    &lt;tstamp&gt;</div><div class="line">        &lt;format property="time" pattern="yyyyMMddhhmm" /&gt;</div><div class="line">    &lt;/tstamp&gt;</div><div class="line">    &lt;!-- 需要改成自己本地的 Jmeter 目录--&gt;  </div><div class="line">    &lt;property name="jmeter.home" value=".." /&gt;</div><div class="line">    &lt;!-- jmeter生成jtl格式的结果报告的路径--&gt; </div><div class="line">    &lt;property name="jmeter.result.jtl.dir" value="..\resultLog\jtl" /&gt;</div><div class="line">    &lt;!-- jmeter生成html格式的结果报告的路径--&gt;</div><div class="line">    &lt;property name="jmeter.result.html.dir" value="..\resultLog\html" /&gt;</div><div class="line">    &lt;!-- 生成的报告的前缀--&gt;  </div><div class="line">    &lt;property name="ReportName" value="TestReport" /&gt;</div><div class="line">    &lt;property name="jmeter.result.jtlName" value="$&#123;jmeter.result.jtl.dir&#125;/$&#123;ReportName&#125;$&#123;time&#125;.jtl" /&gt;</div><div class="line">    &lt;property name="jmeter.result.htmlName" value="$&#123;jmeter.result.html.dir&#125;/$&#123;ReportName&#125;$&#123;time&#125;.html" /&gt;</div><div class="line"></div><div class="line">    &lt;target name="run"&gt;</div><div class="line">        &lt;antcall target="test" /&gt;</div><div class="line">        &lt;antcall target="report" /&gt;</div><div class="line">    &lt;/target&gt;</div><div class="line">    &lt;target name="test"&gt;</div><div class="line">        &lt;taskdef name="jmeter" classname="org.programmerplanet.ant.taskdefs.jmeter.JMeterTask" /&gt;</div><div class="line">        &lt;jmeter jmeterhome="$&#123;jmeter.home&#125;" resultlog="$&#123;jmeter.result.jtlName&#125;"&gt;</div><div class="line">            &lt;!-- 声明要运行的脚本"*.jmx"指包含此目录下的所有jmeter脚本--&gt;</div><div class="line">            &lt;testplans dir="." includes="*.jmx" /&gt;</div><div class="line">            &lt;property name="jmeter.save.saveservice.output_format" value="xml"/&gt;</div><div class="line">        &lt;/jmeter&gt;</div><div class="line">    &lt;/target&gt;</div><div class="line">    &lt;path id="xslt.classpath"&gt;</div><div class="line">        &lt;fileset dir="$&#123;jmeter.home&#125;/lib" includes="xalan*.jar"/&gt;</div><div class="line">        &lt;fileset dir="$&#123;jmeter.home&#125;/lib" includes="serializer*.jar"/&gt;</div><div class="line">    &lt;/path&gt;</div><div class="line"></div><div class="line">    &lt;target name="report"&gt;</div><div class="line">        &lt;tstamp&gt; &lt;format property="report.datestamp" pattern="yyyy/MM/dd HH:mm" /&gt;&lt;/tstamp&gt;</div><div class="line">        &lt;xslt </div><div class="line">              classpathref="xslt.classpath"</div><div class="line">              force="true"</div><div class="line">              in="$&#123;jmeter.result.jtlName&#125;"</div><div class="line">              out="$&#123;jmeter.result.htmlName&#125;"</div><div class="line">              style="$&#123;jmeter.home&#125;/extras/jmeter-results-detail-report_21.xsl"&gt;</div><div class="line">              &lt;param name="dateReport" expression="$&#123;report.datestamp&#125;"/&gt;</div><div class="line">       &lt;/xslt&gt;</div><div class="line"></div><div class="line">                &lt;!-- 因为上面生成报告的时候，不会将相关的图片也一起拷贝至目标目录，所以，需要手动拷贝 --&gt; </div><div class="line">        &lt;copy todir="$&#123;jmeter.result.html.dir&#125;"&gt;</div><div class="line">            &lt;fileset dir="$&#123;jmeter.home&#125;/extras"&gt;</div><div class="line">                &lt;include name="collapse.png" /&gt;</div><div class="line">                &lt;include name="expand.png" /&gt;</div><div class="line">            &lt;/fileset&gt;</div><div class="line">        &lt;/copy&gt;</div><div class="line">    &lt;/target&gt;</div><div class="line"></div><div class="line">&lt;/project&gt;</div><div class="line"></div></pre></td></tr></table></figure></p><p>切换目录到build.xml所在文件夹，运行ant查看结果是否生成（<em>.jtl 和</em>.html）。</p><p>集成Jenkins。</p><ol><li>Jinkeins安装好后，需要添加如下插件：Performance plugin 、 HTML Publisher plugin  、ant  Git, Email Extension Plugin 插件。</li><li>在Manage Jenkins –&gt;Config System 里，配置JDK， Ant安装路径。</li><li>新建一个freestyle project，配置Source Code Management（一般选用Git）， Build Triggers（何时触发build运行）， 然后build下配置Execute shell，Ant， 然后在Post Build Actions下面配置Publish HTML Reports 和 Publish Performance Test Results Report， 如下图：<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（二）/1.jpg" alt=""></li></ol><p>配置好后Jenkins会根据你前文设置的Trigger自动download代码执行。结果如下：<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（二）/2.jpg" alt=""><br>到此为止我们的接口测试框架就搭建完成了， 怎么样是不很简单?</p><p>以上只是iTesting的一个简单接口测试框架，实际应用中，框架还有以下可以优化的地方：<br>1.Jmeter脚本的编写，参数化，及断言调用数据库，前一个post的返回结果是后一个post的入参（这个时候如何传递value）等。<br>2.Build.xml文件编写。这个决定了那些jmx file会运行，报告如何生成。<br>3.Jenkins配置，关键是HTML report和Performance report的配置。</p>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API-Test </tag>
            
            <tag> 测试框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口测试自动化框架实践指南（一）</title>
      <link href="/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>接口测试自动化框架实践指南<br><a id="more"></a></p><p>对接口测试概念和好处还不甚理解的同学，请移步iTesting的历史文章《接口（API）测试》。<br>今天介绍的接口测试自动化框架组成如下：<br>Jmeter  + Ant + Jenkins。<br>我们分为两个部分介绍：<br>1.Jmeter的脚本生成及参数化</p><ol><li>Ant + Jenkins集成<br>在详细框架搭建前，我们以一个Restful格式的API为例。这个API的是用做学生上完课后老师给学生的打分：<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">POST: /survey/evc/EVCSurvey/Save</div><div class="line">UAT URL: http://**.englishtown.com/***/Survey/Save</div><div class="line">Save Survey Result Request </div><div class="line">&#123;</div><div class="line">    "SurveyResult" : &#123;</div><div class="line">        "SurveyTitle" : "ClassTechnicalSurvey",</div><div class="line">        "SurveyId" : 1000000,</div><div class="line">        "MemberId" : 12345678,</div><div class="line">        "ClassId" : "987654321",</div><div class="line">        "Token" : "dd556a9d36c1984bbab94f37483f484f",</div><div class="line">        "TokenTime" : "2016-04-24T08:56:32.8807460Z"</div><div class="line">    &#125;,</div><div class="line">    "Detail" : [&#123;</div><div class="line">            "Key" : 764, </div><div class="line">            "Value" : 1, </div><div class="line">            "Type" : 3, </div><div class="line">            "Order" : 1</div><div class="line">        &#125;,&#123;...&#125;</div><div class="line">   ]</div><div class="line">&#125;</div><div class="line">Save   Survey Result Response </div><div class="line">&#123;</div><div class="line">    "IsSuccess" : true,</div><div class="line">    "Description" : "",</div><div class="line">    "StatusCode" : 200 //200-&gt;Success, 0-&gt;None, -300-&gt;Invalid Parameter,</div><div class="line"> -400-&gt;Invalid Token, -500-&gt;Unhandled Exception</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>我们来看看如何测试这个接口：</p><ol><li>手工写test case（如入参的检查，返回值检查，数据库查询，invalid case等不再赘述）</li><li>把test case转成一个个jmeter脚本。</li><li>运行脚本，查看期望结果（例如返回值，数据库记录等）。</li><li>用Ant生成build.xml文件，并成功运行并生成jtl和html格式报告。</li><li>集成Ant到Jenkins, 配置自动运行并生成测试报告发送邮件等。<br>今天先介绍第一部分Jmeter的脚本生成及参数化：<br>我们拿正确输入入参，返回正确返回值为例，来介绍如何生成Jmeter脚本。<br>Jmeter安装好后，我们先添加需要用到的选项，按以下步骤添加：</li><li>右键Test Plan，Add → ThreadGroup.</li><li><p>右键ThreadGroup， Add → Config Element → HTTP Request Defaults.<br>设置 Server name or IP （*.englishtown.com）， port留空。<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（一）/1.jpg" alt=""></p></li><li><p>右键ThreadGroup， Add → Config Element → HTTP Cookie Manager</p></li><li>右键ThreadGroup， Add → Config Element → HTTP Header Manager并设置如下：<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（一）/2.jpg" alt=""></li><li>然后右键ThreadGroup，分别<br>add-&gt;Listener-&gt; Aggregate Report<br>add-&gt;Listener-&gt; Aggregate ReportView Results in Tree<br>add-&gt;Listener-&gt; Aggregate ReportSummary Report<br>关注iTesting，后续更精彩。</li><li>然后右键ThreadGroup，add-&gt;Config Element-&gt;CSV Data Set Config， 重命名为set variable。并设置如下（这个txt文件里为参数化的值）：<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（一）/3.jpg" alt=""></li><li><p>然后右键ThreadGroup，add-&gt;Sampler-&gt;HTTP Request，并重命名为suvery，根据前文API的描述，我们的post请求里配置如下（放在Body Data里），Jmeter参数化格式 ${}：<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（一）/4.jpg" alt=""></p></li><li><p>然后右键suvery， add-&gt;Assertions-&gt;Response Assertions， 并根据API返回值设置assertion<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（一）/5.jpg" alt=""></p></li><li><p>最终我们得到以下配置项并配置完毕如下图所示，点击Run运行。<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（一）/6.jpg" alt=""></p></li><li>我们得到的结果如下。<br><img src="/2017/04/03/接口测试/接口测试自动化框架实践指南（一）/7.jpg" alt=""></li><li>最后我们检查下数据库看看有没有写入就可以了。<br>以上是用jmeter生成脚本，如果不想通过GUI方式运行，也可以用命令行直接调用：格式如下：<br>-n This specifies JMeter is to run in non-gui mode<br>-t [name of JMX file that contains the Test Plan].<br>-l [name of JTL file to log sample results to].<br>-r Run all remote servers specified in JMeter.properties (or remote servers specified on command line by overriding properties)<br>The script  also lets you specify the optional firewall/proxy server information:<br>-H [proxy server hostname or ip address]<br>-P [proxy server port]<br>Example : JMeter -n -t my_test.jmx -l log.jtl -H my.proxy.server -P 8000<br>对于我们的例子如下：<br>C:\apache-jmeter-2.13\bin&gt;jmeter -n -t C:\Users\kevin.cai\Desktop\HTTP_Request.j<br>mx -l log.jtl</li></ol><p>到此jmeter脚本就生成了，文件后缀*.jmx。我们可以根据需求设计出更多的jmeter脚本以备后用。 明天我们讲如何集成Ant和Jenkins。</p>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API-Test </tag>
            
            <tag> 测试框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口（API）测试</title>
      <link href="/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3(API)%E6%B5%8B%E8%AF%95/"/>
      <url>/2017/04/03/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/%E6%8E%A5%E5%8F%A3(API)%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>什么是接口测试<br><a id="more"></a></p><p>1.什么是接口测试<br>接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。（像不像集成测试？）</p><p>接口可以分下面几种 ：<br>第一种是函数级别的，测试需要对接口的各个参数进行测试，如：<br>Int MathAdd（int a， int b）。<br>第二种是对象级别的，开发在使用API接口时，先引入包名，在使用之前声明一个对象，之后可以使用对象提供的方法，而测试时，需要测试的是API的功能及对数据输入的正确性。第二种和第一种的差别是，我们只需关注提供给用户使用的接口就可以了，不用关心接口调用其他函数情况，相对于第一种来说，测试的粒度要大一些，范围小一些。<br>第三种是http协议的接口，App客户端和后端服务连接，一般采用的都是http协议，客户端通过get和post的方法从后端服务获取数据。第三种相对于第二种来说，粒度更大，我们关注的接口更少，但是这些接口都是核心功能。</p><p>而我们所要做的接口测试，先要了解是基于哪一种类型的接口测试，不同类型的接口测试方法可能是不一致的，总体来说，不管是那种类型，我们只要把被测接口当做是服务方，而把我们的测试手段当做是客户方，我们的目的就是，通过我们的测试手段，去验证服务端满足了他声明提供的功能。</p><ol><li><p>接口测试的目的<br>接口测试的目的是测试接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换，传递和控制管理过程，还包括处理的次数。外部接口测试一般是作为系统测试来看待的。</p></li><li><p>为什么做接口测试<br>节省测试成本，数据模型推算，N多上层bug是由于地层的同一bug引起的，接口测试能够提供系统复杂度上升情况下的低成本高效率的解决方案。</p></li></ol><p>接口测试实施在多系统多平台的构架下，有着极为高效的成本收益比，接口测试天生为搞复杂性的平台带来高效的缺陷监测和质量监督能力。平台越复杂，系统越庞大，接口测试的效果越明显。</p><ol><li>如何设计接口测试用例<br>接口测试用例设计和测试用例设计一样，用例设计的内容应该包括：主要测试功能点、测试环境、测试数据、执行操作以及预期结果。</li></ol><p>选择好测试对象。对于一个系统做接口测试选择好的测试对象是接口测试关键， 因为我们不可能测试所有接口。</p><p>可将这些最外层的接口分为两类：<br>1). 数据进入系统的接口；<br>进入系统的接口实际是我们用例的执行调用的接口。可通过变化参数对这些接口进行调用 ，模拟外部的使用；<br>2). 数据流出系统的接口。<br>流出的接口则是我们用例真正该验证的点。数据从哪里流出，流出时的状态如何 ，此时系统又是什么状态都是我们所应该验证的。</p><p>确认完整的测试对象的功能.确认外部接口提供给使用这些接口的外部用户什么样的功能，外部用户真正需要什么样的功能。此两个功能一定要准确详细，用例的设计要严格按照测试对象功能设计才是正确的用例。最后当出发点、对象、功能都确定了，就可以真正设计用例了。</p><ol><li>接口测试工具<br>Wireshark<br>Postman<br>SoapUI</li></ol><p>web接口测试 :<br>服务器接口测试：<br>是测试浏览器与服务器的接口。这个很容易理解，我们知道web开发一般分前端和后端，前端开发人员用html/css/javascript等技术。后端开发人用php/java/python/ruby等各种语言。用户输入的数据是输入到的前端页面上，怎样把这些数据传递的后台的呢？通过http协议的get与post请求来实现前后端的数据传递。这也可认为是接口测试，调用的登录接口还是查询接口，传参的是用户密码还是搜索关键字。</p><p>外部接口测试：<br>这个很典型的例子就是第三方登录，比如你做的新系统免于新用户重新注册的麻烦会提供第三方登录，那用户在登录的时候调用的就是第三方登录的接口，由第三方验证用户名和密码并且返回给当前系统。</p><p>web接口测试要点：<br>1、请求是否正确，默认请求成功是200，如果请求错误也能返回404、500等。<br>2、检查返回数据的正确性与格式；json是一种非常创建的格式。<br>3、接口的安全性，一般web都不会暴露在网上任意被调用，需要做一些限制，比如鉴权或认证。<br>4、接口的性能，web接口同样注重性能，这直接影响用户的使用体验.</p>]]></content>
      
      
      <categories>
          
          <category> api-test </category>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API-Test </tag>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动APP专项测试</title>
      <link href="/2017/04/03/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E7%A7%BB%E5%8A%A8APP%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
      <url>/2017/04/03/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E7%A7%BB%E5%8A%A8APP%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>APP测试，除了传统的那些测试方法外，需要额外关注以下方面：<br>兼容性测试、流量测试、电量测试、弱网络测试、稳定性测试、安全测试和环境相关测试。<br><a id="more"></a></p><p>第一：兼容性测试<br>针对App通常会考虑这些方面：<br>1）操作系统版本<br>包括Andoird版本，iOS版本<br>2）屏幕分辨率<br>android 800<em>480, 960</em>640,1280<em>720(720p),1920</em>1080(1080p),2560*1440(2k).<br>对于iOS,考虑最近几代机型对应的分辨率即可.<br>3）不同厂家的ROM<br>不同厂家的ROM,大多厂家都对android 系统进行了定制、实际中会遇到例如调用相机和底层服务出现的不兼容问题以及摇一摇遇到的不同手机对于方向和重力传感器灵敏度设置不同的问题.<br>4) 网络类型<br>网络类型通常考虑wifi,2g,3g4g下的功能情况。另外针对m版网站考虑不同浏览器类型和屏幕分辨率.<br>第二：流量测试<br>在移动产品的测试中，很有必要对App使用的流量进行度量，大致来说，流量可以从用户使用的的相关性角度分为：一类是用户的操作直接导致的流量消耗；另一类是后台，即在用户没有直接使用情况下的流量消耗。<br>流量的测试方法：<br>基于系统自带功能.<br>eg android proc/uid_stat/{uid} /tcp_send<br>     android proc/uid_stat/{uid} /tcp_rcv<br>通过API或者系统埋点来获取数据。<br>通用的流量测试方法：手机抓包，或者wifi代理（Fiddler， Charles）。<br>常见的流量节省方法：<br>数据压缩。<br>压缩包含接口文本数据的压缩，js文件的压缩及图片的压缩。<br>不同数据格式的采用<br>例如采用JSON格式作为接口数据返回格式通常比XML格式要小。<br>控制访问的频次<br>这个主要针对后台数据上报，PUSH消息检查等定时机制的。<br>只获取必要的数据<br>有时候APP一页的内容非常多，而用户可能只会看一部分，过多的从后台拉去数据就是浪费，所以可以采用分屏加载或者懒加载的方式来减少流量消耗。<br>缓存<br>可将图片，js等数据暂存起来，但由于手机存储空间有限，也需要控制整个缓存大小，并给用户提供清理缓存的选项。<br>针对不同网络类型设计不同的访问策略<br>有些APP不同的网络类型返回的内容不一样。<br>第三：电量测试<br>在电器电池技术没有取得巨大突破前提下，这方面始终会存在一些瓶颈，如果一些App架构设计的不好，或者代码偶缺陷，就可能导致电量消耗比较高，所以电量测试也是很重要的。<br>工具 GSam Battery Monitor Pro.<br>第四：弱网络测试<br>移动互联网产品相比PC互联网产品，有一个特点是前者使用的网络比较多样，除了Wif之外，很多时候是在移动网络下使用的，移动网络遇到的情况又比较复杂，比如地铁、隧道、体育场等。所以网络不稳定的情况是比较容易发生的，很多情况下App的一些问题是在复杂的网络情况下才会暴露，与其让用户发现和投诉这些问题，不如我们在测试阶段尽量模拟这样的网络情况，及早发现和修复这些问题。<br>工具：<br>Windows下的Network Delay Simulator<br>Mac下的Network Link Conditioner<br>第五：稳定性测试<br>在保证基本功能正确基础之上，App的稳定性就显得非常重要，如果一个App经常出现闪退或者卡死，那么用户体验就会受到很大伤害，在有其他竞争产品的情况下很容易造成用户的流失。<br>第六：安全测试<br>包括安装包的安全测试（能否反编译代码、安装包是否签名，完整性校验，权限设置检查等）。<br>敏感信息测试（数据库，日志，配置文件）。<br>软键盘劫持（金融类APP登录页面的用户名密码输入框）、<br>账户安全（密码是否明文，密码传输是否加密，账户输入错误次数过多锁定，同时会话提醒， 注销机制）<br>数据通信安全（关键数据是否散列或加密，关键连接是否使用安全通信，是否对数字证书合法性进行验证，是否校验数据合法性。<br>组件安全测试。<br>服务器端接口测试（SQL注入测试、XSS跨站脚本攻击， CSRF跨站请求伪造，越权访问等）。<br>第七：环境相关的测试<br>在实际项目中，有一些缺陷我发现是和App所处的运行环境相关的，所以设计测试的时候，要多考虑这些场景，比如：<br>1）干扰测试<br>收到电话、收到短信、收到通知栏消息、无电提示框弹出、第三方安全软件告警弹出。<br>2）权限测试<br>一些用户在实际使用App的时候回有意识阻止某些功能。例如有的用户感觉让某个App访问电话本或者相册可能泄漏隐私，就在手机中设置了禁止了该App访问相册的权限。<br>3）边界测试<br>手机环境本身也有其边界情况需要在测试中覆盖。常见的场景有：<br>可用存储空间过少、没有SD卡/双SD卡、飞行模式、系统时间有误（晚于和早于标准时间）、第三方依赖（比如我们的App依赖第三方App，但是现在第三方App没有安装或者版本过低的测试情况）。<br>4）Android定位测试<br>用白盒方式模拟</p>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mobile-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载压力测试</title>
      <link href="/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E8%B4%9F%E8%BD%BD%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
      <url>/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E8%B4%9F%E8%BD%BD%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>负载压力测试是在一定约束条件下测试系统所能承受的并发用户量、运行时间、数据量，以确定系统所能承受的最大负载压力。<br><a id="more"></a></p><p>负载压力测试有助于确认被测系统是否能够支持性能需求，以及预期的负载增长等。负载压力测试不只是关注不同负载场景下的响应时间等指标，它也要通过测试来发现在不同负载场景下会出现的，例如速度变慢、内存泄漏等问题的原因。负载压力测试是性能测试的重要组成部分，负载压力测试包括并发性能测试、疲劳强度测试、大数据量测试等内容。一般包括如下： </p><h5 id="1-性能测试"><a href="#1-性能测试" class="headerlink" title="1. 性能测试"></a>1. 性能测试</h5><p>性能测试用来保证产品发布后系统的性能能够满足用户需求。其中系统性能包括执行效率、资源占用、稳定性、安全性、兼容性、可扩展性、可靠性等。</p><h5 id="2-性能评测"><a href="#2-性能评测" class="headerlink" title="2. 性能评测"></a>2. 性能评测</h5><p>性能评测包括：在真实环境下，检查系统服务等级的满足情况，评估并报告整个系统的性能；对系统的未来容量作出预测和规划。<br>负载压力测试结构剖析</p><h5 id="3-性能调优"><a href="#3-性能调优" class="headerlink" title="3. 性能调优"></a>3. 性能调优</h5><p>性能调优一般的步骤为首先查找形成系统瓶颈或者故障的根本原因，其次是进行性能调整和优化，最后便是评估性能调整的结果。</p><h5 id="4-负载测试"><a href="#4-负载测试" class="headerlink" title="4. 负载测试"></a>4. 负载测试</h5><p>负载测试时通过逐步增加系统负载，测试系统性能的变化，并最终确定在满足性能指标的情况下，系统所能承受的最大负载量的测试。</p><h5 id="5-压力测试"><a href="#5-压力测试" class="headerlink" title="5. 压力测试"></a>5. 压力测试</h5><p>压力测试是通过逐步增加系统负载，测试系统性能的变化，并最终确定在什么负载条件下系统性能处于失效状态，并以此来获得系统能提供的最大服务级别的测试。</p><h5 id="6-并发性测试"><a href="#6-并发性测试" class="headerlink" title="6. 并发性测试"></a>6. 并发性测试</h5><p>并发性测试的过程，是一个负载测试和压力测试的过程。即逐渐增加并发用户数负载，直到系统的瓶颈或者不能接收的性能点。并发性测试分为三类：<br>a、应用在客户端性能的测试；<br>b、应用在网络上性能的测试；<br>c、应用在服务器上性能的测试；</p><h5 id="7-疲劳强度测试"><a href="#7-疲劳强度测试" class="headerlink" title="7. 疲劳强度测试"></a>7. 疲劳强度测试</h5><h5 id="8-大数据量测试"><a href="#8-大数据量测试" class="headerlink" title="8. 大数据量测试"></a>8. 大数据量测试</h5><p>大数据量测试包括独立的数据量测试和综合数据量测试两类。</p><h4 id="负载压力测试的目的："><a href="#负载压力测试的目的：" class="headerlink" title="负载压力测试的目的："></a>负载压力测试的目的：</h4><ol><li>在真实环境下检测系统性能，评估系统性能以及服务等级的满足情况</li></ol><p>例如电信计费软件，众所周知，每月20日左右是市话交费的高峰期，全市几千个收费网点同时启动。收费过程一般分为两步，首先要根据用户提出的电话号码来查询出其当月产生费用，然后收取现金并将此用户修改为已交费状态。一个看起来简单的两个步骤，当成百上千的终端同时执行这样的操作时情况就大不一样了，如此众多的交易同时发生，对应用程序本身、操作系统、中心数据库服务器、中间件服务器、网络设备的承受力都是一个严峻的考验。决策者需要模拟系统负载压力，预见软件的并发承受力，这是在测试阶段就应该解决的重要问题。</p><p>一个企业自己组织力量或委托软件公司代为开发的应用系统，在生产环境中实际使用起来以后，往往会产生这样一个问题，即这套系统能不能承受大量的并发用户同时访问，这个问题是系统负载压力需求的体现。</p><p>这里强调在真实环境下检测系统性能，在实施过程中大家认为这样做会遇到很多阻力，比如系统上线运行之后，真实环境下不允许负载压力测试为系统带来大量的垃圾数据，测试数据与真实业务数据混在一起无法控制测试结果，负载压力测试如果使服务器宕机会给系统带来巨大损失等。那么在这种条件下不允许的情况下，应该采用什么肃然措施弥补呢？我们可以使用一种“模拟环境”来做测试，这种环境是指与实际真实应用环境基本等级保持一致的测试环境。</p><ol><li>预见系统负载压力承受力，在应用实际部署之前，评估系统性能。</li></ol><p>目前的大多数公司企业需要支持成百上千名用户，各类应用环境，以及由不同供应商的元件组装起来的复杂产品。难以预知的用户负载和越来载复杂的应用程序，使公司时时担忧会发生投放性能差，用户遭受反应慢，系统失灵等问题。其结果就是导致公司收益的损失。</p><p>检测系统性能强调对系统当前性能的评估中，通过评估，可以在应用实际部署之前，预见系统负载压力承受力。这种测试的意义在于指导系统总体设计，既可以避免浪费不必要的人力、物力和财力，又避免硬件和软件的设计不匹配，使系统具有更长、更健壮的生命力。</p><p>如何确定系统的“负载压力承受力”是一个非常复杂且关键的问题。</p><p>对于系统性能检测，有时我们所从事的工作仅仅是被动监控一些性能指标，而预见系统负载压力承受力，则不可避免地会借助自动化的负载压力测试工具。</p><ol><li>分析系统瓶颈、优化系统</li></ol><p>系统性能检测和预见为分析系统瓶颈和优化提供了原始数据，打好了基础。</p><p>系统瓶颈即应用系统中导致系统性能大幅下降的原因。</p><p>瓶颈大大降低了系统性能，一般情况下，发现瓶颈并找出原因并不是件容易的事。很多时候你可能无法准确定位系统瓶颈之所在。瓶颈可能定位在硬件中，也可能定位在软件中，对于后者，是无能为力的。硬件中的瓶颈可能会非常容易排除,一般来讲，解决硬件瓶颈的方法只是简单地向系统中添加CPU、磁盘或者内存等，如果硬件瓶颈是由于系统缓冲区设计或内存总线造成的，那么通常情况下就无能为力了。硬件瓶颈与软件瓶颈相比，更建议先解决软件瓶颈，原因有三，其一是软件瓶颈往往导致系统性能衰减更快，反过来讲，消除软件瓶颈，系统性能提升更快；其二是人为因素更易导致软件瓶颈，要消除软件瓶颈，开发人员会更主动，并且可以节省资源；其三，盲目增加硬件则无形中增加维护费用，将来，软硬件不匹配的问题终究还会暴露出来。</p><p>优化调整系统是在发现瓶颈，故障定位之后要完成的事情，实现优化之后即可消除瓶颈，提高性能。</p><p>性能测试指标：</p><table><thead><tr><th>指标</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>ProcessorTime</td><td style="text-align:center">服务器CPU占用率，一般平均达到70%时，服务就接近饱和</td></tr><tr><td>Memory Available Mbyte</td><td style="text-align:center">可用内存数，如果测试时发现内存有变化情况也要注意，如果是内存泄露则比较严重</td></tr><tr><td>Physicsdisk Time</td><td style="text-align:center">物理磁盘读写时间情况</td></tr></tbody></table><p>Web服务器指标</p><table><thead><tr><th>指标</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>Requests Per Second（Avg Rps）</td><td style="text-align:center">平均每秒钟响应次数＝总请求时间 / 秒数</td></tr><tr><td>Avg time to last byte per terstion （mstes）</td><td style="text-align:center">平均每秒业务脚本的迭代次数 ,有人会把上面那个混淆</td></tr><tr><td>Successful Rounds</td><td style="text-align:center">成功的请求</td></tr><tr><td>Failed Requests</td><td style="text-align:center">失败的请求</td></tr><tr><td>Successful Hits</td><td style="text-align:center">成功的点击次数</td></tr><tr><td>Failed Hits</td><td style="text-align:center">失败的点击次数</td></tr><tr><td>Hits Per Second</td><td style="text-align:center">每秒点击次数</td></tr><tr><td>Successful Hits Per Second</td><td style="text-align:center">每秒成功的点击次数</td></tr><tr><td>Failed Hits Per Second</td><td style="text-align:center">每秒失败的点击次数</td></tr><tr><td>Attempted Connections</td><td style="text-align:center">尝试链接数</td></tr></tbody></table><table><thead><tr><th>指标</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>User 0 Connections</td><td style="text-align:center">用户连接数，也就是数据库的连接数量</td></tr><tr><td>Number of deadlocks</td><td style="text-align:center">数据库死锁</td></tr><tr><td>Butter Cache hit</td><td style="text-align:center">数据库Cache的命中情况</td></tr></tbody></table><p>系统的瓶颈定义  </p><table><thead><tr><th>性能项</th><th style="text-align:center">命令</th><th style="text-align:right">指标</th></tr></thead><tbody><tr><td>CPU限制</td><td style="text-align:center">vmstat</td><td style="text-align:right">当%user+%sys超过80%时</td></tr><tr><td>磁盘I/O限制</td><td style="text-align:center">Vmstat</td><td style="text-align:right">当%iowait超过40%(AIX4.3.3或更高版本)时</td></tr><tr><td>应用磁盘限制</td><td style="text-align:center">Iostat</td><td style="text-align:right">当%tm_act超过70%时</td></tr><tr><td>虚存空间少</td><td style="text-align:center">Lsps，-a</td><td style="text-align:right">当分页空间的活动率超过70%时</td></tr><tr><td>换页限制</td><td style="text-align:center">Iostat, stat</td><td style="text-align:right">虚存逻辑卷%tm_act超过I/O(iostat)的30%，激活的虚存率超过CPU数量(vmstat)的10倍时</td></tr><tr><td>系统失效</td><td style="text-align:center">Vmstat, sar</td><td style="text-align:right">页交换增大、CPU等待并运行队列</td></tr></tbody></table><p>稳定系统的资源状态<br><img src="/2017/04/03/软件测试基础知识系列/负载压力测试/1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试，集成测试，系统测试，确认测试</title>
      <link href="/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%EF%BC%8C%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%EF%BC%8C%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95/"/>
      <url>/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8C%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%EF%BC%8C%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%EF%BC%8C%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>从测试阶段的划分可以分为单元测试、集成测试、系统测试、确认测试。下面内容来自网络相关资料的整理。<br><a id="more"></a></p><h5 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h5><pre><code>（1）定义：单元测试（又称为模块测试）是针对程序模块(软件设计的最小单位)来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</code></pre><p>　  （2）单元测试任务包括：<br>1 模块接口测试；<br>2 模块局部数据结构测试；<br>3 模块边界条件测试；<br>4 模块中所有独立执行通路测试；<br>5 模块的各条错误处理通路测试。</p><p>　　模块接口测试是单元测试的基础。只有在数据能正确流入、流出模块的前提下，其他测试才有意义。测试接口正确与否应该考虑下列因素：<br>　　1 输入的实际参数与形式参数的个数是否相同；<br>　　2 输入的实际参数与形式参数的属性是否匹配；<br>　　3 输入的实际参数与形式参数的量纲是否一致；<br>　　4 调用其他模块时所给实际参数的个数是否与被调模块的形参个数相同；<br>　　5 调用其他模块时所给实际参数的属性是否与被调模块的形参属性匹配；<br>　　6 调用其他模块时所给实际参数的量纲是否与被调模块的形参量纲一致；<br>　　7 调用预定义函数时所用参数的个数、属性和次序是否正确；<br>　　8 是否存在与当前入口点无关的参数引用；<br>　　9 是否修改了只读型参数；<br>　　10 对全程变量的定义各模块是否一致；<br>　　11是否把某些约束作为参数传递。</p><p>　　如果模块内包括外部输入输出，还应该考虑下列因素：<br>　　1 文件属性是否正确；<br>　　2 OPEN/CLOSE语句是否正确；<br>　　3 格式说明与输入输出语句是否匹配；<br>　　4缓冲区大小与记录长度是否匹配；<br>　　5文件使用前是否已经打开；<br>　　6是否处理了文件尾；<br>　　7是否处理了输入/输出错误；<br>　　8输出信息中是否有文字性错误；</p><p>　　检查局部数据结构是为了保证临时存储在模块内的数据在程序执行过程中完整、正确。局部数据结构往往是错误的根源，应仔细设计测试用例，力求发现下面几类错误：<br>　　1 不合适或不相容的类型说明；<br>　　2 变量无初值；<br>　　3 变量初始化或省缺值有错；<br>　　4 不正确的变量名（拼错或不正确地截断）；<br>　　5 出现上溢、下溢和地址异常。</p><p>　　除了局部数据结构外，如果可能，单元测试时还应该查清全局数据（例如FORTRAN的公用区）对模块的影响。</p><p>　　在模块中应对每一条独立执行路径进行测试，单元测试的基本任务是保证模块中每条语句至少执行一次。此时设计测试用例是为了发现因错误计算、不正确的比较和不适当的控制流造成的错误。此时基本路径测试和循环测试是最常用且最有效的测试技术。计算中常见的错误包括：<br>　　1 误解或用错了算符优先级；<br>　　2混合类型运算；<br>　　3变量初值错；<br>　　4精度不够；<br>　　5表达式符号错。</p><p>　　比较判断与控制流常常紧密相关，测试用例还应致力于发现下列错误：<br>　　1不同数据类型的对象之间进行比较；<br>　　2错误地使用逻辑运算符或优先级；<br>　　3因计算机表示的局限性，期望理论上相等而实际上不相等的两个量相等；<br>　　4比较运算或变量出错；<br>　　5循环终止条件或不可能出现；<br>　　6迭代发散时不能退出；<br>　　7错误地修改了循环变量。</p><p>　　一个好的设计应能预见各种出错条件，并预设各种出错处理通路，出错处理通路同样需要认真测试，测试应着重检查下列问题：<br>　　1输出的出错信息难以理解；<br>　　2记录的错误与实际遇到的错误不相符；<br>　　3在程序自定义的出错处理段运行之前，系统已介入；<br>　　4异常处理不当；<br>　　5错误陈述中未能提供足够的定位出错信息。</p><p>　　边界条件测试是单元测试中最后，也是最重要的一项任务。众的周知，软件经常在边界上失效，采用边界值分析技术，针对边界值及其左、右设计测试用例，很有可能发现新的错误。<br>   （3）单元测试过程<br>　　一般认为单元测试应紧接在编码之后，当源程序编制完成并通过复审和编译检查，便可开始单元测试。测试用例的设计应与复审工作相结合，根据设计信息选取测试数据，将增大发现上述各类错误的可能性。在确定测试用例的同时，应给出期望结果。<br>　　应为测试模块开发一个驱动模块（driver）和（或）若干个桩模块（stub）,下图显示了一般单元测试的环境。驱动模块在大多数场合称为“主程序”，它接收测试数据并将这些数据传递到被测试模块，被测试模块被调用后，“主程序”打印“进入-退出”消息。<br>　　驱动模块和桩模块是测试使用的软件，而不是软件产品的组成部分，但它需要一定的开发费用。若驱动和桩模块比较简单，实际开销相对低些。遗憾的是，仅用简单的驱动模块和桩模块不能完成某些模块的测试任务，这些模块的单元测试只能采用下面讨论的综合测试方法。<br>　　提高模块的内聚度可简化单元测试，如果每个模块只能完成一个，所需测试用例数目将显著减少，模块中的错误也更容易发现。集成测试：在单元测试的基础上，将模块按照设计要求组装进行测试。一般包括逻辑关系检查、数据关系检查、业务关系检查、模块间接口检查、外部接口检查。</p><h5 id="2-集成测试"><a href="#2-集成测试" class="headerlink" title="2. 集成测试"></a>2. 集成测试</h5><pre><code>（1）定义： 集成测试也叫组装测试、联合测试、子系统测试或部件测试。集成测试是在单元测试的基础上，将所有模块按照概要设计要求组装成为子系统或系统。</code></pre><p>   （2）集成测试的关注点：<br>　　1.在把各个模块连接起来时，穿越模块接口的数据是否会丢失。<br>　　2.各个子功能组合起来，能否达到预期的要求的父功能。<br>　　3.一个模块的功能是否会对另一个模块的功能产生不利的影响。<br>　　4.全局数据结构是否有问题，会不会被异常修改。<br>　　5.单个模块的误差积累起来，是否会放大，从而达到不可接受的程度。<br>   （3）集成测试的模式：<br>     ① 非增殖式集成方式。先分别测试每个模块，再把所有模块按设计要求一次全部组装起来所要的系统，然后进行整体测试。使用这种方式可能发现一大堆错误，但为每个错误定位和纠正非常困难，并且在改正一个错误的同时又可能引入新的错误，新旧错误混杂，更难断定出错的原因和位置。<br>　　② 增殖式集成方式。又称渐增式集成方式。首先对一个个模块进行模块测试，然后将这些模块逐步组装成较大的系统，在组装的过程中边连接边测试，以发现连接过程中产生的问题。最后通过增殖逐步组装成为要求的软件系统。 常用的增殖方法有：自顶向下集成测试、自底向上集成测试、核心集成测试等。<br>　　自顶向下的增殖方式：将模块按系统程序结构，沿控制层次自顶向下进行集成。由于这种增殖方式在测试过程中较早地验证了主要的控制和判断点。在一个功能划分合理的程序结构中，判断常出现在较高的层次，较早就能遇到。如果主要控制有问题，尽早发现它能够减少以后的返工。<br>　　自底向上的增殖方式：从程序结构的最底层模块开始组装和测试。因为模块是自底向上进行组装，对于一个给定层次的模块，它的子模块(包括子模块的所有下属模块)已经组装并测试完成，所以不再需要桩模块。在模块的测试过程中需要从子模块得到的信息可以直接运行子模块得到。<br>    自顶向下增殖的方式和自底向上增殖的方式各有优缺点。自顶向下增殖方式的缺点是需要建立桩模块。要使桩模块能够模拟实际子模块的功能将是十分困难的。同时涉及复杂算法和真正输入/输出的模块一般在底层，它们是最容易出问题的模块，到组装和测试的后期才遇到这些模块，一旦发现问题，导致过多的回归测试。而自顶向下增殖方式的优点是能够较早地发现在主要控制方面的问题。自底向上增殖方式的缺点是“程序一直未能做为一个实体存在，直到最后一个模块加上去后才形成一个实体”。就是说，在自底向上组装和测试的过程中，对主要的控制直到最后才接触到。但这种方式的优点是不需要桩模块，而建立驱动模块一般比建立桩模块容易，同时由于涉及到复杂算法和真正输入/输出的模块最先得到组装和测试，可以把最容易出问题的部分在早期解决。此外自底向上增殖的方式可以实施多个模块的并行测试。<br>　　核心集成测试：核心系统先行集成测试法的思想是先对核心软件部件进行集成测试，在测试通过的基础上再按各外围软件部件的重要程度逐个集成到核心系统中。每次加入一个外围软件部件都产生一个产品基线，直至最后形成稳定的软件产品。核心系统先行集成测试法对应的集成过程是一个逐渐趋于闭合的螺旋形曲线，代表产品逐步定型的过程。　　<br>③ 混合增殖式测试</p><h5 id="3-系统测试"><a href="#3-系统测试" class="headerlink" title="3. 系统测试"></a>3. 系统测试</h5><pre><code>（1）定义：系统测试是在所有单元、集成测试后，对系统的功能及性能的总体测试。（2）系统测试内容：系统不仅仅包括软件本身，而且还包括计算机硬件及其相关的外围设备、实际运行时大批量数据、非正常操作(如黑客攻击)等。通常意义上的系统测试包括压力测试、容量测试、性能测试、安全测试、容错测试等。</code></pre><p>　　· 压力测试(s”esstest)：也称为强度测试、负载测试。压力测试是模拟实际应用的软硬件环境及用户使用过程的系统负荷，长时间或超大负荷地运行测试软件，来测试被测系统的性能、可靠性、稳定性等。压力测试的目的就是在软件投入使用以前或软件负载达到极限以前，通过执行可重复的负载测试，了解系统硼J靠性、性能瓶颈等，以提高软件系统的可靠性、稳定性，减少系统的宕机时间和因此带来的损失。</p><p>　　· 容量测试(c印ac时test)：预先分析出反映软件系统应用特征的某项指标的极限值，如某个web站点可以支持多少个并发用户的访问量、网络在线会议系统的与会者人数。知道了系统的实际容量，如果不能满足要求，就应该寻求新的解决方案， 以提高系统的容量。若一时没有新的解决方案，就有必要在产品发布说明书上明确这些容量的限制，避免引起软件产品使用上的纠纷。如果实际容量已满足要求，就能帮助用户建立对产品的信心。</p><p>　　· 性能测试(pe晌nllance test)：通过测试确定系统运行时的性能表现，如得到运行速度、响应时间、占有系统资源等方面的系统数据。对丁那些实时或嵌入式系统，系统有时满足了功能要求，但未必能够满足性能要求，如某个}{_9站可以被访问， 而且司以提供预先设定的功能，但每打开一个页面都需要1～2分钟，用户不可忍 受，其结果没有用户愿意使用这个网站所提供的服务。</p><p>　　· 安全测试(securhyten)：检查系统对非法侵入的防范能力。安全测试期间。测试人员假扮非法入侵者，采用各种办法试图突破防线。系统安全设计的准则是，使非法侵入的代价超过被保护信息的价值。</p><p>　　· 容错测试(recovervtest)：主要检查系统的容错能力。当系统出错时，能否在指定时间间隔内修正错误并重新启动系统。容错测试首先要通过各种手段，让软件强制性地发生故障，然后验证系统是否能尽快恢复。对于自动恢复需验证熏新初始化、检查点、数据恢复和重新启动等机制的正确性</p><h5 id="4-确认测试"><a href="#4-确认测试" class="headerlink" title="4. 确认测试"></a>4. 确认测试</h5><pre><code>（1）定义：确认测试又称有效性测试。有效性测试是在模拟的环境下，运用黑盒测试的方法，验证被测软件是否满足需求规格说明书列出的需求。任务是验证软件的功能和性能及其他特性是否与用户的要求一致。对软件的功能和性能要求在软件需求规格说明书中已经明确规定，它包含的信息就是软件确认测试的基础。  确认测试的目的是向未来的用户表明系统能够像预定要求那样工作。经集成测试后，已经按照设计把所有的模块组装成一个完整的软件系统，接口错误也已经基本排除了，接着就应该进一步验证软件的有效性，这就是确认测试的任务，即软件的功能和性能如同用户所合理期待的那样。（2）基本方法：</code></pre><p>  　通过集成测试之后，软件已完全组装起来，接口方面的错误也已排除，确认测试即可开始。确认测试应检查软件能否按合同要求进行工作，即是否满足软件需求说明书中的确认标准。<br>　　1. 确认测试标准<br>　　实现软件确认要通过一系列黑盒测试。确认测试同样需要制订测试计划和过程，测试计划应规定测试的种类和测试进度，测试过程则定义一些特殊的测试用例，旨在说明软件与需求是否一致。无论是计划还是过程，都应该着重考虑软件是否满足合同规定的所有功能和性能，文档资料是否完整、准确人机界面和其他方面（例如，可移植性、兼容性、错误恢复能力和可维护性等）是否令用户满意。<br>　　确认测试的结果有两种可能，一种是功能和性能指标满足软件需求说明的要求，用户可以接受；另一种是软件不满足软件需求说明的要求，用户无法接受。项目进行到这个阶段才发现严重错误和偏差一般很难在预定的工期内改正，因此必须与用户协商，寻求一个妥善解决问题的方法。<br>　　2. 配置复审<br>　　确认测试的另一个重要环节是配置复审。复审的目的在于保证软件配置齐全、分类有序，并且包括软件维护所必须的细节。<br>　　3. α、β测试<br>　　事实上，软件开发人员不可能完全预见用户实际使用程序的情况。例如，用户可能错误的理解命令，或提供一些奇怪的数据组合，亦可能对设计者自认明了的输出信息迷惑不解，等等。因此，软件是否真正满足最终用户的要求，应由用户进行一系列“验收测试”。验收测试既可以是非正式的测试，也可以有计划、有系统的测试。有时，验收测试长达数周甚至数月，不断暴露错误，导致开发延期。一个软件产品，可能拥有众多用户，不可能由每个用户验收，此时多采用称为α、β测试的过程，以期发现那些似乎只有最终用户才能发现的问题。<br>　　α测试是指软件开发公司组织内部人员模拟各类用户行对即将面市软件产品（称为α版本）进行测试，试图发现错误并修正。α测试的关键在于尽可能逼真地模拟实际运行环境和用户对软件产品的操作并尽最大努力涵盖所有可能的 用户操作方式。经过α测试调整的软件产品称为β版本。紧随其后的β测试是指软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，并要求用户报告异常情况、提出批评意见。然后软件开发公司再对β版本进行改错和完善。</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
          <category> block-box </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白盒测试用例设计</title>
      <link href="/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p><a id="more"></a><p>这一方法是把测试对象看作一个打开的盒子，测试人员依据程序内部逻辑结构相关信息，设计或选择测试用例，对程序所有逻辑路径进行测试，通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致。</p><p>常用的软件测试方法有两大类：静态测试方法和动态测试方法。其中软件的静态测试不要求在计算机上实际执行所测程序，主要以一些人工的模拟技术对软件进行分析和测试；而软件的动态测试是通过输入一组预先按照一定的测试准则构造的实例数据来动态运行程序，而达到发现程序错误的过程。 </p><p>白盒测试的测试方法有：</p><p>代码检查法<br>静态结构分析法<br>静态质量度量法<br>逻辑覆盖法<br>用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/03/软件测试基础知识系列/白盒测试用例设计/1.jpg" alt=""></p><p>基本路径测试法<br>用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/03/软件测试基础知识系列/白盒测试用例设计/2.jpg" alt=""></p><p>域测试<br> 域测试是一种基于程序结构的测试方法，基于对程序输入空间（域）的分析，选择测试点进行测试。域测试主要测试如下错误：<br>1）域错误：程序的控制流存在错误，对于某一特定的输入可能执行的是一条错误路径，这种错误称为路径错误，也叫做域错误。<br>2）计算型错误：对于特定输入执行的路径正确，但赋值语句的错误导致输出结果错误，称为计算型错误。<br>3）丢失路径错误：由于程序中的某处少了一个判定谓词而引起的丢失路径错误。</p><p>域测试的缺点是：<br>1）为进行域测试对程序提出的限制过多.<br>2）当程序中存在很多路径时，所需的测试点很多.</p><p>符号测试<br>符号测试的基本思想是允许程序的输入不仅仅是具体的数值数据，而且包括符号值，符号值可以是基本的符号变量值，也可以是符号变量值的表达式。符号测试的优点如下：<br>1）符号测试执行的是代数运算，可以作为普通测试的扩充。<br>2）符号测试可以看做是程序测试和程序验证的一种折中办法。<br>3）符号测试程序中仅有有限的几条执行路径。<br>符号测试的缺点是：<br>1）分支问题不能控制。<br>2）二义性问题不能控制。<br>3）大程序问题不能控制。</p><p>Z路径覆盖<br>Z路径覆盖是路径覆盖的一个变体,路径覆盖是白盒测试最为典型的问题,着眼于路径分析的测试可称为路径测试。<br>完成路径测试的理想情况是做到路径覆盖,对于比较简单的小程序实现路径覆盖是可能做到的,但是如果程序中出现多个判断和多个循环，可能的路径数目将会急剧增长，达到天文数字，以至实现路径覆盖不可能做到。</p><p>为了解决这一问题，我们必须舍掉一些次要因素，对循环机制进行简化，从而极大地减少路径的数量，使得覆盖这些有限的路径成为可能。我们称简化循环意义下的路径覆盖为Z路径覆盖。</p><p>这里所说的对循环化简是指，限制循环的次数。无论循环的形式和实际执行循环体的次数多少，我们只考虑循环一次和零次两种情况。也即只考虑执行时进入循环体一次和跳过循环体这两种情况。</p><p>对于程序中的所有路径可以用路径树来表示。当得到某一程序的路径树后，从其根结点开始，一次遍历，再回到根结点时，把所经历的叶结点名排列起来，就得到一个路径。如果我们设法遍历了所有的叶结点，那就得到了所有的路径。</p><p>当得到所有的路径后，生成每个路径的测试用例，就可以做到Z路径覆盖测试。</p><p>程序变异。<br>程序变异方法与前面提到的结构测试和功能测试都不一样，它是一种错误驱动测试。<br>       错误驱动测试方法，是指该方法是针对某类特定程序错误的。<br>       错误驱动测试主要有两种，即程序强变异和程序弱变异。</p><p>白盒测试综合策略:<br>（1）在测试中，首先尽量使用测试工作进行静态结构分析<br>（2）采用先静态后动态的组合方式，先进行静态结构分析，代码检查和静态质量度量，然后现进行覆盖测试<br>（3）利用静态结构分析的结果，通过代码检查和动态测试的方法对结果进一步确认，使测试工作更为有效<br>（4）覆盖率测试是白盒测试的重点，使用基本路径测试达到语句覆盖标准；对于重点模块，应使用多种覆盖标准衡量代码的覆盖率<br>（5）不同测试阶段，侧重点不同<br>单元测试：以代码检查、逻辑覆盖<br>集成测试：增加静态结构分析、静态质量度量<br>系统测试：根据黑盒测试结果，采用白盒测试.</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
          <category> white-box </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白盒测试之基本路径测试法</title>
      <link href="/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%E6%B3%95/"/>
      <url>/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>基本路径测试是一种白盒测试方法，它在程序控制图的基础上，通过分析控制构造的环行复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每一个可执行语句至少执行一次。<br><a id="more"></a><br><img src="/2017/04/03/软件测试基础知识系列/白盒测试之基本路径测试法/1.jpg" alt=""></p><h5 id="1-工具-原料"><a href="#1-工具-原料" class="headerlink" title="1. 工具/原料"></a>1. 工具/原料</h5><ul><li>图形矩阵</li><li>控制流图</li></ul><h5 id="2-方法-步骤"><a href="#2-方法-步骤" class="headerlink" title="2. 方法/步骤"></a>2. 方法/步骤</h5><p>画出控制流图。<br>使用控制流图制作方法对程序流程图进行简化，以突出的表示程序控制流的结构。<br>对于复合条件，则可将其分解为多个单个条件，并映射成控制流图。<br>图例如图所示。<br><img src="/2017/04/03/软件测试基础知识系列/白盒测试之基本路径测试法/2.jpg" alt=""></p><p>确定程序基本集的独立路径数量，再确保所有语句至少执行一次的测试数量的上界。<br>需要注意的是测试可以被设计为基本路径集的执行过程，但基本路径集通常并不唯一。<br>一般而言控制流图中区域的数量对应于环形复杂度。<br><img src="/2017/04/03/软件测试基础知识系列/白盒测试之基本路径测试法/3.jpg" alt=""></p><p>再根据上面的独立路径，去设计输入数据，使程序分别执行到上面四条路径。<br>于是形成路程测试用例。<br>为了确保基本路径集中的每一条路径的执行，根据判断结点给出的条件，选择适当的数据以保证某一条路径可以被测试到<br><img src="/2017/04/03/软件测试基础知识系列/白盒测试之基本路径测试法/4.jpg" alt=""></p><p>有关圈复杂度：</p><p>圈复杂度是一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在定义之前不曾用到的边。</p><p>有以下三种方法计算圈复杂度：</p><p>流图中区域的数量对应于环型的复杂性;</p><p>给定流图G的圈复杂度V(G)，定义为V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量;</p><p>给定流图G的圈复杂度V(G)，定义为V(G)=P+1，P是流图G中判定结点的数量。</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
          <category> white-box </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白盒测试之逻辑覆盖法</title>
      <link href="/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95/"/>
      <url>/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的技术。<br>根据覆盖目标的不同和覆盖源程序语句的详尽程度，逻辑覆盖又可分为：</p><ol><li>语句覆盖(SC)</li><li>判定覆盖(DC)</li><li>条件覆盖(CC)</li><li>条件/判定覆盖(CC)</li><li>条件组合覆盖(MCC)</li><li>修正判定条件覆盖(MCDC)</li><li>点覆盖</li><li>边覆盖</li><li>路径覆盖</li></ol><p>几种逻辑覆盖标准发现错误的能力呈由弱至强的变化。</p><p>下面我们来逐一举例详解：</p><a id="more"></a><h5 id="1-语句覆盖（SC）："><a href="#1-语句覆盖（SC）：" class="headerlink" title="1. 语句覆盖（SC）："></a>1. 语句覆盖（SC）：</h5><p>语句覆盖是指选择足够的测试用例，使得运行这些测试用例时，被测程序的每一个语句至少执行一次，其覆盖标准无法发现判定中逻辑运算的错误.</p><p>我们看下面的被测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span> a / b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>假如我们的测试人员编写如下测试案例：<br>TeseCase: a = 10, b = 5</p><p>测试人员的测试结果会告诉你，他的代码覆盖率达到了100%，并且所有测试案例都通过了。然而遗憾的是，我们的语句覆盖率达到了所谓的100%，但是却没有发现最简单的 Bug，比如，当我让b=0时，会抛出一个除零异常。</p><p>简言之，语句覆盖，就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。这里的“若干个”，意味着使用测试用例越少越好。</p><p>语句覆盖率的公式可以表示如下：<br>语句覆盖率=可执行的语句总数/被评价到的语句数量 x 100%</p><h5 id="2-判定覆盖-DC"><a href="#2-判定覆盖-DC" class="headerlink" title="2. 判定覆盖(DC)"></a>2. 判定覆盖(DC)</h5><p>判定覆盖是设计足够多的测试用例，使得程序中的每一个判断至少获得一次“真”和一次“假”，即使得程序流程图中的每一个真假分支至少被执行一次。<br>但若程序中的判定是有几个条件联合构成时，它未必能发现每个条件的错误。<br>例：<br>int a,b;<br>if(a || b)<br>执行语句1<br>else<br>执行语句2</p><p>要达到这段程序的判断覆盖,我们采用测试用例:<br>1)a = true , b = false;<br>2)a = false, b = false</p><h5 id="3-条件覆盖-CC"><a href="#3-条件覆盖-CC" class="headerlink" title="3. 条件覆盖(CC)"></a>3. 条件覆盖(CC)</h5><p>条件覆盖是指选择足够的测试用例，使得运行这些测试用例时，判定中每个条件的所有可能结果至少出现一次，但未必能覆盖全部分支.<br>例：<br>int a,b;<br>if(a || b)<br>执行语句1<br>else<br>执行语句2</p><p>要达到这段程序的条件覆盖,我们采用测试用例:<br>1)a = true , b = false ;<br>2)a = false, b = true</p><h5 id="4-判定-条件覆盖（CDC）"><a href="#4-判定-条件覆盖（CDC）" class="headerlink" title="4. 判定/条件覆盖（CDC）"></a>4. 判定/条件覆盖（CDC）</h5><p>判定/条件覆盖是使判定中每个条件的所有可能结果至少出现一次，并且每个判定本身的所有可能结果也至少出现一次。<br>例：<br>int a,b;<br>if(a || b)<br>执行语句1<br>else<br>执行语句2</p><p>要达到这段程序的判定/条件覆盖,我们采用测试用例:<br>1)a = true , b = true;<br>2)a = false, b = false</p><h5 id="5-条件组合覆盖（MCC）"><a href="#5-条件组合覆盖（MCC）" class="headerlink" title="5. 条件组合覆盖（MCC）"></a>5. 条件组合覆盖（MCC）</h5><p>选择足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。显然，满足“条件组合覆盖”的测试用例是一定满足“判定覆盖”、“条件覆盖”和“判定/条件覆盖”的。</p><p>例：<br>int a,b;<br>if(a || b)<br>执行语句1<br>else<br>执行语句2</p><p>要达到这段程序的判定/条件覆盖,我们采用测试用例:<br>1)a = true , b = true;<br>2)a = false, b = false<br>3)a = true,  b = false<br>4)a = false,  b = ture</p><h5 id="6-修正判定条件覆盖（MC-DC）"><a href="#6-修正判定条件覆盖（MC-DC）" class="headerlink" title="6. 修正判定条件覆盖（MC/DC）"></a>6. 修正判定条件覆盖（MC/DC）</h5><p>MC/DC首先要求实现条件覆盖、判定覆盖，在此基础上，对于每一个条件C，要求存在符合以下条件的两次计算：<br>    1）条件C所在判定内的所有条件，除条件C外，其他条件的取值完全相同；<br>    2）条件C的取值相反；<br>    3）判定的计算结果相反。</p><pre><code>核心意思是每个条件都要独立影响判定结果。为什么说“两次计算”，而不是“两个用例”呢？当循环中有判定时，一个用例下同一判定可能被计算多次，每次的条件值和判定值也可能不同，因此，一个用例就可能完成循环中判定的MC/DC。MC/DC是条件组合覆盖的子集。条件组合覆盖要求覆盖判定中所有条件取值的所有可能组合，需要大量的测试用例，实用性较差。MC/DC具有条件组合覆盖的优势，同时大幅减少用例数。满足MC/DC的用例数下界为条件数+1，上界为条件数的两倍，例如，判定中有三个条件，条件组合覆盖需要8个用例，而MC/DC需要的用例数为4至6个。如果判定中条件很多，用例数的差别将非常大，例如，判定中有10个条件，条件组合覆盖需要1024个用例，而MC/DC只需要11至20个用例。下面是MC/DC的示例：代码：{% codeblock lang:c %}    int func(BOOL A, BOOL B, BOOL C)    {        if(A && (B || C))            return 1;        return 0;    }{% endcodeblock %}用例：对于条件A，用例1和用例2，A取值相反，B和C相同，判定结果分别为1和0；对于条件B，用例1和用例3，B取值相反，A和C相同，判定结果分别为1和0；对于条件C，用例3和用例4，C取值相反，A和B相同，判定结果分别为0和1。</code></pre><h5 id="7-路径覆盖（PC）"><a href="#7-路径覆盖（PC）" class="headerlink" title="7. 路径覆盖（PC）"></a>7. 路径覆盖（PC）</h5><p>MC/DC被称为“最严格的标准”，但这种说法是将条件组合覆盖和路径覆盖排除在外为基础的。MC/DC显然不如条件组合覆盖严格，但是条件组合覆盖需要太多用例，实际应用中难以做到，所以排除，那么，路径覆盖是否也难以做到？使用先进的工具，对于一般的代码，实现路径覆盖还是可能的。另外，路径代表了从函数入口到出口的所有可能的代码组合，这些组合会不会出问题？只有路径覆盖能发现，这与MC/DC侧重于判定内的条件的组合关系是完全不同的。</p><pre><code>ＭC/DC与路径覆盖的侧重点不同，两者都有其优势和局限性，如果组合起来，优势互补，形成“MC/DC-路径覆盖”，就是真正意义上的“最严格的标准”了。有些程序，路径数量可能大得惊人，可用以下规则和方法减少路径数量：计算路径时，不考虑循环的次数，将循环结构视为循环体“至少执行一次”和“从不执行”两个分支；不考虑条件的计算结果只考虑判定的计算结果，条件间的组合关系由条件覆盖、C/DC和MC/DC负责；一个分支如果不可达，通过该分支的所有路径也不可达，可以让工具自动排除；当代码很复杂时，理想的处置方式是将部分代码独立为函数，如果做不到，可以让工具来模拟，即在逻辑结构图中，将部分代码临时屏蔽，被屏蔽的代码视为一个函数调用。交替屏蔽可以既减少路径数量，又保证路径覆盖的效果。对于一般复杂度的代码，采用以上规则和方法后，路径数量和用例数量可以维持在一个现实可覆盖的的范围内。路径覆盖的主要缺陷是：不相关的逻辑块会组合出大量没有意义的路径。一个函数的路径，可能达到几万条甚至几百万条。如果路径超过100条，通常路径覆盖就没有意义了。对于一般企业来说，建议用MC/DC作为统一的覆盖标准，只有特别关键的代码，才要求完成“MC/DC-路径覆盖”。</code></pre><p>路径覆盖要求设计足够多的测试用例，在白盒测试法中，覆盖程度最高的就是路径覆盖，因为其覆盖程序中所有可能的路径。<br>对于比较简单的小程序来说，实现路径覆盖是可能的，但是如果程序中出现了多个判断和多个循环，可能的路径数目将会急剧增长，以致实现路径覆盖是几乎不可能的。</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
          <category> white-box </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑盒测试用例设计</title>
      <link href="/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。<br><a id="more"></a><br>黑盒测试法注重于测试软件的功能需求，主要试图发现下列几类错误。</p><p>功能不正确或遗漏；<br>界面错误；<br>输入和输出错误；<br>数据库访问错误；<br>性能错误；<br>初始化和终止错误等。</p><p>常用的黑盒测试方法有：<br>等价类划分<br>用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/03/软件测试基础知识系列/黑盒测试用例设计/1.jpg" alt=""></p><p>边界值分析<br>用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/03/软件测试基础知识系列/黑盒测试用例设计/2.jpg" alt=""></p><p>错误推测法<br>基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法。<br>基本思想：<br>列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。</p><p>因果图<br>用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/03/软件测试基础知识系列/黑盒测试用例设计/3.jpg" alt=""></p><p>功能图</p><p>场景法<br>用例详解请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/03/软件测试基础知识系列/黑盒测试用例设计/4.jpg" alt=""></p><p>测试方法选择的综合策略：<br>（1）首先进行等价类划分，包括输入条件和输出条件的等价划分，将无限测试变成有限测试，这是减少工作量和提高测试效率最有效的方法。<br>（2）在任何情况下都必须使用边界值分析方法。经验表明，用这种方法设计出的测试用例发现程序错误的能力最强。<br>（3）如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法和判定表驱动法。<br>（4）对于业务流清晰的系统，可以利用场景法贯穿整个测试案例过程，在案例中综合使用各种测试方法。<br>（5）可以用错误推测法追加一些测试用例，这需要依靠测试工程师的智慧和经验。<br>（6）对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度。如何没有达到要求的覆盖标准，应当再补充足够的测试用例。<br>（7）对参数配置类得软件，要用正交试验法选择较少的组合方式达到最佳效果。<br>（8）功能图法也是很好的测试用例设计方法，我们可以通过不同时期条件的有效性设计不同的测试数据。<br> (9) 对于业务清晰的系统，可以利用场景法贯穿整个测试案例过程，在案例中综合使用各种测试方法。</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
          <category> block-box </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试的原则</title>
      <link href="/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8E%9F%E5%88%99/"/>
      <url>/2017/04/03/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>测试应该遵循怎样的原则呢？<br><a id="more"></a></p><p>1、所有的测试都应追溯到用户需求。<br>因为软件的目的是使用户完成预定的任务，满足其需求，而软件测试揭示软件的缺陷和错误，一旦修正这些错误就能更好地满足用户需求。</p><p>2、应尽早地和不断地进行软件测试。<br>由于软件的复杂性和抽象性，在软件生命周期各阶段都可能产生错误，所以不应把软件测试仅仅看作是软件开发的一个独立阶段，而应当把它贯穿到软件开发的各个阶段去。在需求分析和设计阶段就应开始进行测试工作，编写相应的测试计划及测试设计文档，同时坚持在开发各阶段进行技术评审和验证，这样才能尽早发现和预防错误，杜绝某些缺陷和错误，提高软件质量，测试工作进行得越早，越有利于提高软件的质量，这是预防性测试的基本原则。</p><p>3、完全测试是不可能的， 测试需要终止。<br>因为，测试输入量大、输出结果多、路径组合太多，用有限的资源来达到完全测试是不现实的。</p><p>4、测试只能证明软件存在错误而不能证明软件没有错误。<br>测试是无法显示潜在的错误和缺陷，继续进一步错误可能还会找到其它错误和缺陷。</p><p>5、充分关注测试中的集群现象。<br>在测试的程序段中，若发现的错误数目多，则残存在其中的错误也越多，因此应当花较多的时间和代价测试那些具有更多错误数目的程序模块。</p><p>6、程序员应避免检查自己的程序。<br>考虑到人们的心理因素，自己揭露自己程序中的错误是件不愉快的事，自己不愿意否认自己的工作;另一方面，由于思维定势，自己难以发现自己的错误。因此，测试一般由独立的测试部门或第三方机构进行。</p><p>7、尽量避免测试的随意性。<br>软件测试是有组织、有计划、有步骤的活动，要严格按照测试计划进行，要避免测试的随意性</p><p>–<br><img src="/2017/04/03/软件测试基础知识系列/测试的原则/阿里Devops体系和实践.svg.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basic-knowledge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Appium远程运行自动化脚本</title>
      <link href="/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Appium%E8%BF%9C%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
      <url>/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Appium%E8%BF%9C%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>前面我分享过移动端测试&lt;移动APP自动化测试之元素定位&gt;, 但没有像web端测试那样系统，例如框架一笔带过，分布式运行甚至都没有提。近期有读者问我一个问题，如何实现Appium在远程运行自动化脚本？ 我建议他自己研究下，此文即为他的研究成果，分享给大家， 以下是正文：</p><a id="more"></a><p>Appium的远程设置<br>客户端控制脚本，服务器控制手机和appium server（注：最终脚本运行在这个机器上）。</p><ol><li>客户端（PC1）配置IP地址要同服务器（appium server）在一个网段内。</li><li>服务端设置地址和端口号，设置Server Address为0.0.0.0，Port为4723。<br><img src="/2017/04/02/移动测试系列/Appium远程运行自动化脚本/0.jpg" alt=""></li></ol><p>（注：服务器端实际IP为192.168.3.35）</p><ol><li>开启appium server服务<br><img src="/2017/04/02/移动测试系列/Appium远程运行自动化脚本/1.jpg" alt=""></li><li>在客户端（PC1）上验证能不能访问appium server<br>在浏览器上输入服务器的地址：（如下图所示）<br><img src="/2017/04/02/移动测试系列/Appium远程运行自动化脚本/2.png" alt=""></li><li>在客户端（PC1）中，修改脚本<br><img src="/2017/04/02/移动测试系列/Appium远程运行自动化脚本/2.jpg" alt=""></li><li>手机设备插在服务器mac上</li><li>在客户端（PC1）中，执行脚本<br><img src="/2017/04/02/移动测试系列/Appium远程运行自动化脚本/3.png" alt=""><br>如果在appium server（MAC机器上）能跑自动化，证明远程设置成功啦！</li></ol><p>——-我是分割线———-<br>总结起来就一句话，webdriver.Remote（）这个方法控制脚本运行在哪个机器上，你想要脚本运行在哪台机器上，就在你的远程脚本里配置这个ip，并在被运行脚本的这台机器上的Appium server上，配置server地址为127.0.1或0.0.0.0。</p>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Mobile-Test </tag>
            
            <tag> Appium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS自动化测试之元素定位</title>
      <link href="/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D/"/>
      <url>/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>iOS自动化测试之元素定位<br><a id="more"></a></p><p>在iOS自动化测试过程中， 如何来定位页面元素呢？</p><ol><li>利用Appium的Inspector<br>第一步，配置好你要运行的app的各项参数，如下图所示：<br><img src="/2017/04/02/移动测试系列/iOS自动化测试之元素定位/1.jpg" alt=""><br>app path指向源代码编译后生成的 *.app文件<br>然后点击Launch（1）打开APP， 然后点击Inspector Icon（2）来load Inspector。</li></ol><p>第二步，Inspector打开后如下图所示：<br><img src="/2017/04/02/移动测试系列/iOS自动化测试之元素定位/2.jpg" alt=""><br>最右边是我们的APP HelloKevin， 目前只有一个TextEdit dialog。 左边红色部分是我们可以选择的locator。</p><p>第三步， 定位元素。<br> 写好能唯一指定页面元素的locator，然后点击右边的search， 如果定位正确，就会如下图所所示：<br><img src="/2017/04/02/移动测试系列/iOS自动化测试之元素定位/3.jpg" alt=""><br>对应的代码（以Python为例）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> page_objects <span class="keyword">import</span> PageElement</div><div class="line">........</div><div class="line">TEXT_EDIT_XPATH = <span class="string">"//UIATextField[1]"</span></div><div class="line">text_edit_dialog = PageElement(xpath=TEXT_EDIT_XPATH)   </div><div class="line">self.driver.text_edit_dialog.click()</div></pre></td></tr></table></figure><br>另外几种Locator Type 举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">el = self.driver.find_element_by_id(<span class="string">'ButtonsExplain'</span>)</div><div class="line">el = self.driver.find_element_by_name(<span class="string">'TextFields, Uses of UITextField'</span>)</div><div class="line">el = self.driver.find_element_by_class_name(<span class="string">'UIATextField'</span>)</div></pre></td></tr></table></figure></p><ol><li>利用UI AUTomation<br>This allows elements in iOS applications to be found using recursive element search using the UIAutomation library.<br>Adds the methods driver.find_element_by_ios_uiautomation and driver.find_elements_by_ios_uiautomation.<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">el = self.driver.find_element_by_ios_uiautomation(<span class="string">'.elements()[0]'</span>)</div><div class="line">self.assertEqual(<span class="string">'UICatalog'</span>, el.get_attribute(<span class="string">'name'</span>))</div><div class="line">els = self.driver.find_elements_by_ios_uiautomation(<span class="string">'.elements()'</span>)</div><div class="line">self.assertIsInstance(els, list)</div></pre></td></tr></table></figure>代码实现如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_elements_by_ios_uiautomation</span><span class="params">(self, uia_string)</span>:</span></div><div class="line">    <span class="string">"""Finds elements by uiautomation in iOS.</span></div><div class="line"></div><div class="line">    :Args:</div><div class="line">     - uia_string - The element name in the iOS UIAutomation library</div><div class="line"></div><div class="line">    :Usage:</div><div class="line">        driver.find_elements_by_ios_uiautomation('.elements()[1].cells()[2]')</div><div class="line">    """</div><div class="line">    <span class="keyword">return</span> self.find_elements(by=By.IOS_UIAUTOMATION, value=uia_string)</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_element</span><span class="params">(self, by=By.ID, value=None)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    'Private' method used by the find_element_by_* methods.</div><div class="line"></div><div class="line">    :Usage:</div><div class="line">        Use the corresponding find_element_by_* instead of this.</div><div class="line"></div><div class="line">    :rtype: WebElement</div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> By.is_valid(by) <span class="keyword">or</span> <span class="keyword">not</span> isinstance(value, str):</div><div class="line">        <span class="keyword">raise</span> InvalidSelectorException(<span class="string">"Invalid locator values passed in"</span>)</div><div class="line">    <span class="keyword">if</span> self.w3c:</div><div class="line">        <span class="keyword">if</span> by == By.ID:</div><div class="line">            by = By.CSS_SELECTOR</div><div class="line">            value = <span class="string">'[id="%s"]'</span> % value</div><div class="line">        <span class="keyword">elif</span> by == By.TAG_NAME:</div><div class="line">            by = By.CSS_SELECTOR</div><div class="line">        <span class="keyword">elif</span> by == By.CLASS_NAME:</div><div class="line">            by = By.CSS_SELECTOR</div><div class="line">            value = <span class="string">".%s"</span> % value</div><div class="line">        <span class="keyword">elif</span> by == By.NAME:</div><div class="line">            by = By.CSS_SELECTOR</div><div class="line">            value = <span class="string">'[name="%s"]'</span> % value</div><div class="line">    <span class="keyword">return</span> self.execute(Command.FIND_ELEMENT,</div><div class="line">                         &#123;<span class="string">'using'</span>: by, <span class="string">'value'</span>: value&#125;)[<span class="string">'value'</span>]</div></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Mobile-Test </tag>
            
            <tag> Appium </tag>
            
            <tag> 自动化测试定位元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIAutomation Viewer定位Android APP元素</title>
      <link href="/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/UIAutomation%20Viewer%E5%AE%9A%E4%BD%8DAndroid%20APP%E5%85%83%E7%B4%A0/"/>
      <url>/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/UIAutomation%20Viewer%E5%AE%9A%E4%BD%8DAndroid%20APP%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>如何用UIAutomation Viewer定位Android APP元素<br><a id="more"></a><br><img src="/2017/04/02/移动测试系列/UIAutomation Viewer定位Android APP元素/1.jpg" alt=""><br>We will use android calculator app to get element’s XPath in different ways. Supposing I need XPath of button 5. So i can write XPath in multiple ways for it as bellow.<br>UI Automator Viewer screenshot for button 5 is as bellow. </p><ol><li><p>XPath using class and text attribute :<br>In above image you can see that button 5 has text attribute with value = 5 which is unique. Class name is android.widget.Button which is same for all number buttons. So we can create XPath using text attribute value with class name as bellow.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xpath(<span class="string">"//android.widget.Button[@text='5']"</span>)</div></pre></td></tr></table></figure></li><li><p>XPath using class and resource-id :<br>Here resource-id for button 5 is com.android.calculator2:id/digit5. Trailing part (e.g digit5, digit4, digit7) of resource-id is changing for every number buttons so we can use contains function to get relative XPath of button 5 as bellow.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xpath(<span class="string">"//android.widget.Button[contains(@resource-id,'digit5')]"</span>)</div></pre></td></tr></table></figure></li><li>XPath using class, text attribute and resource-id :<br>We can use combination of text attribute and resource-id with class name to create unique XPath of element button 5 as bellow.<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xpath(<span class="string">"//android.widget.Button[contains(@resource-id,'digit5') and @text='5']"</span>)</div></pre></td></tr></table></figure></li><li>XPath using class, text attribute and index :<br>We can use same approach as described in point 3 but with index number. Button 5 has index 1 but it is not unique as number buttons 0,2 and 8 has also same index with same class name. So we can include text attribute with indexattribute to locate number button 5.<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xpath(<span class="string">"//android.widget.Button[@text='5' and @index='1']"</span>)</div></pre></td></tr></table></figure></li><li>XPath using parent and child class hierarchy<br><img src="/2017/04/02/移动测试系列/UIAutomation Viewer定位Android APP元素/2.jpg" alt=""><br>As you can see in above image, Parent class android.widget.LinearLayout class with index = 1 has buttons 4, 5, 6 and X. So we can locate that specific row by it’s class index. Child element is member of class android.widget.Button withindex = 1. So we can format XPath using parent and child class hierarchy as bellow.<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xpath(<span class="string">"//android.widget.LinearLayout[@index='1']/android.widget.Button[@index='1']"</span>)</div></pre></td></tr></table></figure></li><li>XPath using content-desc</li></ol><p><img src="/2017/04/02/移动测试系列/UIAutomation Viewer定位Android APP元素/3.jpg" alt=""><br>Supposing element has content-desc which is unique then you can use it to create XPath. Example : DELETE button has unique content-desc = delete. So we can write XPath for delete button using it as bellow.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xpath(<span class="string">"//android.widget.Button[@content-desc='delete']"</span>)</div></pre></td></tr></table></figure></p><ol><li>XPath using class name<br>Note : Using class name In By.className or By.xpath will works only if it is unique for element. If same class name is provided to multiple elements then it will not work.<br><img src="/2017/04/02/移动测试系列/UIAutomation Viewer定位Android APP元素/4.jpg" alt=""></li></ol><p>If software application’s element has a class name and it is unique for element then you can use class name only to create XPath. See above image. Options button has class name android.widget.ImageButton which is unique. So we can use it only to create xpath as bellow.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xpath(<span class="string">"//android.widget.ImageButton"</span>)</div></pre></td></tr></table></figure><br>Locating Android App Element By ID<br>We can locate elements by ID in android app too. We can use resource-id as a id. Example is as bellow.<br>resource-id for button 5 is “com.android.calculator2:id/digit5” so we can locate to it by id as bellow.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id(<span class="string">"com.android.calculator2:id/digit5"</span>)</div></pre></td></tr></table></figure><br>Locating Android App Element By className<br>Same way, We can use class name to locate element if it is unique.<br><img src="/2017/04/02/移动测试系列/UIAutomation Viewer定位Android APP元素/5.jpg" alt=""><br>Class name for above option button is “android.widget.ImageButton”. We can locate it using className as bellow.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">By.className(<span class="string">"android.widget.ImageButton"</span>)</div></pre></td></tr></table></figure><br>Locating Android App element by Name<br>It is possible to locate element by name if element contains unique text.<br><img src="/2017/04/02/移动测试系列/UIAutomation Viewer定位Android APP元素/6.png" alt=""><br>If you see in above image, button Equals has text value “=”. So we can locate it by name using bellow given syntax.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">By.name(<span class="string">"="</span>)</div></pre></td></tr></table></figure><br>Locating element by findElements<br>If you inspect all buttons of android calculator app, All the buttons has same class “android.widget.Button”. If you know, findElements method is useful to get list of all the matching elements from current page as per given element locator mechanism. VIEW MORE DETAIL on findElements. So here we can collect list of all buttons using findElements and store list using java<br>List interface. Then we access required element using get() method of List interface.<br>Array list Index IDs of button elements of “android.widget.Button” class is as bellow.<br><img src="/2017/04/02/移动测试系列/UIAutomation Viewer定位Android APP元素/7.jpg" alt=""></p><p>List<webelement> calcButtons = driver.findElements(By.xpath(“//android.widget.Button”));<br>Above given syntax will store list of all buttons in list calcButtons with bellow given array list index ids. Bellow given table illustrate array index ids for different buttons of calculator application.<br><img src="/2017/04/02/移动测试系列/UIAutomation Viewer定位Android APP元素/8.png" alt=""></webelement></p>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Mobile-Test </tag>
            
            <tag> Appium </tag>
            
            <tag> 自动化测试定位元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Android UiSelector（）类来定位元素</title>
      <link href="/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Android%20UiSelector%EF%BC%88%EF%BC%89%E7%B1%BB%E6%9D%A5%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0/"/>
      <url>/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Android%20UiSelector%EF%BC%88%EF%BC%89%E7%B1%BB%E6%9D%A5%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>在Android自动化测试过程中，有些元素难以定位，比如一个要定位一个元素的某一个子元素，这样上篇文章讲的方法有时候不那么适用，那么我们可以利用Andorid 自带的UiSelector 类来定位元素。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">el = self.driver.find_element_by_android_uiautomator(<span class="string">'new UiSelector().text("Animation")'</span>)</div><div class="line"></div><div class="line">els = self.driver.find_elements_by_android_uiautomator(<span class="string">'new UiSelector().clickable(true)'</span>)     </div><div class="line">el = self.driver.find_element_by_class_name(<span class="string">'android.widget.ListView'</span>)</div><div class="line">sub_el = el.find_element_by_android_uiautomator(<span class="string">'new UiSelector().description("Animation")'</span>)</div><div class="line"></div><div class="line">el = self.driver.find_element_by_class_name(<span class="string">'android.widget.ListView'</span>)</div><div class="line">sub_el = el.find_element_by_android_uiautomator(<span class="string">'new UiSelector().description("Animation")'</span>)</div><div class="line"></div><div class="line"></div><div class="line">el = self.driver.find_element_by_class_name(<span class="string">'android.widget.ListView'</span>)</div><div class="line">sub_els = el.find_elements_by_android_uiautomator(<span class="string">'new UiSelector().clickable(true)'</span>)</div></pre></td></tr></table></figure><br>UiSelector的具体方法如下：<br>Public constructors<br>UiSelector()</p><p>Public methods<br>checkable(boolean   val)<br>Set the search criteria to match widgets that are   checkable.</p><p>checked(boolean   val)<br>Set the search criteria to match widgets that are   currently checked (usually for checkboxes).</p><p>childSelector(UiSelector selector)<br>Adds a child UiSelector criteria to this selector.</p><p>className(String   className)<br>Set the search criteria to match the class property for   a widget (for example, “android.widget.Button”).</p><p>className(Class<t>   type)<br>Set the search criteria to match the class property for   a widget (for example, “android.widget.Button”).</t></p><p>classNameMatches(String   regex)<br>Set the search criteria to match the class property for   a widget, using a regular expression.</p><p>clickable(boolean   val)<br>Set the search criteria to match widgets that are   clickable.</p><p>description(String   desc)<br>Set the search criteria to match the content-description   property for a widget.</p><p>descriptionContains(String   desc)<br>Set the search criteria to match the   content-description property for a widget.</p><p>descriptionMatches(String   regex)<br>Set the search criteria to match the   content-description property for a widget.</p><p>descriptionStartsWith(String   desc)<br>Set the search criteria to match the   content-description property for a widget.</p><p>enabled(boolean   val)<br>Set the search criteria to match widgets that are   enabled.</p><p>focusable(boolean   val)<br>Set the search criteria to match widgets that are   focusable.</p><p>focused(boolean   val)<br>Set the search criteria to match widgets that have   focus.</p><p>fromParent(UiSelector selector)<br>Adds a child UiSelector criteria to this selector which   is used to start search from the parent widget.</p><p>index(int   index)<br>Set the search criteria to match the widget by its node   index in the layout hierarchy.</p><p>instance(int   instance)<br>Set the search criteria to match the widget by its   instance number.</p><p>longClickable(boolean   val)<br>Set the search criteria to match widgets that are   long-clickable.</p><p>packageName(String   name)<br>Set the search criteria to match the package name of   the application that contains the widget.</p><p>packageNameMatches(String   regex)<br>Set the search criteria to match the package name of   the application that contains the widget.</p><p>resourceId(String   id)<br>Set the search criteria to match the given resource ID.</p><p>resourceIdMatches(String   regex)<br>Set the search criteria to match the resource ID of the   widget, using a regular expression.</p><p>scrollable(boolean   val)<br>Set the search criteria to match widgets that are   scrollable.</p><p>selected(boolean   val)<br>Set the search criteria to match widgets that are   currently selected.</p><p>text(String   text)<br>Set the search criteria to match the visible text   displayed in a widget (for example, the text label to launch an app).</p><p>textContains(String   text)<br>Set the search criteria to match the visible text in a   widget where the visible text must contain the string in your input argument.</p><p>textMatches(String   regex)<br>Set the search criteria to match the visible text   displayed in a layout element, using a regular expression.</p><p>textStartsWith(String   text)<br>Set the search criteria to match visible text in a   widget that is prefixed by the text parameter.</p>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Mobile-Test </tag>
            
            <tag> Appium </tag>
            
            <tag> 自动化测试定位元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动APP自动化测试之元素定位</title>
      <link href="/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E7%A7%BB%E5%8A%A8APP%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D/"/>
      <url>/2017/04/02/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E7%A7%BB%E5%8A%A8APP%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%85%83%E7%B4%A0%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>在基于UI的移动APP自动化测试中，如何定位页面元素呢？对于iOS和Android，定位元素各有什么特殊技巧吗？本文为你揭晓。<br><a id="more"></a></p><p>通用方法之Appium之Inspector<br>详细用法请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/02/移动测试系列/移动APP自动化测试之元素定位/1.png" alt=""><br>iOS only 之 UIAutomation search<br>-ios uiautomation: a string corresponding to a recursive element search using the UIAutomation library (iOS-only)</p><p>Android only之UiAutomation API<br>-android uiautomator: a string corresponding to a recursive element search using the UiAutomator Api(Android-only)<br>详细用法请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/02/移动测试系列/移动APP自动化测试之元素定位/2.png" alt=""><br>Android only 之UI Autoamtion Viewer<br>详细用法请长按下图二维码，在弹出菜单中选择“识别图中二维码” 阅读全文。<br><img src="/2017/04/02/移动测试系列/移动APP自动化测试之元素定位/3.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Mobile-Test </tag>
            
            <tag> Appium </tag>
            
            <tag> 自动化测试定位元素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解RESTful </title>
      <link href="/2017/04/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E7%90%86%E8%A7%A3RESTful/"/>
      <url>/2017/04/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E7%90%86%E8%A7%A3RESTful/</url>
      
        <content type="html"><![CDATA[<p>在测试开发中，我们经常接触到API，在调用API时候特别是第三方API时候，我们常常陷入以下困惑：<br>以一个文件获取为例，我们要获取，上传，删除文件，需要以下接口：</p><blockquote><p>api/getfile.php - 获取文件信息，下载文件<br>api/uploadfile.php - 上传创建文件<br>api/deletefile.php - 删除文件</p></blockquote><p>我们必须很熟悉每一个接口的名称才能使用<br><a id="more"></a><br>如果我需要调用一个修改文件的接口该怎么办呢？这个接口叫modifyfile吗还是别的名字？如果接口维护人员不能及时提供帮助，我们是不是就无法正确引用了？ 既然都是对文件的操作，我们能不能用一个接口表述对这个文件的所有操作呢？<br>当然可以了，我们可以只用一个接口，但是用不同的http请求来表述不同的操作。：<br>api/file 只需要这一个接口<br>GET 方式请求 api/file - 获取文件信息，下载文件<br>POST 方式请求 api/file - 上传创建文件<br>DELETE 方式请求 api/file - 删除某个文件<br>是不是方便了很多？那么，这个是什么风格的API呢？是怎么实现的呢？我们就要从头说起了。<br>答案就是 RESTFUL。通常采用http+JSON实现。<br>（对API的调用通常包含两个部分，序列化和通信协议。常见的序列化协议包括json、xml、hession、protobuf、thrift、text、bytes等；通信比较流行的是http、soap、websockect，RPC。通常基于TCP实现，常用框架例如netty。web开发中常用的是json-rpc。 RESTful是另外一种方法)</p><p>要理解RESTful，首先要理解REST.<br>REST – REpresentational State Transfer， 全称是 Resource Representational State Transfer<br>通俗来讲就是：资源在网络中以某种表现形式进行状态转移。REST是Web自身的架构风格。REST也是Web之所以取得成功的技术架构方面因素的总结。REST是世界上最成功的分布式应用架构风格（成功案例：Web，还不够吗？）。它是为 运行在互联网环境 的 分布式 超媒体系统量身定制的。互联网环境与企业内网环境有非常大的差别，最主要的差别是两个方面：<br>可伸缩性需求无法控制：并发访问量可能会暴涨，也可能会暴跌。<br>安全性需求无法控制：无法控制客户端发来的请求的格式，很可能会是恶意的请求。<br>而所谓的“超媒体系统”，即，使用了超文本的系统。可以把“超媒体”理解为超文本+媒体内容。</p><p>REST是HTTP/1.1协议等Web规范的设计指导原则，HTTP/1.1协议正是为实现REST风格的架构而设计的。新的Web规范，其设计必须符合REST的要求，否则整个Web的体系架构会因为引入严重矛盾而崩溃。这句话不是危言耸听，做个类比，假如苏州市政府同意在市区著名园林的附近大型土木，建造大量具有后现代风格的摩天大楼，那么不久之后世界闻名的苏州园林美景将不复存在。</p><p>上述这些关于“REST是什么”的描述，可以总结为一句话：REST是所有Web应用都应该遵守的架构设计指导原则。当然，REST并不是法律，违反了REST的指导原则，仍然能够实现应用的功能。但是违反了REST的指导原则，会付出很多代价，特别是对于大流量的网站而言。<br>要深入理解REST，需要理解REST的五个关键词：<br>资源（Resource）<br>资源的表述（Representation）<br>状态转移（State Transfer）<br>统一接口（Uniform Interface）<br>超文本驱动（Hypertext Driven）</p><p>什么是资源？<br>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</p><p>什么是资源的表述？<br>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p><p>什么是状态转移？<br>状态转移（state transfer）与状态机中的状态迁移（state transition）的含义是不同的。状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</p><p>什么是统一接口？<br>REST要求，必须通过统一的接口来对资源执行各种操作。对于每个资源只能执行一组有限的操作。以HTTP/1.1协议为例，HTTP/1.1协议定义了一个操作资源的统一接口，主要包括以下内容：<br>7个HTTP方法：GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS<br>HTTP头信息（可自定义）<br>HTTP响应状态代码（可自定义）<br>一套标准的内容协商机制<br>一套标准的缓存机制<br>一套标准的客户端身份认证机制<br>REST还要求，对于资源执行的操作，其操作语义必须由HTTP消息体之前的部分完全表达，不能将操作语义封装在HTTP消息体内部。这样做是为了提高交互的可见性，以便于通信链的中间组件实现缓存、安全审计等等功能。</p><p>什么是超文本驱动？<br>“超文本驱动”又名“将超媒体作为应用状态的引擎”（Hypermedia As The Engine Of Application State，来自Fielding博士论文中的一句话，缩写为HATEOAS）。将Web应用看作是一个由很多状态（应用状态）组成的有限状态机。资源之间通过超链接相互关联，超链接既代表资源之间的关系，也代表可执行的状态迁移。在超媒体之中不仅仅包含数据，还包含了状态迁移的语义。以超媒体作为引擎，驱动Web应用的状态迁移。通过超媒体暴露出服务器所提供的资源，服务器提供了哪些资源是在运行时通过解析超媒体发现的，而不是事先定义的。从面向服务的角度看，超媒体定义了服务器所提供服务的协议。客户端应该依赖的是超媒体的状态迁移语义，而不应该对于是否存在某个URI或URI的某种特殊构造方式作出假设。一切都有可能变化，只有超媒体的状态迁移语义能够长期保持稳定。</p><p>一旦读者理解了上述REST的五个关键词，就很容易理解REST风格的架构所具有的6个的主要特征：<br>面向资源（Resource Oriented）<br>可寻址（Addressability）<br>连通性（Connectedness）<br>无状态（Statelessness）<br>统一接口（Uniform Interface）<br>超文本驱动（Hypertext Driven）</p><p>这6个特征是REST架构设计优秀程度的判断标准。其中，面向资源是REST最明显的特征，即，REST架构设计是以资源抽象为核心展开的。可寻址说的是：每一个资源在Web之上都有自己的地址。连通性说的是：应该尽量避免设计孤立的资源，除了设计资源本身，还需要设计资源之间的关联关系，并且通过超链接将资源关联起来。无状态、统一接口是REST的两种架构约束，超文本驱动是REST的一个关键词，在前面都已经解释过，就不再赘述了。</p><p>那么什么是RESTful呢？<br>如果一个架构符合REST原则，就称它为RESTful架构。</p><p>Server的API如何设计才满足RESTful要求?<br>REST 是面向资源的，这个概念非常重要，而资源是通过 URI 进行暴露。<br>一旦定义好了资源, 需要确定什么样的 actions 应用它们，这些 actions 怎么映射到你的 API 上。RESTful 原则提供了 HTTP methods 映射作为策略来处理 CRUD actions，如下：<br>GET /tickets - 获取 tickets 列表<br>GET /tickets/12 - 获取一个单独的 ticket<br>POST /tickets - 创建一个新的 ticket<br>PUT /tickets/12 - 更新 ticket #12<br>PATCH /tickets/12 - 部分更新 ticket #12<br>DELETE /tickets/12 - 删除 ticket #12</p><p>REST 非常棒的是，利用现有的 HTTP 方法在单个的 /tickets 接入点上实现了显著的功能。没有什么方法命名约定需要去遵循，URL 结构是整洁干净的。 REST 太棒了!</p><p>下面的是一个反例：<br>比如：左边是错误的设计，而右边是正确的<br>GET /rest/api/getDogs –&gt; GET /rest/api/dogs 获取所有小狗狗 GET /rest/api/addDogs –&gt; POST /rest/api/dogs 添加一个小狗狗 GET /rest/api/editDogs/:dog_id –&gt; PUT /rest/api/dogs/:dog_id 修改一个小狗狗 GET /rest/api/deleteDogs/:dog_id –&gt; DELETE /rest/api/dogs/:dog_id 删除一个小狗狗<br>左边的这种设计，很明显不符合REST风格，上面已经说了，URI 只负责准确无误的暴露资源，而 getDogs/addDogs…已经包含了对资源的操作，这是不对的。相反右边却满足了，它的操作是使用标准的HTTP动词来体现。总结起来就是：<br>URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</p><p>本文是我看了大量REST资料，根据自己理解总结而成，文中大量引用，糅合了不同资料，对这些乐于分享的人表示感谢。对REST的理解，可能有不当之处，欢迎交流指正。</p><p>参考资料如下：<br><a href="https://www.zhihu.com/question/28557115" target="_blank" rel="external">https://www.zhihu.com/question/28557115</a><br><a href="http://www.infoq.com/cn/articles/understanding-restful-style" target="_blank" rel="external">http://www.infoq.com/cn/articles/understanding-restful-style</a><br><a href="https://www.zhihu.com/question/28570307" target="_blank" rel="external">https://www.zhihu.com/question/28570307</a><br><a href="http://blog.csdn.net/douliw/article/details/52592188" target="_blank" rel="external">http://blog.csdn.net/douliw/article/details/52592188</a></p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议总结</title>
      <link href="/2017/04/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/HTTP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2017/04/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/HTTP%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>我们在测试中，经常与http协议， URL打交道，不时会修改URL的参数来达到不同的测试目的或者转到不同的页面，那么，你对HTTP协议了解多少呢？今天我们来总结下。<br><a id="more"></a><br>简介：<br>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）的协议。</p><p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p><p>主要特点:</p><ol><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效.<br>Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持B/S及C/S模式。</li></ol><p>URI<br>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。<br>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个URI来定位的.<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p><p>URL<br>URL全称是UniformResourceLocator, 中文叫统一资源定位符。是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。互联网上用URL来标识某一处资源的地址,主要用在各种WWW客户程序和服务器程序上.<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</p><p>URN<br>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:itesting@awsome.com。</p><p>三者关系<br>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL.</p><p>URL的组成部分及其含义:<br>以下面这个URL为例 <a href="http://www.itesting.com:8080/profile/index.aspx?id=5&amp;page=1#name" target="_blank" rel="external">http://www.itesting.com:8080/profile/index.aspx?id=5&amp;page=1#name</a><br>一个完整的URL包括以下几部分：<br>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。<br>2.域名部分：该URL的域名部分为“www.itesting.com”。一个URL中，也可以使用IP地址作为域名使用<br>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口<br>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/profile/”<br>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.aspx”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名<br>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分<br>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“id=5&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p><p>HTTP请求方法<br>http请求由三部分组成，分别是：请求行、消息报头、请求正文<br>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本<br>格式：Method Request-URI HTTP-Version CRLF<br>      Method表示请求方法；<br>      Request-URI是一个统一资源标识符；<br>      HTTP-Version表示请求的HTTP协议版本；<br>      CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF符）。<br>举例：<br>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)。</p><p>HTTP请求方法（所有方法全为大写）有多种，各个方法的解释如下：<br>GET     请求获取Request-URI所标识的资源<br>POST    在Request-URI所标识的资源后附加新的数据<br>HEAD    请求获取由Request-URI所标识的资源的响应消息报头<br>PUT     请求服务器存储一个资源，并用Request-URI作为其标识<br>DELETE  请求服务器删除Request-URI所标识的资源<br>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断<br>CONNECT 保留将来使用<br>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</p><p>常用的是GET， POST， PUT， DELETE<br>那这四种方法除语义外有什么其他区别呢？<br>首先介绍两个概念：安全性和幂等性。如果针对一个URL的方法不改变URL所指资源的状态，就称其为安全的，显然在这四种方法里，只有GET方法是安全的。幂等性，来源于数学上的术语，即对同一操作数的多次操作与一次操作效果是一样的操作符即称幂等操作符，比如取绝对值操作符。类比到网络操作中就是指一方法对同一URL的请求，多次和一次的效果是一致的，就称该方法是幂等的，显然除POST外其他三种方法都是幂等的，总结如下表：<br>http方法     安全   幂等<br>GET             是        是<br>POST           否        否<br>PUT             否        否<br>DELETE        否        否<br>另外在具体技术实现上，这四种方法也有一些区别，那么POST与GET有什么区别呢？</p><ol><li>使用目标不同：<br>POST与GET都用于获取信息，但是GET方式仅仅是查询，并不对服务器上的内容产生任何作用结果；每次GET的内容都是相同的。<br>POST则常用于发送一定的内容进行某些修改操作。</li><li>大小不同：<br>由于不同的浏览器对URL的长度大小有一定的字符限制，因此由于GET方式放在URL的首部中，自然也跟着首先，但是具体的大小要依浏览器而定。<br>POST方式则是把内容放在报文内容中，因此只要报文的内容没有限制，它的大小就没有限制。</li><li>安全性不同：<br>GET是直接添加到URL后面的，直接就可以在URL中看到内容。<br>而POST是放在报文内部的，用户无法直接看到。</li></ol><p>HTTP报文常见属性<br>chrome打开上面的link，按F12</p><ol><li>URL, 即http访问的地址</li><li>request method, 报文的请求方式</li><li>status code, 状态码以及状态短语</li><li>Accept Encoding, 内容编码</li><li>Connection, 连接方式</li><li>Cookie, 添加的cookie内容</li><li>Host, 目标主机</li><li>User-Agent, 客户端浏览器的相关信息</li><li>Set-Cookie, 指定想要在Cookie中保存的内容</li></ol><p>HTTP是无状态的，如何保存状态？<br>由于http是一种无状态的协议，因此无论是客户端还是服务器都不记录http的相关信息。这样设计一方面减轻了服务器端的负载，另一方面减小了http请求的开销。</p><p>但是针对某些特殊的场景，需要时刻记录用户的相关信息，这该如何处理呢?</p><p>cookie<br>客户端第一次访问，服务器在http响应头中添加Set-Cookie信息，其值的格式通常是name = value的格式。浏览器收到响应后会根据头中的字段保存cookie，下一次访问时在请求头中附带cookie内容，供服务器根据cookie值进行后续处理。<br>cookie的内容主要包括：名字，值，过期时间，路径和域。</p><p>cookie机制采用的是在客户端保持状态的方案。</p><p>与 cookie 相对的一个解决方案是 session:<br>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。<br>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识- 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 保存这个session id的方式可以采用cookie（一般这个cookie的名字都是类似于SEEESIONID），这样浏览器下次发请求的时候，这个session id会被放置在请求头中，和cookie一起发送回来。服务器再通过内存中保存的session id跟cookie中保存的ssession id进行比较，并根据id在内存中找到之前创建的session对象，提供给请求使用，也就是服务器会通过session保存一个状态记录，浏览器会通过cookie保存状态记录，服务器通过两者的对比实现跟踪状态，这样的做，也极大的避免了cookie被篡改而带来的安全性问题。<br>URL重写<br>由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。<br>附加方式：<br>1.作为URL路径的附加信息，表现形式为：<br><a href="http://...../xxx;jsessionid=ByOK" target="_blank" rel="external">http://...../xxx;jsessionid=ByOK</a> … 99zWpBng!-145788764<br>2.作为查询字符串附加在URL后面，表现形式为：<br><a href="http://...../xxx?jsessionid=ByOK" target="_blank" rel="external">http://...../xxx?jsessionid=ByOK</a> … 99zWpBng!-145788764</p><p>这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。<br>为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。</p><p>cookie和session的区别：<br>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>考虑到减轻服务器性能方面，应当使用COOKIE。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>5、所以个人建议：<br>将登陆信息等重要信息存放为SESSION<br>其他信息如果需要保留，可以放在COOKIE中</p><p>HTTP状态码<br>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求</p><p>常见状态码：<br>200 OK            //客户端请求成功</p><p>400 Bad Request   //客户端请求有语法错误，不能被服务器所理解</p><p>401 Unauthorized  //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </p><p>403 Forbidden     //服务器收到请求，但是拒绝提供服务</p><p>404 Not Found     //请求资源不存在，eg：输入了错误的URL</p><p>500 Internal Server Error     //服务器发生不可预期的错误</p><p>503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python读取excel文件</title>
      <link href="/2017/04/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/python%E8%AF%BB%E5%8F%96excel%E6%96%87%E4%BB%B6/"/>
      <url>/2017/04/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/python%E8%AF%BB%E5%8F%96excel%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>自动化测试中，测试数据一般保存在Excel里，过程产生的数据一般保存在SQL里，上次我们讲里如何读SQL 数据库，今天我们来看下，如何使用Python操作Excel。<br><a id="more"></a><br>Python操作Excel的library也有好多种，我们拿 Openpyxl为例子，它可以支持Excel2010：</p><blockquote><p>penpyxl is a Python library for reading and writing Excel 2010 xlsx/xlsm/xltx/xltm files</p></blockquote><p>安装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install openpyxl</div></pre></td></tr></table></figure><br>用法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook, Workbook</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    <span class="comment"># Create a workbook named test and it contains two tabs uat &amp; qa</span></div><div class="line">   file_name = <span class="string">r'c:\test.xlsx'</span></div><div class="line">   wb = Workbook()</div><div class="line">    wb.create_sheet(<span class="string">'uat'</span>,<span class="number">1</span>)</div><div class="line">    wb.create_sheet(<span class="string">'qa'</span>,<span class="number">1</span>)</div><div class="line">    wb.save(file_name)</div><div class="line"></div><div class="line">    <span class="comment"># Read &amp; write</span></div><div class="line">   wb2 = load_workbook(<span class="string">r'c:\test.xlsx'</span>)</div><div class="line">    <span class="comment"># List all sheets</span></div><div class="line">   <span class="keyword">print</span> wb2.get_sheet_names()</div><div class="line">    <span class="comment"># Get target sheet</span></div><div class="line">   s = wb2.get_sheet_by_name(<span class="string">'qa'</span>)</div><div class="line">    <span class="comment"># Two ways to set value for specific column/row</span></div><div class="line">   s.cell(row=<span class="number">2</span>,column=<span class="number">1</span>).value= <span class="number">6</span></div><div class="line">   s[<span class="string">'A2'</span>] = <span class="number">5</span></div><div class="line">   <span class="comment"># Get value for specific column/row</span></div><div class="line">   <span class="keyword">print</span> s.cell(row=<span class="number">2</span>,column=<span class="number">1</span>).value</div><div class="line">    <span class="keyword">print</span> s[<span class="string">'A2'</span>].value</div></pre></td></tr></table></figure><br>以上创建了一个workbook，然后又读取这个workbook，并在指定的sheet里设置单元格的值并读出， 代码本身已经解释了一切，无需再特殊说明用法。<br>这只是Python对Excel的简单实用，如果你有更深层的需求，可以参考官方网页：<br><a href="https://openpyxl.readthedocs.io/en/default/index.html" target="_blank" rel="external">官网</a>  </p><p>通过一周两次发布，我们逐步快把测试用常用的方法技术都讲解完毕了，如果大家想要更深层次的了解某个方法，可以直接回复，我会抽取问题最多的来讲解。</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Web-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLAlchemy连接数据库入门</title>
      <link href="/2017/04/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/SQLAlchemy%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"/>
      <url>/2017/04/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/SQLAlchemy%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>自动化测试中常常需要访问数据库来获得所需数据，Python里访问数据库的Library有很多，例如MySQL ，SQLite， SQLAlchemy 等，运用最广泛的当属SQLAlchemy， 我们今天就以SQLAlchemy为例，讲下如何连接，使用，更新数据库。<br><a id="more"></a></p><blockquote><p>SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL.<br>SQLAlchemy is most famous for its object-relational mapper (ORM), an optional component that provides the data mapper pattern, where classes can be mapped to the database in open ended, multiple ways - allowing the object model and database schema to develop in a cleanly decoupled way from the beginning.</p></blockquote><p>如何安装：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">        </div><div class="line">pip install SQLAlchemy</div></pre></td></tr></table></figure><br>如何使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</div><div class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, DateTime, String, Integer, text, and_</div><div class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</div><div class="line"></div><div class="line"><span class="comment"># 1</span></div><div class="line">base = declarative_base()</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassAudit</span><span class="params">(base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'ClassAudit'</span></div><div class="line"></div><div class="line">    Class_id = Column(Integer)</div><div class="line">    StudentMember_id = Column(Integer)</div><div class="line">    Comment = Column(String(<span class="number">100</span>))</div><div class="line">    ...</div><div class="line"><span class="comment"># 2 </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBHelper</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.engine = create_engine(<span class="string">"mssql+pymssql://用户名:密码@数据库ip/数据库名"</span>,</div><div class="line">                                    encoding=<span class="string">'latin1'</span>, echo=<span class="keyword">True</span>)</div><div class="line">        DBSession = sessionmaker(bind=self.engine)</div><div class="line">        self.dbsession = DBSession()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query_status</span><span class="params">(self, class_id, message)</span>:</span></div><div class="line">         query = self.dbsession.query(ClassAudit).filter(and_(ClassAudit.Class_id==class_id, ClassAudit.Comment.like(<span class="string">'%'</span>+ <span class="string">'%s'</span> % message + <span class="string">'%'</span> )))</div><div class="line">         <span class="keyword">return</span> query.all()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    db_helper = DBHelper()</div><div class="line">    <span class="comment"># Method 1</span></div><div class="line">    txt = db_helper.query_status(<span class="string">'1501287'</span>, <span class="string">'test'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> txt:</div><div class="line">        <span class="keyword">print</span> i.Comment</div><div class="line"></div><div class="line">    <span class="comment"># Method 2</span></div><div class="line">    sql_string = <span class="string">"""select * from teachers..classaudit where class_id='1501287' and comment like '%test%'"""</span></div><div class="line">    conn = db_helper.engine.connect()</div><div class="line">      txt = conn.execute(sql_string)</div><div class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> txt:</div><div class="line">       <span class="keyword">print</span> i.Comment</div></pre></td></tr></table></figure><br>根据上面的代码我们来逐步说明sqlalchemy的使用步骤：</p><ol><li>连接数据库<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>engine = create_engine(<span class="string">'sqlite:///:memory:'</span>, echo=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>create_engine()用来初始化数据库连接，语法如下：<br>‘数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名’</li><li>声明mapping关系<br>参考上面代码的#1和#2之间的代码。 ClassAudit是数据库表名，这里我们用来来和数据库中真实存在的table对应。要对应的table可以是已经存在的，也可以是要新建立的，如果是新建立的，那么顺序执行下面的3步。否则略过。</li><li>创建一个数据库表格并插入数据<br>#创建数据库<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, MetaData</div><div class="line"> </div><div class="line">engine = create_engine(<span class="string">'sqlite:///:memory:'</span>)</div><div class="line">metadata = MetaData()</div><div class="line"> </div><div class="line">user = Table(<span class="string">'user'</span>, metadata,</div><div class="line">    Column(<span class="string">'user_id'</span>, Integer, primary_key=<span class="keyword">True</span>),</div><div class="line">    Column(<span class="string">'user_name'</span>, String(<span class="number">16</span>), nullable=<span class="keyword">False</span>),</div><div class="line">    Column(<span class="string">'email_address'</span>, String(<span class="number">60</span>), key=<span class="string">'email'</span>),</div><div class="line">    Column(<span class="string">'password'</span>, String(<span class="number">20</span>), nullable=<span class="keyword">False</span>)</div><div class="line">)</div><div class="line"> </div><div class="line">metadata.create_all(engine)</div><div class="line"> </div><div class="line"><span class="comment">#插入数据</span></div><div class="line">ins = user.insert().values(name=<span class="string">'kevin'</span>, fullname=<span class="string">'Kevin cai'</span>)</div><div class="line">conn = engine.connect()</div><div class="line">result = conn.execute(ins)</div></pre></td></tr></table></figure></li><li>创建一个session<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">DBSession = sessionmaker(bind=self.engine)</div><div class="line">self.dbsession = DBSession()</div></pre></td></tr></table></figure></li><li>增加或者更新数据库对象<br>当需要添加数据库记录时使用，也可以用第3步的方法来插入数据。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">new_audit = ClassAudit(Class_id=<span class="number">1</span>, =’<span class="number">123</span>’,,,,)</div><div class="line">self.dbsession.add(ClassAudit)</div><div class="line">self.dbsession.commit()</div><div class="line">self.dbsession.close()</div></pre></td></tr></table></figure></li><li>查询<br>Query的关键字和函数用法如下：<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">AND:</div><div class="line">from sqlalchemy import and_</div><div class="line">session.query.filter(and_(User.name == 'kevin', User.fullname == kevin cai'))</div><div class="line">LIKE:</div><div class="line">session.query.filter(User.name.like('%test'))</div><div class="line">all() :returns a list:</div><div class="line">query = session.query(User).filter(User.name.like('%ed')).order_by(User.id)</div><div class="line">query.all()</div></pre></td></tr></table></figure>以上就是sqlalchemy对数据库的操作，这个通常在有很多表格并且这些表格有联系的情况下使用，如果你的代码里只需要查询独立的几个表格，你完全可以不建立表格的对应关系，直接使用sql语句，做法为删除掉上面#1和#2之间的代码，并且参考main函数中Method2的代码即可。</li></ol><p>SQLAlchemy是ORM技术的典型代表，希望大家都学会如何使用（Object-Relational Mapping，把关系数据库的表结构映射到对象上)。</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Web-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebService自动化-浅谈WSDL调用</title>
      <link href="/2017/04/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/WebService%E8%87%AA%E5%8A%A8%E5%8C%96--%E6%B5%85%E8%B0%88WSDL%E8%B0%83%E7%94%A8/"/>
      <url>/2017/04/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/WebService%E8%87%AA%E5%8A%A8%E5%8C%96--%E6%B5%85%E8%B0%88WSDL%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在做自动化测试的过程中，有时候需要测试一个业务流程特定的部分， 这个特定部分可能是接口，它往往需要依赖前期产生的数据输出作为输入，这个时候，重新跑一遍前边流程来获得需要的数据显然不合理， 那么利用后端开发发布出来的web service来直接生成所需数据就显得尤为便捷，<br>今天我们就来看如何利用suds调用web service。<br><a id="more"></a></p><blockquote><p>Suds is a lightweight SOAP python client for consuming Web Services.<br>The suds Client class provides a consolidated API for consuming web services. The object contains (2) sub-namespaces:</p><ul><li>service<br>The service namespace provides a proxy for the consumed service. This object is used to invoke operations (methods) provided by the service endpoint.</li><li>factory<br>The factory namespace provides a factory that may be used to create instances of objects and types defined in the WSDL.</li></ul></blockquote><p>suds Client 是作为一个API来消费提供的web services， 它有两个子命名空间：</p><ul><li>Service ：对象用来调用被消费的web service提供的方法。</li><li>Factory：提供一个工厂用来生成一个定义在WSDL的对象或方法的实例。</li></ul><p>简单来说就是service用来直接调用web service里的方法，factory用来生成一个web service对象实例。</p><p>我们用一段代码来说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> suds.client <span class="keyword">import</span> Client</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebServices</span><span class="params">(object)</span>:</span></div><div class="line">    WSDL_ADDRESS = <span class="string">"http://*/services/*/StudentPrivateLessonService.svc?wsdl"</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.web_service = Client(self.WSDL_ADDRESS)</div><div class="line">        <span class="keyword">print</span> self.web_service</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_class_booked</span><span class="params">(self, class_id, member_id)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.web_service.service.IsClassBooked(class_id, member_id)[<span class="string">"ClassBooked"</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cancel_clas</span><span class="params">(self, class_id, member_id)</span>:</span></div><div class="line">        parameter = self.web_service.factory.create(<span class="string">"CancelClass"</span>)</div><div class="line">        <span class="keyword">print</span> parameter</div><div class="line">        <span class="keyword">print</span> dir(parameter)</div><div class="line">        parameter.param.Class_id = class_id</div><div class="line">        parameter.param.Member_id = member_id</div><div class="line">        parameter.param.CancelBy = <span class="string">'T'</span></div><div class="line">     parameter.param.CancelReason = <span class="string">'test'</span></div><div class="line">     <span class="keyword">return</span> self.web_service.service.CancelClass(parameter.param)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    web_service_class = WebServices()</div><div class="line">    <span class="keyword">print</span> web_service_class.is_class_booked(<span class="string">'315983'</span>, <span class="string">'23540202'</span>)</div><div class="line">    <span class="keyword">print</span> web_service_class.cancel_clas(<span class="string">'315983'</span>, <span class="string">'23540202'</span>)</div></pre></td></tr></table></figure><br>以上代码里：</p><ul><li>WSDL_ADRESS：是我们提供的web service的地址。</li><li><strong>init</strong>方法： 实现了suds client的生成， client的用法如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> suds.client <span class="keyword">import</span> Client</div><div class="line">url = <span class="string">'http://*.?wsdl'</span></div><div class="line">client = Client(url)</div></pre></td></tr></table></figure></li><li>is_class_booked 方法：使用了client的service这个命名空间，即直接调用web service 的可用方法。那么如何知道哪个方法如何调用呢？</li></ul><p>参考代码里<strong>init</strong>方法的print语句，打印出来了所有可用的方法和类型， print的打印结果片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Suds ( https://fedorahosted.org/suds/ )  version: 0.4 GA  build: R699-20100913</div><div class="line"></div><div class="line">Service ( StudentPrivateLessonService ) tns=&quot;http://tempuri.org/&quot;</div><div class="line">   Prefixes (9)</div><div class="line">      ns0 = &quot;EFSchools.Englishtown.TeacherTools.Client.ServiceParams&quot;</div><div class="line">      ns1 = &quot;EFSchools.Englishtown.TeacherTools.Client.ServiceParams.StudentPrivateLesson&quot;</div><div class="line">      ---</div><div class="line">      ns8 = &quot;http://tempuri.org/&quot;</div><div class="line">   Ports (1):</div><div class="line">      (BasicHttpBinding_IStudentPrivateLessonService)</div><div class="line">         Methods (18):</div><div class="line">      ---</div><div class="line">            ** CancelClass(ns1:CancelParameter param, )</div><div class="line">            ---</div><div class="line">            ** IsClassBooked(xs:int class_id, xs:int member_id, )</div><div class="line">      ---</div><div class="line">         Types (47):</div><div class="line">            ns4:ArrayOfBatchCancelDetail</div><div class="line">            ns4:ArrayOfBookablePLClass</div><div class="line">            ns4:ArrayOfBookedPLClass</div><div class="line">       ---</div></pre></td></tr></table></figure><br>从打印结果可以看出，IsClassBooked方法可以直接调用，它需要2个参数，类型为int型。</p><p>Cancel_class方法：利用了 client的factory这个命名空间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parameter = self.web_service.factory.create(<span class="string">"CancelClass"</span>) </div></pre></td></tr></table></figure><br>创建了Cancel Class这个方法的一个实例，然后通过 print parameter，可以看出这个函数的参数组成：<br><img src="/2017/04/02/自动化测试系列/WebService自动化--浅谈WSDL调用/0.jpg" alt=""><br>它是一个字典，字典的param的值又是一个字典，故我们要调用这个方法时下需要用Parameter.param.Class_id 这样的方式来引用。</p><p>下图是整段代码的运行结果：<br><img src="/2017/04/02/自动化测试系列/WebService自动化--浅谈WSDL调用/1.jpg" alt=""><br>证明成功，我们再去DB里查下结果：<br><img src="/2017/04/02/自动化测试系列/WebService自动化--浅谈WSDL调用/2.jpg" alt=""><br>可以看出，有一条新的记录添加出来。</p><p>以上，只要给出WSDL的地址，导入suds，通过Client， service， factory这3个类就可以实现web services的自动化调用，是不是很简单？</p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Web-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie 基本知识</title>
      <link href="/2017/04/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/Cookie%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2017/04/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/Cookie%20%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>Cookie是当前识别用户，实现持久会话的最好方式。Cookie最初是由网景公司开发，但是现在所有的主要浏览器都支持它。<br><a id="more"></a></p><p>Cookie的类型：会话Cookie和持久Cookie</p><ul><li>会话Cookie是一种临时Cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话Cookie就被删除了。</li><li>持久Cookie生存的时间相对较长，他们存储在硬盘上，浏览器退出，计算机重启它们仍然存在。通常会用持久Cookie维护用户会周期性访问的站点的配置文件或登录名。</li></ul><p>会话Cookie和持久Cookie的唯一区别就是他们的过期时间。<br>如果设置了Discard参数，或者没有设置Expires或Max-Age参数来说明扩展的过期时间，这个Cookie就是一个会话Cookie。<br>想做持久Cookie—–一定要设置Expires或Max-Age参数。</p><p>下面总结记录一些关于http的cookie的知识：</p><ol><li>cookie的属性<br>一般cookie所具有的属性，包括：</li></ol><ul><li>Domain：域，表示当前cookie所属于哪个域或子域下面。<br>对于服务器返回的Set-Cookie中，如果没有指定Domain的值，那么其Domain的值是默认为当前所提交的http的请求所对应的主域名的。比如访问 <a href="http://www.example.com，返回一个cookie，没有指名domain值，那么其为值为默认的www.example.com。" target="_blank" rel="external">http://www.example.com，返回一个cookie，没有指名domain值，那么其为值为默认的www.example.com。</a></li><li>Path：表示cookie的所属路径。</li><li>Expire time / Max-age：表示了cookie的有效期。</li><li>expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。<br>如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了。</li><li>secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输。</li><li>httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的。</li></ul><ol><li>关于把cookie从从服务器发送给客户端<br>从服务器端，发送cookie给客户端，是对应的Set-Cookie。<br>包括了对应的cookie的名称，值，以及各个属性。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: lu=Rg3vHJZnehYLjVg7qi3bZjzg; Expires=Tue, 15 Jan 2013 21:47:38 GMT; Path=/; Domain=.foo.com; HttpOnly</div><div class="line">Set-Cookie: made_write_conn=1295214458; Path=/; Domain=.foo.com</div><div class="line">Set-Cookie: reg_fb_gate=deleted; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Path=/; Domain=.foo.com; HttpOnly</div></pre></td></tr></table></figure></li><li>关于把cookie从客户端发送到服务器<br>从客户端发送cookie给服务器的时候，是不发送cookie的各个属性的，而只是发送对应的名称和值。<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">GET /spec.html HTTP/1.1</div><div class="line">Host: www.example.org</div><div class="line">Cookie: name=value; name2=value2</div><div class="line">Accept: */*</div></pre></td></tr></table></figure></li><li>关于修改，设置cookie<br>除了服务器发送给客户端（浏览器）的时候，通过Set-Cookie，创建或更新对应的cookie之外，<br>还可以通过浏览器内置的一些脚本，比如javascript，去设置对应的cookie，对应实现是操作js中的document.cookie。</li></ol>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web-Test </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用cookie实现自动登录</title>
      <link href="/2017/04/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/"/>
      <url>/2017/04/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8cookie%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>在使用Webdriver 自动化测试过程中，譬如，一个网页系统，如果我想测试登录成功后的一个具体页面，比如 学生可以参加的课程的页面，那么一般流程是：<br><a id="more"></a></p><ol><li>用户登录（UI登录，可以新写脚本，也可以利用已存在的脚本）。</li><li>登录成功后跳转到目标页面，验证目标页面是否正确。</li><li>开始具体的测试执行。<br>这样就有一个问题，无论测试什么功能step 1 都会被重复执行，我的目标页面必须借助 Step 1才能达到。 假如目标页面UI没有改变，但是Login界面的UI改变了，那么我的脚本会执行失败， 有没有办法去掉无关页面的干扰直接测试目标页面呢？<br>当然有，我们可以利用cookie达到。原理很简单，就是利用服务器返回的登录成功的用户cookie，把它写入到当前的driver中，从而实现不依赖Login UI的目的。</li></ol><p>具体做法如下：</p><ol><li>利用Requests 直接发送请求给登录的API， 这里以*.englishtown.com/login/handler.ashx 为例，成功登录后拿到server 返回的cookie。</li><li>把cookie写入到webdriver的driver， 然后利用driver.get(url)跳转到目标页面。</li></ol><p>关于Requests的用法，请查看官方文档。</p><p>核心代码如下（Python）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"></div><div class="line"><span class="keyword">import</span> settings</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginAPI</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.s = requests.session()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cookie_to_selenium_format</span><span class="params">(self, cookie)</span>:</span></div><div class="line">        cookie_selenium_mapping = &#123;<span class="string">'path'</span>:<span class="string">''</span>, <span class="string">'secure'</span>:<span class="string">''</span>, <span class="string">'name'</span>:<span class="string">''</span>, <span class="string">'value'</span>:<span class="string">''</span>,<span class="string">'expires'</span>:<span class="string">''</span>&#125;</div><div class="line">        cookie_dict = &#123;&#125;</div><div class="line">        <span class="keyword">if</span> getattr(cookie, <span class="string">'domain_initial_dot'</span>):</div><div class="line">            cookie_dict[<span class="string">'domain'</span>] = <span class="string">'.'</span> + getattr(cookie, <span class="string">'domain'</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            cookie_dict[<span class="string">'domain'</span>] = getattr(cookie, <span class="string">'domain'</span>)</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> cookie_selenium_mapping.keys():</div><div class="line">            key = k</div><div class="line">            value = getattr(cookie, k)</div><div class="line">            cookie_dict[key] = value</div><div class="line">        <span class="keyword">return</span> cookie_dict</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">page_login</span><span class="params">(self, driver, target_url, account_dict)</span>:</span></div><div class="line">        login_url = settings.COOKIE_LOGIN_URL</div><div class="line">        login_start_time = datetime.datetime.now()</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            login_status = self.s.post(login_url, account_dict)</div><div class="line">            login_end_time = datetime.datetime.now()</div><div class="line">            login_duration = login_end_time - login_start_time</div><div class="line">        <span class="keyword">except</span> requests.exceptions.Timeout:</div><div class="line">            <span class="keyword">print</span> <span class="string">"Time out"</span></div><div class="line">        <span class="keyword">except</span> requests.exceptions.TooManyRedirects:</div><div class="line">            <span class="keyword">print</span> <span class="string">"Too many redirects"</span></div><div class="line">        <span class="keyword">except</span> requests.exceptions.ConnectionError:</div><div class="line">            <span class="keyword">print</span> <span class="string">"Connection error"</span></div><div class="line">            login_status = self.s.post(login_url, account_dict)</div><div class="line">            login_end_time = datetime.datetime.now()</div><div class="line">            login_duration = login_end_time - login_start_time</div><div class="line">        <span class="keyword">except</span> Exception, e:</div><div class="line">            <span class="keyword">print</span> e</div><div class="line"></div><div class="line">        <span class="keyword">if</span> int(login_status.status_code) == <span class="number">200</span>:</div><div class="line">            all_cookies = tuple(self.s.cookies)</div><div class="line">            driver.get(target_url)</div><div class="line">            driver.delete_all_cookies()</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(all_cookies)):</div><div class="line">                driver.add_cookie(self.cookie_to_selenium_format(all_cookies[i]))</div><div class="line">            driver.get(target_url)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> ValueError, <span class="string">"Response code not equal to 200, log in failed!,\</span></div><div class="line">            status code is &#123;&#125;, duration time is &#123;&#125; ".format(login_status.status_code, login_duration)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    login = LoginAPI()</div><div class="line">    target_url = settings.MY_BOOKINGS_PAGE_URL</div><div class="line">    account_dict = settings.Account.B2B_Account</div><div class="line">    driver = webdriver.Chrome()</div><div class="line">    login.page_login(driver, target_url, account_dict)</div><div class="line"></div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> automation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> automation </tag>
            
            <tag> Web-Test </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何模拟不同网络环境及设置丢包率？</title>
      <link href="/2017/04/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%AE%BE%E7%BD%AE%E4%B8%A2%E5%8C%85%E7%8E%87%EF%BC%9F/"/>
      <url>/2017/04/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%B3%BB%E5%88%97/%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83%E5%8F%8A%E8%AE%BE%E7%BD%AE%E4%B8%A2%E5%8C%85%E7%8E%87%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>我们的产品近期收到关于网络情况的很多反馈，学生在上课过程中和老师的视频，音频有时候会不那么流畅，这个时候我们需要知道导致网络问题的原因是什么,<br>于是开发了一个新的功能来显示当前网络的联通情况，这种情况下，就需要我们测试不同的网络连接质量下产品的稳定度，显然我们需要模拟不同的网络情况，<br>那么有没有好用的工具呢？<br><a id="more"></a><br>我们开始使用chrome浏览器自带的throtting，不过它只能模拟不同的网络情况无法设置丢包率等。<br>经过搜索，发现了NetWork Enulator Client, 它是一款简单易用的工具，可以模拟不同的网络情况包括丢包率等等。</p><p>使用如下：</p><ol><li>安装好后打开，新建一个channel：<br><img src="/2017/04/02/软件测试基础知识系列/如何模拟不同网络环境及设置丢包率？/0.jpg" alt=""></li><li>Channel建立好后，还在configuration选项里，选择new  Filter, 在弹出的选项里，选择你要的网卡，我们这里全选。<br><img src="/2017/04/02/软件测试基础知识系列/如何模拟不同网络环境及设置丢包率？/1.jpg" alt=""></li><li>新建立一个Link，Configuration-&gt;New Link,<br><img src="/2017/04/02/软件测试基础知识系列/如何模拟不同网络环境及设置丢包率？/2.jpg" alt=""><br>然后在新建立的link上，点击右键，设置incoming/outcoming的丢包率。<br><img src="/2017/04/02/软件测试基础知识系列/如何模拟不同网络环境及设置丢包率？/3.jpg" alt=""><br><img src="/2017/04/02/软件测试基础知识系列/如何模拟不同网络环境及设置丢包率？/4.jpg" alt=""><br>设置好后保存，点击开始按钮，就可以了。<br>说明：<br>No Loss：默认，不模拟丢包<br>Periodic loss: 模拟周期性的丢包。按填写数量(设为x个)，每x个包，就丢一个包(one packet is dropped per given number of packets)。<br>Random loss: 模拟随机丢包，按给定丢包的概率，随机丢包。<br>Burst loss: 模拟根据给定的可能性进行丢包。当发生一个丢包事件时，接着连续丢几个包（丢包数量控制在最大(max)最小值(min)之间）。<br>G-E loss: 模拟发生数据包丢失遵循Gilbert-Elliot模型，由两个状态组成：好的状态和坏的状态。可分别为这2个状态指定数据包丢失率,同时可设置网络传输在这两种状态的概率<br>（And the network transit between the two states is at given transition probabilities）</li></ol><p>PS：<br>      进入到cmd， ping自己的网关地址，就可以观察自己的设置是否起效。</p>]]></content>
      
      
      <categories>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 多进程</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%20%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%20%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Python 多进程</p><a id="more"></a><p>前面我们讲了multiple thread的用法， 在Python中，由于GIL（Global Interpreter Lock）的存在（ GIL將会防止多个原生线程同时执行Python字节码。换句话说,GIL將序列化您的所有线程，也就是说，多线程等于时分复用，一个时刻只有一个线程运行），多线程就最多只能用满1个CPU核心，无法真正利用多核的优势。</p><p>Python提供了非常好用的多进程包multiprocessing，mutilprocess像线程一样管理进程，这个是mutilprocess的核心，他与threading很是相像，对多核CPU的利用率会比threading好的多。</p><p>多进程用法如下：</p><ol><li>Process<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(msg)</span>:</span></div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</div><div class="line">    <span class="keyword">print</span> msg</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">  p = multiprocessing.Process(target=func, args=(<span class="string">"hello"</span>, ))</div><div class="line">  p.start()</div><div class="line">  p.join()</div><div class="line">  <span class="keyword">print</span> <span class="string">"Sub-process done."</span></div></pre></td></tr></table></figure></li><li>生产者消费者多进程模型Queue<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">que = Queue()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProduceMethod</span><span class="params">(multiprocessing.Process)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, que)</span>:</span></div><div class="line">        multiprocessing.Process.__init__(self)</div><div class="line">        self.data = que</div><div class="line">        self.name = <span class="string">"Process%s"</span> %name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> self.data.qsize() &lt; <span class="number">2</span>:</div><div class="line">                self.do_produce(self.name)</div><div class="line">                time.sleep(<span class="number">10</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">"queue is %s, stop produce"</span>%self.data.qsize()</div><div class="line">                time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_produce</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"Before produce, the queue size is %s"</span>%self.data.qsize()</div><div class="line">        product = random.randint(<span class="number">0</span>, <span class="number">10</span>)</div><div class="line">        self.data.put(product)</div><div class="line">        <span class="keyword">print</span> <span class="string">"%s produce product -- %s, after produce, queue is %s now"</span>%(name, product,self.data.qsize())</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeMethodEven</span><span class="params">(multiprocessing.Process)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, que)</span>:</span></div><div class="line">        multiprocessing.Process.__init__(self)</div><div class="line">        self.data = que</div><div class="line">        self.name = <span class="string">"Thread %s"</span> %name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"></div><div class="line">            <span class="keyword">if</span> self.data.qsize()&gt;<span class="number">0</span>:</div><div class="line">                self.do_consume(self.name)</div><div class="line">                time.sleep(<span class="number">5</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">"queue is %s, stop consume"</span>%self.data.qsize()</div><div class="line">                time.sleep(<span class="number">5</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_consume</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">print</span><span class="string">"before consume,the quque size is %s"</span>%self.data.qsize()</div><div class="line">        product = self.data.get()</div><div class="line">        <span class="keyword">if</span> product %<span class="number">2</span> ==<span class="number">0</span>:</div><div class="line">            <span class="keyword">print</span><span class="string">"%s consume product -- %s, after consume, queue is %s now"</span>%(name, product, self.data.qsize())</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">        p1 = ProduceMethod(i, que)</div><div class="line">        p1.start()</div><div class="line">    c1 = ConsumeMethodEven(<span class="number">1</span>, que)</div><div class="line">    c1.start()</div></pre></td></tr></table></figure>由代码可以看出，多进程的方法名和函数名跟多线程基本一模一样，这样就方便了我们开发者（当然内部实现由很多不同），这也是Python容易上手的的一个作证吧。</li><li>Pool<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> multiprocessing</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(msg)</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">" Sub-process(es) %s said %s."</span>%(os.getpid(), msg)</div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">  pool = multiprocessing.Pool(processes=<span class="number">4</span>)</div><div class="line">  <span class="keyword">print</span> <span class="string">"parent id is %s"</span>%os.getpid()</div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    msg = <span class="string">"hello %d"</span> %(i)</div><div class="line">    <span class="comment">#注意要用apply_async，如果用apply，就变成阻塞版本了。</span></div><div class="line">    pool.apply_async(func, (msg, ))</div><div class="line">  pool.close()</div><div class="line">  pool.join()</div><div class="line">看一下运行结果：</div><div class="line">parent id <span class="keyword">is</span> <span class="number">8804</span></div><div class="line"> Sub-process(es) <span class="number">10948</span> said hello <span class="number">0.</span></div><div class="line"> Sub-process(es) <span class="number">428</span> said hello <span class="number">1.</span></div><div class="line"> Sub-process(es) <span class="number">8592</span> said hello <span class="number">2.</span></div><div class="line"> Sub-process(es) <span class="number">16112</span> said hello <span class="number">3.</span></div><div class="line"> Sub-process(es) <span class="number">10948</span> said hello <span class="number">4.</span></div><div class="line"> Sub-process(es) <span class="number">428</span> said hello <span class="number">5.</span></div><div class="line"> Sub-process(es) <span class="number">8592</span> said hello <span class="number">6.</span></div><div class="line"> Sub-process(es) <span class="number">16112</span> said hello <span class="number">7.</span></div><div class="line"> Sub-process(es) <span class="number">8592</span> said hello <span class="number">8.</span></div><div class="line"> Sub-process(es) <span class="number">428</span> said hello <span class="number">9.</span></div></pre></td></tr></table></figure>在运行中，你会看到打印出来的记录是4个一批，打印好4个马上打印下一个4个，那是因为我们设置了processes=4是最多并发进程数量。</li></ol><p>何时用多进程：<br>对于计算密集型程序，多进程并发优于多线程并发。计算密集型程序指的程序的运行时间大部分消耗在CPU的运算处理过程，而硬盘和内存的读写消耗的时间很短；相对地，IO密集型程序指的则是程序的运行时间大部分消耗在硬盘和内存的读写上，CPU的运算时间很短。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python多线程系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Queue详解</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%20Queue%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%20Queue%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>上次我们讲了多线程的condition来实现 生产者消费者模式，今天我们介绍下另外一个方法， Queue, 它是线程安全的，天生利于实现多生产者多消费者模型。</p><a id="more"></a><p>Python的Queue模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列PriorityQueue。这些队列都实现了锁原语，能够在多线程中直接使用。可以使用队列来实现线程间的同步。</p><p>我们先来看一个多生产者多消费者的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">con = threading.Condition()</div><div class="line">que = Queue.Queue()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProduceMethod</span><span class="params">(threading.Thread)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, que)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.data = que</div><div class="line">        self.name = <span class="string">"Thread%s"</span> %name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">if</span> self.data.qsize() &lt; <span class="number">2</span>:</div><div class="line">                self.do_produce(self.name)</div><div class="line">                time.sleep(<span class="number">10</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">"queue is %s, stop produce"</span>%self.data.qsize()</div><div class="line">                time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_produce</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"Before produce, the queue size is %s"</span>%self.data.qsize()</div><div class="line">        product = random.randint(<span class="number">0</span>, <span class="number">10</span>)</div><div class="line">        self.data.put(product)</div><div class="line">        <span class="keyword">print</span> <span class="string">"%s produce product -- %s, after produce, queue is %s now"</span>%(name, product,self.data.qsize())</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeMethodEven</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, que)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.data = que</div><div class="line">        self.name = <span class="string">"Thread %s"</span> %name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line"></div><div class="line">            <span class="keyword">if</span> self.data.qsize()&gt;<span class="number">0</span>:</div><div class="line">                self.do_consume(self.name)</div><div class="line">                self.data.task_done()</div><div class="line">                time.sleep(<span class="number">5</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">print</span> <span class="string">"queue is %s, stop consume"</span>%self.data.qsize()</div><div class="line">                time.sleep(<span class="number">5</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_consume</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">print</span><span class="string">"before consume,the quque size is %s"</span>%self.data.qsize()</div><div class="line">        product = self.data.get()</div><div class="line">        <span class="keyword">if</span> product %<span class="number">2</span> ==<span class="number">0</span>:</div><div class="line">            <span class="keyword">print</span><span class="string">"%s consume product -- %s, after consume, queue is %s now"</span>%(name, product, self.data.qsize())</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">        p1 = ProduceMethod(i, que)</div><div class="line">        p1.start()</div><div class="line">    c1 = ConsumeMethodEven(<span class="number">1</span>, que)</div><div class="line">    c1.start()</div><div class="line">运行结果如下：</div><div class="line">Before produce, the queue size <span class="keyword">is</span> <span class="number">0</span></div><div class="line">Thread0 produce product -- <span class="number">4</span>, after produce, queue <span class="keyword">is</span> <span class="number">1</span> now</div><div class="line">Before produce, the queue size <span class="keyword">is</span> <span class="number">1</span></div><div class="line">Thread1 produce product -- <span class="number">10</span>, after produce, queue <span class="keyword">is</span> <span class="number">2</span> now</div><div class="line">before consume,the quque size <span class="keyword">is</span> <span class="number">2</span></div><div class="line">Thread <span class="number">1</span> consume product -- <span class="number">4</span>, after consume, queue <span class="keyword">is</span> <span class="number">1</span> now</div><div class="line">before consume,the quque size <span class="keyword">is</span> <span class="number">1</span></div><div class="line">Thread <span class="number">1</span> consume product -- <span class="number">10</span>, after consume, queue <span class="keyword">is</span> <span class="number">0</span> now</div><div class="line">Before produce, the queue size <span class="keyword">is</span> <span class="number">0</span></div><div class="line">......</div></pre></td></tr></table></figure><br>可以看到我们完全不需要自己加锁实现线程同步，Queue的get， 和put操作，自带锁，使用的时候，不用对队列加锁操作。</p><p>是不是很方便，再来看下Queue的一些用法：<br>Queue.qsize() 返回队列的大小<br>Queue.empty() 如果队列为空，返回True,反之False<br>Queue.full() 如果队列满了，返回True,反之False。Queue.full 与 maxsize 大小对应<br>Queue.put(item[, block[, timeout]]) ：<br>写入队列，timeout等待时间，如果可选的参数block为True且timeout为空对象（默认的情况，阻塞调用，无超时）。<br>如果timeout是个正整数，阻塞调用进程最多timeout秒，如果一直无空空间可用，抛出Full异常（带超时的阻塞调用）。<br>如果block为False，如果有空闲空间可用将数据放入队列，否则立即抛出Full异常<br>Queue.put_nowait(item) 相当Queue.put(item, False)<br>Queue.get([block[, timeout]])从队列中移除并返回一个数据。block跟timeout参数同put方法<br>Queue.get_nowait() 相当Queue.get(False)<br>Queue.task_done()：<br>意味着之前入队的一个任务已经完成。由队列的消费者线程调用。每一个get()调用得到一个任务，接下来的task_done()调用告诉队列该任务已经处理完毕。<br>如果当前一个join()正在阻塞，它将在队列中的所有任务都处理完时恢复执行（即每一个由put()调用入队的任务都有一个对应的task_done()调用）join()。<br>Queue.join()：<br>阻塞调用线程，直到队列中的所有任务被处理掉。只要有数据被加入队列，未完成的任务数就会增加。当消费者线程调用task_done()（意味着有消费者取得任务并完成任务），未完成的任务数就会减少。当未完成的任务数降到0，join()解除阻塞。实际上意味着等到队列为空，再执行别的操作。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python多线程系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程系列 -- Condition</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20Condition/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20Condition/</url>
      
        <content type="html"><![CDATA[<p>Python多线程系列 – Condition</p><a id="more"></a><p>经过前几次的学习，我们已经明白了多线程的大致用法，我们也可以用lock， rlock 来控制简单的线程同步，那么稍微复杂点的线程同步，比如我需要等到一定条件触发的情况下才处理数据，该怎么办呢？</p><p>下面我们以经典的消费者，生产者模型， 来讲解下threading.condition的用法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">product = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="comment">#Condition</span></div><div class="line"></div><div class="line">con = threading.Condition()</div><div class="line"><span class="comment">#Produce method</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProduceMethod</span><span class="params">(threading.Thread)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        threading.Thread.__init__(self)    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> product        </div><div class="line">        <span class="keyword">if</span> con.acquire():            </div><div class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:                </div><div class="line">                <span class="keyword">if</span> product <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                    <span class="keyword">print</span> <span class="string">"Produce....."</span></div><div class="line">                    self.do_produce()</div><div class="line">                    <span class="keyword">print</span> <span class="string">"Now we have %s products"</span> %product                    <span class="comment">#Notify consumer, product is generated</span></div><div class="line">                    con.notify()                </div><div class="line">                 <span class="comment">#Wait notify</span></div><div class="line">                 con.wait()</div><div class="line">                 time.sleep(<span class="number">2</span>)    </div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">do_produce</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> product</div><div class="line">        product = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> (product &lt;<span class="number">10</span>):</div><div class="line">            product +=<span class="number">1</span></div><div class="line">            <span class="keyword">print</span> product</div><div class="line">     </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeMethod</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> product</div><div class="line">        <span class="keyword">if</span> con.acquire():</div><div class="line">           <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">              <span class="keyword">if</span> product <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:     </div><div class="line">                  <span class="keyword">print</span> <span class="string">"Consume...."</span></div><div class="line">                  self.do_consume()                    </div><div class="line">                  <span class="comment">#Notify produceser, no product</span></div><div class="line">                  con.notify()                </div><div class="line">               <span class="comment">#wait notify</span></div><div class="line">               con.wait()</div><div class="line">               time.sleep(<span class="number">2</span>)    </div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">do_consume</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> product        </div><div class="line">        <span class="keyword">while</span> product&gt;<span class="number">0</span>:</div><div class="line">            <span class="keyword">print</span> product </div><div class="line">            product -= <span class="number">1</span>  </div><div class="line">        <span class="keyword">if</span> product == <span class="number">0</span>:</div><div class="line">            product = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    t1 = ProduceMethod()</div><div class="line">    t2 = ConsumeMethod()</div><div class="line">    t1.start()</div><div class="line">    t2.start()</div><div class="line">运行结果可以看到，程序在不停的生产，消费。</div><div class="line">Produce.....</div><div class="line"><span class="number">1</span></div><div class="line">.........</div><div class="line"><span class="number">10</span></div><div class="line">Now we have <span class="number">10</span> products</div><div class="line">Consume....</div><div class="line"><span class="number">10</span></div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line">Produce.....</div><div class="line">（继续循环）</div></pre></td></tr></table></figure><br>Condition对象可以在某些事件触发或者达到特定条件后才处理数据，可以把Condiftion理解为一把高级的琐，它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题。</p><p>threadiong.Condition在内部维护一个琐对象（默认是RLock），可以在创建Condition对象的时候把琐对象作为参数传入。Condition也提供了acquire, release方法，其含义与Lock的acquire, release方法一致，其实它只是简单的调用内部琐对象的对应的方法而已。Condition还提供了如下方法(特别要注意：这些方法只有在占用Lock(acquire)之后才能调用，否则将会报RuntimeError异常。)：</p><p>Condition.wait([timeout]):<br>wait方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。</p><p>Condition.notify():<br>唤醒一个挂起的线程（如果存在挂起的线程）。注意：notify()方法不会释放所占用的琐。</p><p>Condition.notify_all()<br>Condition.notifyAll()<br>唤醒所有挂起的线程（如果存在挂起的线程）。注意：这些方法不会释放所占用的琐。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python多线程系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程系列 -- Lock和RLock</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20Lock%E5%92%8CRLock/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20Lock%E5%92%8CRLock/</url>
      
        <content type="html"><![CDATA[<p>Lock和RLock</p><a id="more"></a><p>先来说下Lock的作用：<br>用来确保多线程多共享资源的访问。</p><p>下面直接看代码， 如果你不用lock：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadExample_2</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        threading.Thread.__init__(self)   </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> x    </div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        x +=<span class="number">1</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'%s get the lock, number is %s'</span> \</div><div class="line">    % (threading.currentThread().getName(), x)</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    lock = threading.Lock()    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        t = ThreadExample_2()</div><div class="line">        t.start()</div><div class="line">运行结果如下：</div><div class="line">Thread<span class="number">-1</span> get the lock, number <span class="keyword">is</span> <span class="number">1</span></div><div class="line">Thread<span class="number">-5</span> get the lock, number <span class="keyword">is</span> <span class="number">2</span></div><div class="line">Thread<span class="number">-4</span> get the lock, number <span class="keyword">is</span> <span class="number">3</span></div><div class="line">Thread<span class="number">-3</span> get the lock, number <span class="keyword">is</span> <span class="number">4</span></div><div class="line">Thread<span class="number">-2</span> get the lock, number <span class="keyword">is</span> <span class="number">5</span></div><div class="line">再次运行一遍，结果如下：</div><div class="line">Thread<span class="number">-1</span> get the lock, number <span class="keyword">is</span> <span class="number">1</span></div><div class="line">Thread<span class="number">-2</span> get the lock, number <span class="keyword">is</span> <span class="number">2</span></div><div class="line">Thread<span class="number">-5</span> get the lock, number <span class="keyword">is</span> <span class="number">3</span></div><div class="line">Thread<span class="number">-4</span> get the lock, number <span class="keyword">is</span> <span class="number">4</span></div><div class="line">Thread<span class="number">-3</span> get the lock, number <span class="keyword">is</span> <span class="number">5</span></div><div class="line">两次运行的结果不一样，你肯定不想你的程序随机输出吧？</div></pre></td></tr></table></figure><br>用下lock看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadExample_2</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        threading.Thread.__init__(self)    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">global</span> x        </div><div class="line">        <span class="keyword">if</span> lock.acquire():             </div><div class="line">             <span class="keyword">print</span> <span class="string">'%s get the lock.'</span> % threading.currentThread().getName()</div><div class="line">             x +=<span class="number">1</span></div><div class="line">             <span class="keyword">print</span> x</div><div class="line">             time.sleep(<span class="number">3</span>)             </div><div class="line">             <span class="keyword">print</span> <span class="string">'%s release lock...'</span> \</div><div class="line">             % threading.currentThread().getName()</div><div class="line">             lock.release()        </div><div class="line">             </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    lock = threading.Lock()    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">        t = ThreadExample_2()</div><div class="line">        t.start()</div><div class="line">无论运行几次，都是一个结果：</div><div class="line">Thread<span class="number">-1</span> get the lock.</div><div class="line"><span class="number">1</span></div><div class="line">Thread<span class="number">-1</span> release lock...</div><div class="line">Thread<span class="number">-2</span> get the lock.</div><div class="line"><span class="number">2</span></div><div class="line">Thread<span class="number">-2</span> release lock...</div><div class="line">Thread<span class="number">-3</span> get the lock.</div><div class="line"><span class="number">3</span></div><div class="line">Thread<span class="number">-3</span> release lock...</div><div class="line">Thread<span class="number">-4</span> get the lock.</div><div class="line"><span class="number">4</span></div><div class="line">Thread<span class="number">-4</span> release lock...</div><div class="line">Thread<span class="number">-5</span> get the lock.</div><div class="line"><span class="number">5</span></div><div class="line">Thread<span class="number">-5</span> release lock...</div></pre></td></tr></table></figure><br>解释：<br>Lock对象的状态可以为locked和unlocked<br>使用acquire()设置为locked状态；<br>使用release()设置为unlocked状态。<br>如果当前的状态为unlocked，则acquire()会将状态改为locked然后立即返回。当状态为locked的时候，acquire()将被阻塞直到另一个线程中调用release()来将状态改为unlocked，然后acquire()才可以再次将状态置为locked。</p><p>Lock.acquire(blocking=True, timeout=-1),blocking参数表示是否阻塞当前线程等待，timeout表示阻塞时的等待时间 。如果成功地获得lock，则acquire()函数返回True，否则返回False，timeout超时时如果还没有获得lock仍然返回False。</p><p>那么Rlock呢？<br>RLock与Lock的区别是：RLock中除了状态locked和unlocked外还记录了当前lock的owner和递归层数，使得RLock可以被同一个线程多次acquire()。</p><p>还是来看代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">lock = threading.Lock() </div><div class="line"><span class="comment">#Lock对象</span></div><div class="line">lock.acquire()</div><div class="line">lock.acquire()  </div><div class="line"><span class="comment">#产生了死琐</span></div><div class="line">lock.release()</div><div class="line">lock.release()</div><div class="line">运行下就看到程序死锁了，永远不会结束。</div><div class="line">再来看Rlock：</div><div class="line">lock = threading.RLock() </div><div class="line"></div><div class="line"><span class="comment">#可以重复lock</span></div><div class="line"></div><div class="line">lock.acquire()</div><div class="line">lock.acquire()  </div><div class="line"></div><div class="line">lock.release()</div><div class="line">lock.release()</div><div class="line"><span class="keyword">print</span> <span class="string">"done without problem"</span></div></pre></td></tr></table></figure><br>输出结果“done without problem” 正常。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python多线程系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程 -- Join</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%20--%20Join/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%20--%20Join/</url>
      
        <content type="html"><![CDATA[<p>Python多线程 – Join</p><a id="more"></a><blockquote><p>join([timeout])<br>Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates – either normally or through an unhandled exception – or until the optional timeout occurs.</p></blockquote><p>join方法，阻塞进程直到线程执行完毕。如果一个线程或者一个函数在执行过程中要调用另外一个线程，并且待到其完成以后才能接着执行，那么在调用这个线程时可以使用被调用线程的join方法。</p><p>下面通过一段代码来说明join是如何工作的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadExample_1</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self,t)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'%s--First method of thread -- start'</span> %t</div><div class="line">        t.start()</div><div class="line">        t.join()        </div><div class="line">        <span class="keyword">print</span> <span class="string">'First method of thread -- end'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadExample_2</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        threading.Thread.__init__(self)    </div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">            time.sleep(<span class="number">2</span>)        </div><div class="line">            <span class="keyword">print</span> <span class="string">'second method of thread'</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    t2 = ThreadExample_2()</div><div class="line">    t1 = threading.Thread(target=ThreadExample_1().func, args=(t2,))</div><div class="line">    t1.start()</div></pre></td></tr></table></figure><br>我们创建了2个子线程，一个t2， 一个t1，其中t1继承自ThreadExample_1,args为t2. 那么先来看下输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;ThreadExample_2(Thread<span class="number">-1</span>, initial)&gt;, First method of thread -- start</div><div class="line">second method of thread</div><div class="line">First method of thread -- end</div></pre></td></tr></table></figure><br>可以看到， ThreadExample_2的一个实例即t2作为参数传入了主线程的func函数，在第一个print语句输出后，由start()调起了run()并成功进入join阻塞状态，接着，第二个print语句卡在哪里直到t2这个子线程执行完毕才打印出来。</p><p>为了进一步说明join的作用我们更改代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadExample_1</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self,t)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'%s, First method of thread -- start'</span>%t</div><div class="line">        t.start()</div><div class="line">        t.join(<span class="number">1</span>)        </div><div class="line">        <span class="keyword">print</span> <span class="string">'First method of thread -- end'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadExample_2</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        threading.Thread.__init__(self)    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        time.sleep(<span class="number">2</span>)        </div><div class="line">        <span class="keyword">print</span> <span class="string">'second method of thread'</span>t2 = ThreadExample_2()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    t2 = ThreadExample_2()</div><div class="line">    t1 = threading.Thread(target=ThreadExample_1().func, args=(t2,))</div><div class="line">    t1.start()</div></pre></td></tr></table></figure><br>我们给join一个timeout时间1秒钟， 再来看下运行结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;ThreadExample_2(Thread<span class="number">-1</span>, initial)&gt;, First method of thread -- start</div><div class="line">First method of thread -- end</div><div class="line">second method of thread</div></pre></td></tr></table></figure><br>可以看到由于join设置了timeout，导致子线程t2没有完成就被退出运行状态，所以主线程的第二个print语句先于t2的print打印出来。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python多线程系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Python中的with语句</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/%E6%B5%85%E8%B0%88Python%E4%B8%AD%E7%9A%84with%E8%AF%AD%E5%8F%A5/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/%E6%B5%85%E8%B0%88Python%E4%B8%AD%E7%9A%84with%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>浅谈Python中的with语句</p><a id="more"></a><p>** with 语句作为 try/finally 编码范式的一种替代，用于对资源访问进行控制的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p><p>** 术语<br>要使用 with 语句，首先要明白上下文管理器这一概念。有了上下文管理器，with 语句才能工作。<br>下面是一组与上下文管理器和with 语句有关的概念。<br>上下文管理协议（Context Management Protocol）： 包含方法 <strong>enter</strong>()和 <strong>exit</strong>()，支持该协议的对象要实现这两个方法。<br>上下文管理器（Context Manager）：支持上下文管理协议的对象，这种对象实现了<strong>enter</strong>()和<strong>exit</strong>() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，也可以通过直接调用其方法来使用。<br>运行时上下文（runtime context）：由上下文管理器创建，通过上下文管理器的 <strong>enter</strong>() 和<strong>exit</strong>() 方法实现，<strong>enter</strong>() 方法在语句体执行之前进入运行时上下文，<strong>exit</strong>() 在 语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。<br>上下文表达式（Context Expression）：with 语句中跟在关键字 with 之后的表达式，该表达式要返回一个上下文管理器对象。<br>语句体（with-body）：with 语句包裹起来的代码块，在执行语句体之前会调用上下文管理器的<strong>enter</strong>() 方法，执行完语句体之后会执行 <strong>exit</strong>() 方法。</p><p>** 基本语法和工作原理<br>with 语句的语法格式如下：</p><p>清单 1. with 语句的语法格式<br>with context_expression [as target(s)]:<br>    with-body<br>这里 context_expression 要返回一个上下文管理器对象，该对象并不赋值给 as 子句中的 target(s) ，如果指定了 as 子句的话，会将上下文管理器的 <strong>enter</strong>() 方法的返回值赋值给 target(s)。target(s) 可以是单个变量，或者由“()”括起来的元组（不能是仅仅由“,”分隔的变量列表，必须加“()”）。<br>Python 对一些内建对象进行改进，加入了对上下文管理器的支持，可以用于 with 语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。假设要对一个文件进行操作，使用 with 语句可以有如下代码：</p><p>清单 2. 使用 with 语句操作文件对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">r'somefileName'</span>) <span class="keyword">as</span> somefile:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</div><div class="line">        <span class="keyword">print</span> line</div><div class="line">        <span class="comment"># ...more code</span></div></pre></td></tr></table></figure><br>这里使用了 with 语句，不管在处理文件过程中是否发生异常，都能保证 with 语句执行完毕后已经关闭了打开的文件句柄。如果使用传统的 try/finally 范式，则要使用类似如下代码：</p><p>清单 3. try/finally 方式操作文件对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">somefile = open(<span class="string">r'somefileName'</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> somefile:</div><div class="line">        <span class="keyword">print</span> line</div><div class="line">        <span class="comment"># ...more code</span></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    somefile.close()</div></pre></td></tr></table></figure><br>比较起来，使用 with 语句可以减少编码量。已经加入对上下文管理协议支持的还有模块 threading、decimal 等。with 语句的执行过程类似如下代码块：</p><p>清单 4. with 语句执行过程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">context_manager = context_expression</div><div class="line">exit = type(context_manager).__exit__  </div><div class="line">value = type(context_manager).__enter__(context_manager)</div><div class="line">exc = <span class="keyword">True</span>   <span class="comment"># True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        target = value  <span class="comment"># 如果使用了 as 子句</span></div><div class="line">        <span class="keyword">with</span>-body     <span class="comment"># 执行 with-body</span></div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="comment"># 执行过程中有异常发生</span></div><div class="line">        exc = <span class="keyword">False</span></div><div class="line">        <span class="comment"># 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span></div><div class="line">        <span class="comment"># 由外层代码对异常进行处理</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exit(context_manager, *sys.exc_info()):</div><div class="line">            <span class="keyword">raise</span></div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="comment"># 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span></div><div class="line">    <span class="comment"># 或者忽略异常退出</span></div><div class="line">    <span class="keyword">if</span> exc:</div><div class="line">        exit(context_manager, <span class="keyword">None</span>, <span class="keyword">None</span>, <span class="keyword">None</span>) </div><div class="line">    <span class="comment"># 缺省返回 None，None 在布尔上下文中看做是 False</span></div></pre></td></tr></table></figure></p><p>执行 contextexpression，生成上下文管理器 contextmanager<br>调用上下文管理器的<strong>enter</strong>() 方法；如果使用了 as 子句，则将 <strong>enter</strong>() 方法的返回值赋值给 as 子句中的 target(s)执行语句体 with-body,不管是否执行过程中是否发生了异常，执行上下文管理器的 <strong>exit</strong>() 方法，<strong>exit</strong>() 方法负责执行“清理”工作，如释放资源等。如果执行过程中没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用 <strong>exit</strong>(None, None, None) ；如果执行过程中出现异常，则使用 sys.excinfo 得到的异常信息为参数调用 <strong>exit</strong>(exctype, excvalue, exctraceback)<br>出现异常时，如果<strong>exit</strong>(type, value, traceback) 返回 False，则会重新抛出异常，让with 之外的语句逻辑来处理异常，这也是通用做法；如果返回 True，则忽略异常，不再对异常进行处理</p><p><em>* 自定义上下文管理器<br>开发人员可以自定义支持上下文管理协议的类。自定义的上下文管理器要实现上下文管理协议所需要的<strong>enter</strong>() 和<strong>exit</strong>() 两个方法：</em>contextmanager.enter_() ：进入上下文管理器的运行时上下文，在语句体执行前调用。with 语句将该方法的返回值赋值给 as 子句中的 target，如果指定了 as 子句的话<br>*contextmanager.exit(exctype, excvalue, exctraceback) ：退出与上下文管理器相关的运行时上下文，返回一个布尔值表示是否对发生的异常进行处理。参数表示引起退出操作的异常，如果退出时没有发生异常，则3个参数都为None。如果发生异常，返回True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。如果该方法内部产生异常，则会取代由 statement-body 中语句产生的异常。要处理异常时，不要显示重新抛出异常，即不能重新抛出通过参数传递进来的异常，只需要将返回值设置为 False 就可以了。之后，上下文管理代码会检测是否<strong>exit</strong>() 失败来处理异常<br>下面通过一个简单的示例来演示如何构建自定义的上下文管理器。注意，上下文管理器必须同时提供<strong>enter</strong>() 和<strong>exit</strong>() 方法的定义，缺少任何一个都会导致 AttributeError；with 语句会先检查是否提供了<strong>exit</strong>() 方法，然后检查是否定义了<strong>enter</strong>() 方法。<br>假设有一个资源 DummyResource，这种资源需要在访问前先分配，使用完后再释放掉；分配操作可以放到<strong>enter</strong>() 方法中，释放操作可以放到<strong>exit</strong>() 方法中。简单起见，这里只通过打印语句来表明当前的操作，并没有实际的资源分配与释放。</p><p>清单 5. 自定义支持 with 语句的对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DummyResource</span>:</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tag)</span>:</span></div><div class="line">        self.tag = tag</div><div class="line">        <span class="keyword">print</span> <span class="string">'Resource [%s]'</span> % tag</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'[Enter %s]: Allocate resource.'</span> % self.tag</div><div class="line">        <span class="keyword">return</span> self   <span class="comment"># 可以返回不同的对象</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, exc_tb)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'[Exit %s]: Free resource.'</span> % self.tag</div><div class="line">        <span class="keyword">if</span> exc_tb <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">'[Exit %s]: Exited without exception.'</span> % self.tag</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">'[Exit %s]: Exited with exception raised.'</span> % self.tag</div><div class="line">            <span class="keyword">return</span> <span class="keyword">False</span>   <span class="comment"># 可以省略，缺省的None也是被看做是Fals</span></div></pre></td></tr></table></figure></p><p>DummyResource 中的<strong>enter</strong>() 返回的是自身的引用，这个引用可以赋值给 as 子句中的 target 变量；返回值的类型可以根据实际需要设置为不同的类型，不必是上下文管理器对象本身。<br><strong>exit</strong>() 方法中对变量 exc_tb 进行检测，如果不为 None，表示发生了异常，返回 False 表示需要由外部代码逻辑对异常进行处理；注意到如果没有发生异常，缺省的返回值为 None，在布尔环境中也是被看做 False，但是由于没有异常发生<strong>exit</strong>() 的三个参数都为 None，上下文管理代码可以检测这种情况，做正常处理。<br>下面在 with 语句中访问 DummyResource ：</p><p>清单 6. 使用自定义的支持 with 语句的对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> DummyResource(<span class="string">'Normal'</span>):</div><div class="line">    <span class="keyword">print</span> <span class="string">'[with-body] Run without exceptions.'</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> DummyResource(<span class="string">'With-Exception'</span>):</div><div class="line">    <span class="keyword">print</span> <span class="string">'[with-body] Run with exception.'</span></div><div class="line">    <span class="keyword">raise</span> Exception</div><div class="line">    <span class="keyword">print</span> <span class="string">'[with-body] Run with exception. Failed to finish statement-body!'</span></div><div class="line">第<span class="number">1</span>个 <span class="keyword">with</span> 语句的执行结果如下：</div><div class="line">清单 <span class="number">7.</span> <span class="keyword">with</span> 语句<span class="number">1</span>执行结果</div><div class="line">Resource [Normal]</div><div class="line">[Enter Normal]: Allocate resource.</div><div class="line">[<span class="keyword">with</span>-body] Run without exceptions.</div><div class="line">[Exit Normal]: Free resource.</div><div class="line">[Exit Normal]: Exited without exception.</div><div class="line">可以看到，正常执行时会先执行完语句体 <span class="keyword">with</span>-body，然后执行__exit__() 方法释放资源。</div><div class="line">第<span class="number">2</span>个 <span class="keyword">with</span> 语句的执行结果如下：</div><div class="line">清单 <span class="number">8.</span> <span class="keyword">with</span> 语句<span class="number">2</span>执行结果</div><div class="line">Resource [With-Exception]</div><div class="line">[Enter With-Exception]: Allocate resource.</div><div class="line">[<span class="keyword">with</span>-body] Run <span class="keyword">with</span> exception.</div><div class="line">[Exit With-Exception]: Free resource.</div><div class="line">[Exit With-Exception]: Exited <span class="keyword">with</span> exception raised.</div><div class="line"></div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"G:/demo"</span>, line <span class="number">20</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">   <span class="keyword">raise</span> Exception</div><div class="line">Exception</div></pre></td></tr></table></figure><br>可以看到，with-body 中发生异常时with-body 并没有执行完，但资源会保证被释放掉，同时产生的异常由 with 语句之外的代码逻辑来捕获处理。<br>可以自定义上下文管理器来对软件系统中的资源进行管理，比如数据库连接、共享资源的访问控制等。Python 在线文档 Writing Context Managers 提供了一个针对数据库连接进行管理的上下文管理器的简单范例。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程系列 -- 线程创建方式</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%20--%20%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>自动化项目中用到到多线程，温故知新之余，我决定花点时间详细讲下Python的多线程模块threading应用。</p><a id="more"></a><p>今天先讲如何创建线程：<br>threading模块是在thread之上进行了封装，也是推荐使用的多线程模块，在某些版本中thread模块可能不存在，要使用dump_threading来代替threading模块。</p><p>线程创建的两种方式：</p><blockquote><p>Thisclass represents an activity that is run in a separate thread of control. Thereare two ways to specify the activity: by passing a callable object to theconstructor, or by overriding the run() method in a subclass. Noother methods (except for the constructor) should be overridden in a subclass.In other words, only override the <strong>init</strong>()and run() methods of this class.</p><p>Once a thread object iscreated, its activity must be started by calling the thread’s start() method. This invokes the run() method in a separatethread of control.</p></blockquote><p>直接用代码来区分吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#encoding: UTF-8</span></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadExample_1</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'First method of thread'</span></div><div class="line"></div><div class="line"><span class="comment">#方法1：将要执行的方法作为参数传给Thread的构造方法</span></div><div class="line"></div><div class="line">t1 = threading.Thread(target=ThreadExample_1().func)</div><div class="line">t1.start()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#方法2：从Thread继承，并重写run()</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadExample_2</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        threading.Thread.__init__(self)    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'second method of thread'</span></div><div class="line"></div><div class="line">t2 = ThreadExample_2()</div><div class="line">t2.start()</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> python多线程系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用wxpython开发类“记事本”软件</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/%E5%88%A9%E7%94%A8wxpython%E5%BC%80%E5%8F%91%E7%B1%BB%E2%80%9C%E8%AE%B0%E4%BA%8B%E6%9C%AC%E2%80%9D%E8%BD%AF%E4%BB%B6/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/%E5%88%A9%E7%94%A8wxpython%E5%BC%80%E5%8F%91%E7%B1%BB%E2%80%9C%E8%AE%B0%E4%BA%8B%E6%9C%AC%E2%80%9D%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在学习编程的过程中，你总会忍不住想实现一个小的软件，而当你有这个想法时，你会发现，做软件，GUI是绕不过去的坎，那么python里，有什么优秀的GUI类库，可以极大的提高我们的生产率呢？</p><a id="more"></a><blockquote><p>wxPython is a GUI toolkit for the Python programming language. It allows Python programmers to create programs with a robust, highly functional graphical user interface, simply and easily。</p></blockquote><p>今天我们就来详细解析下如何用wxpython实现一个类似与notepad的软件。<br>0.开发好后的GUI如下：<br><img src="/2017/04/01/Python知识/利用wxpython开发类“记事本”软件/0.gif" alt=""><br>看起来是不是还算可以？那么如何实现呢？</p><ol><li><p>安装wxpython。<br><a href="http://downloads.sourceforge.net/wxpython/wxPython3.0-win64-3.0.2.0-py27.exe" target="_blank" rel="external">http://downloads.sourceforge.net/wxpython/wxPython3.0-win64-3.0.2.0-py27.exe</a> </p></li><li><p>使用。<br>2.1 先写个helloworld对话框来理解基本用法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="number">2</span> <span class="keyword">import</span> wx</div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span> <span class="comment"># Create a new app, don't redirect stdout/stderr to a window.</span></div><div class="line"><span class="number">5</span> app = wx.App(<span class="keyword">False</span>)  </div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">7</span> <span class="comment"># A Frame is a top-level window.</span></div><div class="line"><span class="number">8</span> frame = wx.Frame(<span class="keyword">None</span>, wx.ID_ANY, <span class="string">"Hello World"</span>) </div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">10</span> <span class="comment"># Show the frame.</span></div><div class="line"><span class="number">11</span> frame.Show(<span class="keyword">True</span>)     </div><div class="line"><span class="number">12</span></div><div class="line"><span class="number">13</span> app.MainLoop()</div></pre></td></tr></table></figure><p>Note：</p><blockquote><p>A wx.Frame is a top-level window. The syntax is x.Frame(Parent, Id, Title). Most of the constructors have this shape (a parent object, followed by an Id). In this example, we use None for “no parent” and wx.ID_ANY to have wxWidgets pick an id for us.<br>2.2 notepad的实现中的关键点来进行讲解。<br>2.2.1 把wx.Frame替换成我们的text editor</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="comment">#!/usr/bin/env python</span></div><div class="line"> <span class="number">2</span> <span class="keyword">import</span> wx</div><div class="line"> <span class="number">3</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span><span class="params">(wx.Frame)</span>:</span></div><div class="line"> <span class="number">4</span>     <span class="string">""" We simply derive a new class of Frame. """</span></div><div class="line"> <span class="number">5</span>     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent, title)</span>:</span></div><div class="line"> <span class="number">6</span>         wx.Frame.__init__(self, parent, title=title, size=(<span class="number">200</span>,<span class="number">100</span>))</div><div class="line"> <span class="number">7</span>         self.control = wx.TextCtrl(self, style=wx.TE_MULTILINE)</div><div class="line"> <span class="number">8</span>         self.Show(<span class="keyword">True</span>)</div><div class="line"> <span class="number">9</span> </div><div class="line"><span class="number">10</span> app = wx.App(<span class="keyword">False</span>)</div><div class="line"><span class="number">11</span> frame = MyFrame(<span class="keyword">None</span>, <span class="string">'Small editor'</span>)</div><div class="line"><span class="number">12</span> app.MainLoop()</div><div class="line"> </div></pre></td></tr></table></figure><p>2.2.2 text editor有了，还需要在上面做菜单及菜单选项。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">import</span> wx</div><div class="line"> <span class="number">2</span> </div><div class="line"> <span class="number">3</span> <span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(wx.Frame)</span>:</span></div><div class="line"> <span class="number">4</span>     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent, title)</span>:</span></div><div class="line"> <span class="number">5</span>         wx.Frame.__init__(self, parent, title=title, size=(<span class="number">200</span>,<span class="number">100</span>))</div><div class="line"> <span class="number">6</span>         self.control = wx.TextCtrl(self, style=wx.TE_MULTILINE)</div><div class="line"> <span class="number">7</span>         self.CreateStatusBar() <span class="comment"># A Statusbar in the bottom of the window</span></div><div class="line"> <span class="number">8</span> </div><div class="line"> <span class="number">9</span>         <span class="comment"># Setting up the menu.</span></div><div class="line"><span class="number">10</span>         filemenu= wx.Menu()</div><div class="line"><span class="number">11</span> </div><div class="line"><span class="number">12</span>         <span class="comment"># wx.ID_ABOUT and wx.ID_EXIT are standard IDs provided by wxWidgets.</span></div><div class="line"><span class="number">13</span>         filemenu.Append(wx.ID_ABOUT, <span class="string">"&amp;About"</span>,<span class="string">" Information about this program"</span>)</div><div class="line"><span class="number">14</span>         filemenu.AppendSeparator()</div><div class="line"><span class="number">15</span>         filemenu.Append(wx.ID_EXIT,<span class="string">"E&amp;xit"</span>,<span class="string">" Terminate the program"</span>)</div><div class="line"><span class="number">16</span> </div><div class="line"><span class="number">17</span>         <span class="comment"># Creating the menubar.</span></div><div class="line"><span class="number">18</span>         menuBar = wx.MenuBar()</div><div class="line"><span class="number">19</span>         menuBar.Append(filemenu,<span class="string">"&amp;File"</span>) <span class="comment"># Adding the "filemenu" to the MenuBar</span></div><div class="line"><span class="number">20</span>         self.SetMenuBar(menuBar)  <span class="comment"># Adding the MenuBar to the Frame content.</span></div><div class="line"><span class="number">21</span>         self.Show(<span class="keyword">True</span>)</div><div class="line"><span class="number">22</span> </div><div class="line"><span class="number">23</span> app = wx.App(<span class="keyword">False</span>)</div><div class="line"><span class="number">24</span> frame = MainWindow(<span class="keyword">None</span>, <span class="string">"Sample editor"</span>)</div><div class="line"><span class="number">25</span> app.MainLoop()</div></pre></td></tr></table></figure><p>2.2.3 菜单选项有了，但只是GUI不能交互，得加上交互部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> <span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(wx.Frame)</span>:</span></div><div class="line"><span class="number">2</span>     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent, title)</span>:</span></div><div class="line"><span class="number">3</span>         wx.Frame.__init__(self,parent, title=title, size=(<span class="number">200</span>,<span class="number">100</span>))</div><div class="line"><span class="number">4</span>         ...</div><div class="line"><span class="number">5</span>         menuItem = filemenu.Append(wx.ID_ABOUT, <span class="string">"&amp;About"</span>,<span class="string">" Information about this program"</span>)</div><div class="line"><span class="number">6</span>         self.Bind(wx.EVT_MENU, self.OnAbout, menuItem)</div><div class="line"></div><div class="line"><span class="number">1</span> <span class="function"><span class="keyword">def</span> <span class="title">OnAbout</span><span class="params">(self, event)</span>:</span></div><div class="line"><span class="number">2</span>         ...</div></pre></td></tr></table></figure><p>2.2.4. 菜单选项有了，每一项菜单选项都有对应的交互函数了，那么运行下看看。如果看到文章开头的界面和功能，则说明运行成功。</p></blockquote></li><li><p>上文只是描述了如何借用wxpython进行GUI开发，具体的源代码及实现请参考github：<br><a href="https://github.com/Light07/wxpython_example.git" target="_blank" rel="external">Github</a>  </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字典Dict总结</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E5%AD%97%E5%85%B8Dict%E6%80%BB%E7%BB%93/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E5%AD%97%E5%85%B8Dict%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Python字典Dict总结,</p><a id="more"></a><ol><li>实现对字典排序<br>python 字典（dict）的特点就是无序的，按照键（key）来提取相应值（value），如果我们需要字典按值排序的话，怎么办呢？<br>假设有这么一个字典 ：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dict = &#123;‘apple’:<span class="number">3</span>, “orange”:<span class="number">2</span>, “oil”:<span class="number">3</span>&#125;</div></pre></td></tr></table></figure>*按照key排序<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">return_dict = sorted(dict.iteritems(), key=<span class="keyword">lambda</span> d:d[<span class="number">0</span>], reverse=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">print</span> return_dict</div></pre></td></tr></table></figure>*按照value排序<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">return_dict = sorted(dict.iteritems(), key=<span class="keyword">lambda</span> d:d[<span class="number">1</span>], reverse=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">print</span> return_dict</div></pre></td></tr></table></figure></li><li>字典实现一键对应多值<br>在编码中，比如你得到了一个字典，字典里是一个sprint的每个story及它对应的优先级，那么我们要统计优先级为P的story都有哪些，该怎么办呢？这就涉及到如何利用字典实现一键对应多值。<br>例如原生字典如下:<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dict  = &#123;<span class="string">"ATEAM-0001"</span>: <span class="string">"P1"</span>, <span class="string">"ATEAM-0002"</span>: <span class="string">"P0"</span>, <span class="string">"ATEAM-0003"</span>: <span class="string">"P1"</span>&#125;</div><div class="line">new_dict = &#123;&#125;</div><div class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> dict.iteritems():</div><div class="line">    new_dict.setdefault(v,[]).append(k)</div><div class="line"><span class="keyword">print</span> new_dict</div></pre></td></tr></table></figure>扩展阅读：<br>Following is the syntax for setdefault() method −</li></ol><blockquote><p>dict.setdefault(key, default=None)</p><h5 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h5><p>key – This is the key to be searched.<br>default – This is the Value to be returned in case key is not found.</p><h5 id="Return-Value"><a href="#Return-Value" class="headerlink" title="Return Value"></a>Return Value</h5><p>This method returns the key value available in the dictionary and if given key is not available then it will return provided default value.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 求List的交集，并集，差集.</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%20%E6%B1%82List%E7%9A%84%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E9%9B%86/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%20%E6%B1%82List%E7%9A%84%E4%BA%A4%E9%9B%86%E5%B9%B6%E9%9B%86%E5%B7%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>Python 求List的交集，并集，差集</p><a id="more"></a><p>1.获取两个list 的交集</p><p>#方法一:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a=[<span class="number">1</span>，<span class="number">2</span>，<span class="number">6</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>]</div><div class="line">b=[<span class="number">2</span>, <span class="number">5</span>, <span class="number">12</span>]</div><div class="line">temp = [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i <span class="keyword">in</span> b]</div><div class="line"><span class="keyword">print</span> temp</div><div class="line"><span class="comment">#[2，5]</span></div></pre></td></tr></table></figure></p><p>#方法二<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> list(set(a).intersection(set(b))) </div></pre></td></tr></table></figure>2.获取两个list 的并集<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> list(set(a).union(set(b)))</div></pre></td></tr></table></figure></p><p>3.获取两个 list 的差集<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> list(set(b).difference(set(a)))</div></pre></td></tr></table></figure></p><p>扩展阅读：<br>python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消 除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和 sysmmetric difference(对称差集)等数学运算：</p><table><thead><tr><th>Operation</th><th>Equivalent</th><th>Result</th></tr></thead><tbody><tr><td>s.update(t)</td><td>s |= t</td><td>return set s with elements added from t</td></tr><tr><td>s.intersection_update(t)</td><td>“s &amp;= t”</td><td>return set s keeping only elements also found in t</td></tr><tr><td>s.difference_update(t)</td><td>“s -= t”</td><td>return set s after removing elements found in t</td></tr><tr><td>s.symmetric_difference_update(t)</td><td>“s ^= t</td><td>return set s with elements from s or t but not both</td></tr><tr><td>s.add(x)</td><td></td><td>add element x to set s</td></tr><tr><td>s.remove(x)</td><td></td><td>remove x from set s; raises KeyError if not present</td></tr><tr><td>s.discard(x)</td><td></td><td>removes x from set s if present</td></tr><tr><td>s.pop()</td><td></td><td>remove and return an arbitrary element from s; raises KeyError if empty</td></tr><tr><td>s.clear()</td><td></td><td>remove all elements from set s</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python统计列表重复项</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E7%BB%9F%E8%AE%A1%E5%88%97%E8%A1%A8%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Python%E7%BB%9F%E8%AE%A1%E5%88%97%E8%A1%A8%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>Python编程中经常遇到的问题，如何统计一个列表中重复项？总结如下：</p><a id="more"></a><p>方法1：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">test_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</div><div class="line">test_set = set(test_list)  <span class="comment">#test_set是另外一个列表，里面的内容是test_list里面的无重复 项</span></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> test_set:</div><div class="line">  print(<span class="string">"the %d has found %d"</span> %(item,test_list.count(item)))</div></pre></td></tr></table></figure></p><p>方法2:<br>利用字典的特性来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</div><div class="line">a = &#123;&#125;</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> List:</div><div class="line">  <span class="keyword">if</span> List.count(i)&gt;<span class="number">1</span>:</div><div class="line">    a[i] = List.count(i)</div><div class="line"><span class="keyword">print</span> (a)</div></pre></td></tr></table></figure></p><p>方法3：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</div><div class="line">Counter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>])</div></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Punit详解</title>
      <link href="/2017/04/01/Python%E7%9F%A5%E8%AF%86/Punit%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/04/01/Python%E7%9F%A5%E8%AF%86/Punit%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>我们之前发布了Web自动化框架实践指南文章，并放出了一个简化版的自动化框架，有同学后台留言说，不知道那些测试用例是如何组织的，如何决定哪些用例要run，那些要skip，我们今天来解答下。</p><a id="more"></a><p>代码里可以看到，我测试用例的组织主要靠python unittest来完成。这个有点像junit，我们先来讲如何使用：</p><ol><li>导入unittest模块</li><li>定义继承自unittest.TestCase的测试用例类</li><li>定义setUp和tearDown，setUp()方法中进行测试前的初始化工作， tearDown()方法中执行测试后的清除工作，setUp()和tearDown()都是TestCase类中定义的方法。</li><li>定义测试用例，名字以test开头。然后完成具体测试用例的编写，断言，判断等。</li><li>调用unittest.main()启动测试或者提供名为suite()的全局方法来启动测试。</li></ol><p>举例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">__author__ = <span class="string">'kevin'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> unittest</div><div class="line"></div><div class="line"><span class="keyword">import</span> settings</div><div class="line"><span class="keyword">from</span> common.take_screenshot <span class="keyword">import</span> take_screenshot</div><div class="line"><span class="keyword">from</span> common.selenium_helper <span class="keyword">import</span> SeleniumHelper</div><div class="line"><span class="keyword">from</span> page.b2s <span class="keyword">import</span> LoginPage</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB2SLogin</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser =SeleniumHelper.open_browser(<span class="string">"chrome"</span>)</div><div class="line"></div><div class="line"><span class="meta">    @take_screenshot</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_blank_user_login</span><span class="params">(self)</span>:</span></div><div class="line">        login = LoginPage(self.browser)</div><div class="line">        login.login(settings.blank_user,settings.blank_password)</div><div class="line">        login.blank_user_login_validation()</div><div class="line"></div><div class="line"><span class="meta">    @unittest.skip("Won't run")</span></div><div class="line"><span class="meta">    @take_screenshot</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_invalid_user_login</span><span class="params">(self)</span>:</span></div><div class="line">        login = LoginPage(self.browser)</div><div class="line">        login.login(settings.invalid_user,settings.invalid_password)</div><div class="line">        login.invalid_user_login_validation()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></div><div class="line">        self.browser.delete_all_cookies()</div><div class="line">        self.browser.quit()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">suite</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">return</span> unittest.makeSuite(TestB2SLogin, <span class="string">"test"</span>)</div><div class="line">    unittest.main(defaultTest = <span class="string">'suite'</span>)</div></pre></td></tr></table></figure></p><p>以上是针对登录page的所有测试用例，在这些用例中，不需要执行的只需要在函数定义前加入如下代码即可：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@unittest.skip("Won't run")  </span></div></pre></td></tr></table></figure>假设我们有N张Page，那么我们每一张Page先定义一个类，然后针对每一个定义的Page类在定义个Test类，这个Test类继承了unittest.TestCase，在每一个Test类中，定义了M个测试方法（每一个测试方法即为一个testcase），想要skip的testcase，只需按照上述方法即可实现运行时skip。等我们针对所有Page的所有Tests类的每一个方法都标记了skip与否后，我们在main函数里通过<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unittest.defaultTestLoader.discover（start_dir, pattern=<span class="string">'test*.py'</span>, top_level_dir=<span class="keyword">None</span>）</div></pre></td></tr></table></figure><br>来实现查找case并执行（一下代码基于所有的testcase放在一个名为tests的文件目录下）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">__author__ = <span class="string">'kevin'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> unittest,os</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    suite = unittest.defaultTestLoader.discover \</div><div class="line">(os.path.join(os.path.dirname(__file__),<span class="string">"test"</span>), \</div><div class="line">    pattern=<span class="string">'*.py'</span>,top_level_dir=os.path.dirname(__file__))</div><div class="line">    unittest.main(defaultTest = <span class="string">'suite'</span>) </div><div class="line">    </div><div class="line"><span class="comment">#测试结果如下：</span></div><div class="line">TestB2SLogin</div><div class="line">.s</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">2</span> tests <span class="keyword">in</span> <span class="number">9.888</span>s</div><div class="line"></div><div class="line">OK (skipped=<span class="number">1</span>)</div></pre></td></tr></table></figure></p><p>扩展阅读：<br>unittest.skip(reason)<br>Unconditionally skip the decorated test.  reason should describe why the test is being skipped.</p><p>unittest.skipIf(condition, reason)<br>Skip the decorated test if condition is true.</p><p>unittest.skipUnless(condition, reason)<br>Skip the decorated test unless condition is true.</p><p>unittest.expectedFailure()<br>Mark the test as an expected failure.  If the test fails when run, the test is not counted as a failure.</p><p>discover(start_dir, pattern=’test*.py’, top_level_dir=None)<br>Find all the test modules by recursing into subdirectories from the specified start directory, and return a TestSuite object containing them.</p><p>Only test files that match pattern will be loaded. (Using shell style<br>pattern matching.) Only module names that are importable (i.e. are valid Python identifiers) will be loaded</p><p>All test modules must be importable from the top level of the project. If<br>the start directory is not the top level directory then the top level directory must be specified separately.</p><p>If importing a module fails, for example due to a syntax error, then this<br>       will be recorded as a single error and discovery will continue.</p><p>If a test package name (directory with <strong>init</strong>.py) matches the<br>pattern then the package will be checked for a load_testsfunction. If this exists then it will be called with loader, tests,pattern.</p><p>If load_tests exists then discovery does not recurse into the package,load_tests is responsible for loading all tests in the package.</p><p>The pattern is deliberately not stored as a loader attribute so that packages can continue discovery themselves. top_level_dir is stored so   load_tests does not need to pass this argument in toloader.discover().</p><p>start_dir can be a dotted module name as well as a directory.</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号开发系列--Flask+SAE新浪云部署微信公众号</title>
      <link href="/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--Flask+SAE%E6%96%B0%E6%B5%AA%E4%BA%91%E9%83%A8%E7%BD%B2%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
      <url>/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--Flask+SAE%E6%96%B0%E6%B5%AA%E4%BA%91%E9%83%A8%E7%BD%B2%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>近期，腾讯公布了2016年业绩报告，其中显示微信活跃用户数已达5.49亿， 如果你还不明白这代表什么，来看看</p><a id="more"></a><p>国内三大电信运营商的表现：</p><blockquote><p>2016年6月20日, 中国移动用户总数达8.35亿， 其中4G用户达4.09亿。<br>2016年2月， 中国联通移动用户数2.57亿，4G用户5480.2万。<br>2016年上半年，电信移动用户数2.07亿，其中4G用户数9010万户。</p></blockquote><p>三者的4G用户相加为 5.53亿上下。 也就是说，全中国每一个用4G网络的人几乎都是微信的客户！！！</p><p>为什么要说这个，同志们，技术人员不能只低头干活，不抬头看路啊！</p><p>加上微信近期将会推出公众号–企业应用号。什么意思呢，就是说以后我们手机里，只需要微信一个APP就可以了， 其它所有的APP都将以web App的方式嵌入到微信中，用户像关注公众号一样的使用。那么开发者怎么办？当然是做公众号开发嵌入微信了。</p><p>细思极恐啊，同志们，微信就是未来，你不懂微信你就没有未来啊！</p><hr><p>好的，装逼结束，我们来看如何开发公众号：</p><ol><li>申请服务器</li><li>搭建服务</li><li>申请公众号</li><li>开发者基本配置</li><li>提供服务<br>如果你不知道如何在本地搭建并发布你的服务， 请参考旧文&lt;利用Apache+Flask+python部署网页应用&gt;</li></ol><p>今天我们来尝试用比较流行的新浪云来部署我们的应用，好处是有了一个外部域名，可以直接被微信服务器访问。</p><p>1.登录新浪云，进入 我的首页 ，点击 创建新应用 ，创建一个新的应用 itesting。运行环境选择 Python2.7<br>2.编辑应用代码<br>要想让微信和新浪云通信，以下下文件不可缺少：<br>index.wsgi<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sae</div><div class="line"><span class="keyword">from</span> main <span class="keyword">import</span> app</div><div class="line">application = sae.create_wsgi_app(app)</div></pre></td></tr></table></figure><br>新浪云上的 Python 应用的入口为index.wsgi:application，也就是index.wsgi这个文件中名为application的 callable object。在 我的应用中，该 application 为一个 wsgi callable object。</p><p>config.yaml 。在目录下创建应用配置文件 config.yaml ，内容如下：  </p><blockquote><ol><li>name: itesting</li><li>version: 1</li></ol></blockquote><p>main.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response</div><div class="line"><span class="keyword">import</span> hashlib</div><div class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.debug = <span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/welcome')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Welcome to Kevin's website!"</span></div><div class="line"></div><div class="line"><span class="meta">@app.route('/',  methods=['GET', 'POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wechat</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</div><div class="line">            <span class="keyword">if</span> len(request.args) &gt; <span class="number">0</span>:</div><div class="line">                temparr = []</div><div class="line">                <span class="comment">#此处为公众号里设置的token</span></div><div class="line">                token = settings.token </div><div class="line">                signature = request.args[<span class="string">"signature"</span>]</div><div class="line">                timestamp = request.args[<span class="string">"timestamp"</span>]</div><div class="line">                nonce = request.args[<span class="string">"nonce"</span>]</div><div class="line">                echostr = request.args[<span class="string">"echostr"</span>]</div><div class="line">                temparr.append(token)</div><div class="line">                temparr.append(timestamp)</div><div class="line">                temparr.append(nonce)</div><div class="line">                temparr.sort()</div><div class="line">                newstr = <span class="string">""</span>.join(temparr)</div><div class="line">                sha1str = hashlib.sha1(newstr)</div><div class="line">                temp = sha1str.hexdigest()</div><div class="line">                <span class="keyword">if</span> signature == temp:</div><div class="line">                    <span class="keyword">return</span> make_response(echostr)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> make_response(<span class="string">"Access denied"</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> make_response(<span class="string">"Wrong args received"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">             <span class="keyword">return</span> make_response(<span class="string">"Welcome to iTesting"</span>) </div></pre></td></tr></table></figure><br>这里面有微信的逻辑，开发者提交信息后，微信服务器将发送GET请求到填写的服务器地址URL上，GET请求携带参数如下表所示：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>signature</td><td>微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。</td></tr><tr><td>timestamp</td><td>时间戳</td></tr><tr><td>nonce</td><td>随机数</td></tr><tr><td>echostr</td><td>随机字符串</td></tr></tbody></table><p>开发者通过检验signature对请求进行校验（下面有校验方式）。若确认此次GET请求来自微信服务器，请原样返回echostr参数内容，则接入生效，成为开发者成功，否则接入失败。加密/校验流程如下：<br>1）将token、timestamp、nonce三个参数进行字典序排序<br>2）将三个参数字符串拼接成一个字符串进行sha1加密<br>3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</p><p>3.上传到新浪云<br>切换到项目目录，用git命令在你应用的git代码目录里，添加一个新的git远程仓库 sae。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git remote add sae https://git.sinacloud.com/itesting</div><div class="line"><span class="comment">#编辑代码并将代码部署到 `sae` 的版本1。</span></div><div class="line">$ git add .</div><div class="line">$ git commit -m <span class="string">'Init my first app'</span></div><div class="line">$ git push sae master:<span class="number">1</span></div></pre></td></tr></table></figure><br>成功后输入 http://itesting.applinzi.com/  测试，如果返回 “Wrong args received”， 说明配置成功。</p><p>4.进入公众号， 左侧菜单选择开发-》基本配置，配置URL为上述地址，然后其它选项填好， 保存，当显示保存成功则说明配置成功。</p><p>配置好后，所有用户发给你的消息都将通过新浪云服务器处理，你需要自己写处理的代码逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号开发系列--自动回复实现天气预报查询</title>
      <link href="/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%9F%A5%E8%AF%A2/"/>
      <url>/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E8%87%AA%E5%8A%A8%E5%9B%9E%E5%A4%8D%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>上次我们讲了微信公众号的部署，今天我们来实现一个小功能，自动回复天气预报的播报。</p><a id="more"></a><p>使用方法如下： 在iTesting公众号里直接回复 “城市 天气”，将会把上海最近的天气信息返回给你， 例如输入上海  天气 ， 会返回给你上海的天气情况。</p><p>通过仔细阅读微信开发文档，我们知道：</p><blockquote><p>当用户发送消息给公众号时（或某些特定的用户操作引发的事件推送时），会产生一个POST请求，开发者可以在响应包（Get）中返回特定XML结构，来对该消息进行响应（现支持回复文本、图片、图文、语音、视频、音乐）。严格来说，发送被动响应消息其实并不是一种接口，而是对微信服务器发过来消息的一次回复。</p></blockquote><p>简单来说，当你输入信息要求微信服务器返回你一个信息时，是在做一个Post请求，这个post请求是text格式的，微信收到会转给你自己的服务器，你的服务器处理好后，按照微信的要求把内容返回，然后你就可以看到回复了。<br>原理知道了，那么如何开发？步骤如下：</p><ol><li><p>首先把回复的xml准备好，放在文件里，例如 txt_message.xml.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[&#123;to_user&#125;]]&gt;&lt;/ToUserName&gt;</div><div class="line">&lt;FromUserName&gt;&lt;![CDATA[&#123;from_user&#125;]]&gt;&lt;/FromUserName&gt;</div><div class="line">&lt;CreateTime&gt;&#123;c_time&#125;&lt;/CreateTime&gt;</div><div class="line">&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</div><div class="line">&lt;Content&gt;&lt;![CDATA[&#123;content_value&#125;]]&gt;&lt;/Content&gt;</div><div class="line">&lt;/xml&gt;</div></pre></td></tr></table></figure></li><li><p>调用天气预报API生成天气。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">"utf-8"</span>)</div><div class="line"></div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line"><span class="keyword">import</span> settings</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetWeather</span><span class="params">(object)</span>:</span></div><div class="line">    headers = &#123;<span class="string">'apikey'</span>: settings.baidu_apikey&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_city_code</span><span class="params">(self, city)</span>:</span></div><div class="line">        url = <span class="string">'http://apis.baidu.com/apistore/weatherservice/citylist?cityname=%s'</span>%city</div><div class="line"></div><div class="line">        r = requests.get(url, headers=self.headers)</div><div class="line">        j =  r.json()[<span class="string">'retData'</span>]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> j:</div><div class="line">            <span class="keyword">if</span> i[<span class="string">'name_cn'</span>] == city:</div><div class="line">                <span class="keyword">return</span> i[<span class="string">'area_id'</span>]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_weather</span><span class="params">(self, city)</span>:</span></div><div class="line">        city_code = self.get_city_code(city)</div><div class="line">        url = <span class="string">'http://apis.baidu.com/apistore/weatherservice/recentweathers?cityname=&#123;&#125;&amp;cityid=&#123;&#125;'</span>.format(city, city_code)</div><div class="line">        r = requests.get(url, headers=self.headers)</div><div class="line">        raw_data = r.json()</div><div class="line"></div><div class="line">        <span class="keyword">if</span> raw_data.has_key(<span class="string">"retData"</span>):</div><div class="line"></div><div class="line">            <span class="keyword">if</span> type(raw_data[<span class="string">'retData'</span>]) == dict:</div><div class="line">                j = raw_data[<span class="string">'retData'</span>][<span class="string">'today'</span>]</div><div class="line">                content = <span class="string">"今日&#123;city&#125;的天气情况如下：\n"</span> \</div><div class="line">                          <span class="string">"日期：&#123;date&#125;,"</span>  \</div><div class="line">                          <span class="string">"&#123;week&#125;, "</span>  \</div><div class="line">                          <span class="string">"当前温度：&#123;curTemp&#125;, "</span>  \</div><div class="line">                          <span class="string">"&#123;type&#125;, &#123;fengxiang&#125;, &#123;fengli&#125;"</span>  \</div><div class="line">                          <span class="string">"最高气温：&#123;hightemp&#125;, "</span> \</div><div class="line">                          <span class="string">"最低气温：&#123;lowtemp&#125;, "</span> \</div><div class="line">                          <span class="string">"PM值：&#123;aqi&#125;"</span> .format(city=city, date=j[<span class="string">'date'</span>], week=j[<span class="string">'week'</span>], curTemp=j[<span class="string">'curTemp'</span>],type=j[<span class="string">'type'</span>],\</div><div class="line">                                             fengxiang=j[<span class="string">'fengxiang'</span>], fengli=j[<span class="string">'fengli'</span>], hightemp=j[<span class="string">'hightemp'</span>],\</div><div class="line">                                              lowtemp=j[<span class="string">'lowtemp'</span>], aqi=j[<span class="string">'aqi'</span>])</div><div class="line">                <span class="keyword">return</span> content</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> <span class="string">"您输入的城市有误，请重新输入."</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> <span class="string">"您输入的城市有误，请重新输入."</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    w = GetWeather()</div><div class="line">    <span class="keyword">print</span> w.get_weather(<span class="string">'上海'</span>)</div></pre></td></tr></table></figure></li><li><p>把上述步骤里得到的返回值，嵌入到step1的变量里，返回给微信Server。具体做法: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@app.route('/',  methods=['GET', 'POST'])</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wechat</span><span class="params">()</span>:</span></div><div class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</div><div class="line">            <span class="keyword">if</span> len(request.args) &gt; <span class="number">0</span>:</div><div class="line">                temparr = []</div><div class="line">                token = settings.token</div><div class="line">                signature = request.args[<span class="string">"signature"</span>]</div><div class="line">                timestamp = request.args[<span class="string">"timestamp"</span>]</div><div class="line">                nonce = request.args[<span class="string">"nonce"</span>]</div><div class="line">                echostr = request.args[<span class="string">"echostr"</span>]</div><div class="line">                temparr.append(token)</div><div class="line">                temparr.append(timestamp)</div><div class="line">                temparr.append(nonce)</div><div class="line">                temparr.sort()</div><div class="line">                newstr = <span class="string">""</span>.join(temparr)</div><div class="line">                sha1str = hashlib.sha1(newstr)</div><div class="line">                temp = sha1str.hexdigest()</div><div class="line">                <span class="keyword">if</span> signature == temp:</div><div class="line">                    <span class="keyword">return</span> make_response(echostr)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">return</span> make_response(<span class="string">"Access denied"</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">return</span> make_response(<span class="string">"Wrong args received"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            raw_data = request.stream.read()</div><div class="line">            xml_raw = ET.fromstring(raw_data)</div><div class="line">            msg = &#123;&#125;</div><div class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> xml_raw:</div><div class="line">                msg[child.tag] = child.text</div><div class="line"></div><div class="line">            msgtype = msg[<span class="string">'MsgType'</span>]</div><div class="line">            tou = msg[<span class="string">'ToUserName'</span>]</div><div class="line">            fromu = msg[<span class="string">'FromUserName'</span>]</div><div class="line">            time_str = str(int(time.time()))</div><div class="line"></div><div class="line">            <span class="keyword">if</span> msgtype == <span class="string">"event"</span>:</div><div class="line">                event_msg = xml_raw.find(<span class="string">'Event'</span>).text</div><div class="line">                <span class="keyword">print</span> event_msg</div><div class="line">                <span class="keyword">if</span> event_msg == <span class="string">"subscribe"</span>:</div><div class="line">                    sub_content = settings.welcome_message</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    sub_content = <span class="string">"error"</span></div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"txt_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=sub_content))</div><div class="line">            <span class="keyword">elif</span> msgtype == <span class="string">"image"</span>:</div><div class="line">                media_id = msg[<span class="string">'MediaId'</span>]</div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"img_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id))</div><div class="line">            <span class="keyword">elif</span> msgtype == <span class="string">"voice"</span>:</div><div class="line">                media_id = msg[<span class="string">'MediaId'</span>]</div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"voice_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id))</div><div class="line">            <span class="keyword">elif</span> msgtype == <span class="string">'text'</span>:</div><div class="line">                <span class="comment"># co = xml_raw.find('Content').text.strip().split(' ')</span></div><div class="line">                <span class="comment"># if co[len(co)-1] == '天气':</span></div><div class="line">                <span class="comment">#     weather = GetWeather()</span></div><div class="line">                <span class="comment">#     auto_response_content = weather.get_weather(co[:-1][0])</span></div><div class="line">                <span class="comment"># else:</span></div><div class="line">                r = RobotHelper()</div><div class="line">                auto_response_content = r.get_robot(xml_raw.find(<span class="string">'Content'</span>).text)</div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"txt_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=auto_response_content))</div><div class="line"></div><div class="line">            <span class="keyword">elif</span> msgtype <span class="keyword">in</span> [<span class="string">"video"</span>,<span class="string">"shortvideo"</span>]:</div><div class="line">                title = <span class="string">"My video"</span></div><div class="line">                description = <span class="string">"Check out my video"</span></div><div class="line">                media_id = msg[<span class="string">'MediaId'</span>]</div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"video_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, media_id=media_id, title=title, description=description))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                unknown_content = <span class="string">u"""我不知道你在干什么,无法回复你"""</span></div><div class="line">                xml_reader = XMLHelper().read_xml(<span class="string">"txt_message.xml"</span>)</div><div class="line">                response = make_response(xml_reader.format(to_user=fromu, from_user=tou, c_time=time_str, content_value=unknown_content))</div><div class="line"></div><div class="line">            response.content_type = <span class="string">'application/xml'</span></div><div class="line">            <span class="keyword">return</span> response</div></pre></td></tr></table></figure></li></ol><p>这样就实现了基于文本格式的天气预报功能，是不是没有那么难？</p><p>其实，如果你仔细研究下微信开发文档你就发现，微信开发的本质是接口测试，不过接口测试的结果被我们的服务器拿来使用，变成了一个个功能而已。</p><p>怎么理解呢？我们开发一个个功能时，实际上就是一次次对微信接口发起请求，微信通过开放给我们一个个接口，接收按照固定格式的post数据，处理后返回结果，我们收到结果后，自己写代码处理完毕，再按照微信要求的格式传给我们的服务器，服务器接收后，展示或者返回相应结果。</p><p>到现在为止，我们基本解锁了微信开发，高大上的微信开发也不过是接口测试而已。。。</p><p>我相信通过上述解释大家肯定可以实现更多好玩的功能了， 大家可以尝试下我写的自动回复机器人功能，有问题直接留言给我， 我会答疑解惑：）</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号开发系列--本地调试环境搭建</title>
      <link href="/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97--%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>上次我们讲了如何利用Flask + 新浪云部署微信开发，在开发的过程中我们发现如下问题：</p><a id="more"></a><p>1.程序出现问题，调试比较麻烦，log保存需要自己写代码。<br>2.每次更改都需要发布到应用服务器，一旦有问题，立刻影响公众号正常使用。<br>3.服务器无效代码太多，这对于有代码洁癖的完全不能忍好吗！<br>如果能本地调试就好了，我们只发布正确的版本到应用服务器，最好调试简单，方便，log即开即看，那么有没有可能呢？</p><p>必须有，今天我们就来介绍一款内网传透神器– ngrok.</p><p>ngrok 是一个反向代理，通过在公共的端点和本地运行的Web 服务器之间建立一个安全的通道。ngrok可捕获和分析所有通道上的流量，便于后期分析和重放.<br>下面以我们本地的服务器为例《利用Apache+Flask+python部署网页应用》，来介绍下如何使用：<br>1.下载：<a href="https://ngrok.com/" target="_blank" rel="external">https://ngrok.com/</a><br>2.安装：<br>下载好后cmd命令进入到解压的目录，然后运行命令如下：</p><blockquote><p>ngrok http 8088 –authtoken “ your token,get from ngrok.com”</p></blockquote><p>当你看到如下信息说明运行成功，Forwarding里的地址就是外网能访问的地址。<br>这里需注意，你注册号后会有一个唯一的token，用作绑定地址。<br>Tunnel Status                 online<br>Version                       2.0/2.0<br>Web Interface                 <a href="http://127.0.0.1:4040" target="_blank" rel="external">http://127.0.0.1:4040</a><br>Forwarding                    <a href="http://92832de0.ngrok.io" target="_blank" rel="external">http://92832de0.ngrok.io</a> -&gt; localhost:80<br>Forwarding                    <a href="https://92832de0.ngrok.io" target="_blank" rel="external">https://92832de0.ngrok.io</a> -&gt; localhost:80</p><p>Connnections                  ttl     opn     rt1     rt5     p50     p90<br>                              0       0       0.00    0.00    0.00    0.00</p><p>3.使用上述地址访问确应用服务器保配置正确，然后去微信-》开发-》开发者工具，里申请公众平台测试帐号，然后在配置里，填写上述url 和token。保存成功后，所有的用户消息都将通过微信转往我们的外网服务器。<br>4.以我们的应用为例, 在浏览器输入 <a href="http://localhost:4040，等我们的程序运行，无论成功与否，所有的get，" target="_blank" rel="external">http://localhost:4040，等我们的程序运行，无论成功与否，所有的get，</a> post请求都可以在这个地址看到，如果有错误你可以可以直接看到具体出错信息，因为我们用的是apache，出错后也可以直接去Apache文件夹下面的log里看error，是不是超级方便？<br>5.那么你修改好错误后，如何生效呢？重启apache server即可。然后去往测试公众号里发送请求，就可以看到最新的反馈了。</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dev-in-test </tag>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Apache+Flask+python部署网页应用</title>
      <link href="/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Apache+Flask+python%E9%83%A8%E7%BD%B2%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8/"/>
      <url>/2017/04/01/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97/%E5%88%A9%E7%94%A8Apache+Flask+python%E9%83%A8%E7%BD%B2%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>当你开发好一个网页程序后，除了本地浏览，你当然期望把它发布出去供大家欣赏。我们今天就来讲下如何用Apache 部署你的应用程序（注：发布后只能通过ip访问，你需注册域名才能通过域名访问）。</p><a id="more"></a><p>重要的事情说三遍：<br>for i in range（3）:<br>“以下所有的安装要么全部安装32bit，要么全部安装64bit，否则运行不起来。”</p><p>1.安装 Python<br>唯一注意的是安装选项需选择应用于所有用户。</p><p>2.安装Apache:<br>地址：https://httpd.apache.org/download.cgi <br>以window为例，我们选择Files for Microsoft Windows， 然后安装Apache Haus下所有的相应版本，例如：<br><img src="/2017/04/01/微信开发系列/利用Apache+Flask+python部署网页应用/1.png" alt=""><br>注意看, 竖排的软件为兼容的组合，如果你安装vc11，那么vc11这一列的都要安装，安装好后根据文件里的 readme进行配置，其中要注意的是主要是mod_wsgi 的安装，这个是用来和python通信的。</p><p>注意：<br>× 根据需要配置你的SRVROOT文件路径（apache安装文件conf下的httpd.conf），这里为”C:\Apache24”.<br>× 根据需要更改你的端口号。（可以在command line下用netstat -ao的方式看端口号有没有被占用。）<br>× 注意需成功配置mod_wsgi, 提示：<br>在apache安装目录下 启用 LoadModule wsgi_module modules/mod_wsgi.so 并将mod_wsgi 文件copy到modules目录。</p><p>全部安装好后，command line进入apache的bin目录，输入httpd来看安装是否正确，然后输入httpd -k install 来安装windows service，然后启动。</p><p>3.安装flask<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install Flask </div></pre></td></tr></table></figure>4.开发你的app我们写一个welcome页面，需要2个文件：main.py<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__)</div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">   <span class="keyword">return</span> <span class="string">"Welcome to Kevin's website!"</span></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">   app.run()</div></pre></td></tr></table></figure></p><p>main.wsgi （这个文件用做网关跟apache通信，记住文件名称，apache配置要用）<br><blockquote><p>To run your application you need a yourapplication.wsgi file. This file contains the codemod_wsgi is executing on startup to get the application object. The object calledapplication in that file is then used as application.</p></blockquote><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys, os</div><div class="line">sys.path.insert(<span class="number">0</span>, os.path.dirname(__file__))</div><div class="line"><span class="keyword">from</span> main <span class="keyword">import</span> app <span class="keyword">as</span> application</div></pre></td></tr></table></figure></p><p>5.配置 Apache。</p><p>在httpd.conf里，配置如下：</p><ul><li>去掉前面的#号。<br>Include conf/extra/httpd-vhosts.conf</li><li>在conf的extra下，配置httpd-vhosts.conf 如下：<virtualhost *:8088="">DocumentRootD:\wechat_test\wechatServerNamelocalhostWSGIScriptAlias / D:\wechat_test\wechat\main.wsgi<directory d:\wechat_test="">Require all granted</directory></virtualhost>注意：</li><li>端口号跟httpd.conf的Listen端口一致。</li><li>wsgi目录， Directory跟你app里定义的一致。</li><li>把文件里原有的不需要的配置command out掉。</li></ul><p>6.重启下Apache services，然后浏览器里输入http://localhost:8088看你开发的app首页有没有正确load：<br><img src="/2017/04/01/微信开发系列/利用Apache+Flask+python部署网页应用/2.png" alt=""><br>成功，下面你可以继续完善你的app了 ：）</p>]]></content>
      
      
      <categories>
          
          <category> dev-in-test </category>
          
          <category> 微信开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dev-in-test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web端测试和移动端测试的区别小记</title>
      <link href="/2016/06/28/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Web%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E8%AE%B0/"/>
      <url>/2016/06/28/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Web%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>本文摘自公众号 我是测试经理， 原作者张真真。</p><p>之前一直参与web端的测试，最近一个项目加入了移动端，本人有幸参与了移动端的测试，记录一下两端的区别：<br><a id="more"></a></p><p>1、报bug<br>　　对于测试来说，比较重要的一个步骤就是报bug,在web端我们发现问题之后，可以利用系统自动工具或者其他截图工具直接截图，然后将错误的地方或者比较重要的点进行标记，但是在移动端，截图相对来说就没那么简单了，因为这地方需要分为两个步骤，一是截图，二是传到电脑端（因为我们利用jira记录bug 情况，报bug是在电脑端的）。关于截图，一般的手机都会有快捷键，传到电脑端比较笨的方式就是利用数据线，或者利用豌豆荚、金山快盘等同步工具，然后，再利用画图等方式对图片进行编辑。<br>　　推荐工具：手机快捷键截图，传送图片可以借用微信/qq传送到我的电脑<br>　　通过一段时间的学习和实践，关于报bug我有以下几点感受和建议。<br>　　bug主题：尽量使用简短的语言描述具体问题，尽量做到通过主题可以知道本jira记录的是什么问题。如果有多端如wap/android/IOS或多模块、多个子系统如主站、后台等同时参与测试，最好开始就标记是哪端或哪个系统的问题。<br>　　环境及系统：移动端由于手机和版本较多，因为在bug的时候尽量做到每一个Bug都有是在什么系统什么版本下发生的，即使此问题与系统或浏览器的版本没有关系。这样做主要有以下几个好处，一是假设问题与系统和版本有关系，则方便开发快速定位问题；二是，版本较大，问题较多时，方便测试人员快速验 证。因为假如是wap端的测试，一个人一般是在几个浏览器之间交叉测试，不可避免会存在忘记问题发生在哪个版本的情况；三是，通过这段时间的测试发现，有些在测试环境发现并且已修复的问题，线上会出现（甚至是运行一段时间之后再出现），这时候假如之前bug记录的很详细，那测试人员是有”证据“说明这件事情不是我们的主要责任，当然这样做的目的并不是为了推卸责任，而是有时候这样做是必要的；<br>　　账号及数据：发现问题记录的时候，尽量提供所用的账号及商品、优惠券等数据，尤其是一些特殊的、边界值等不太容易造的数据，以方便开发人员利用现有数据重现问题，节省时间。</p><p>2、测试环境设置<br>　　web端测试的时候只需要直接修改hosts，但是移动端设置起来比较复杂，比较简单的方式是电脑端设置代理，手机端直接连接代理。注意，手机和电脑必须连接 同一个网络。<br>　　请求及响应数据的查看，也需要通过代理的方式来查看。<br>　　推荐一种设置代理的工具(Fiddler)及方法：<a href="http://www.bitscn.com/network/soft/201408/312306.html" target="_blank" rel="external">http://www.bitscn.com/network/soft/201408/312306.html</a></p><p>3、测试方式——–兼容性<br>　　web端的测试一般都是主要使用一种浏览器，待系统基本稳定的时候，再去专门测试浏览器的兼容性。<br>　　但是，对移动端来说，这样的方式是行不通的，因为移动端主要分为安卓和IOS，而这两端出现的问题一般是不一致的，一致的问题主要是数据问题，这时候是需要后台处理的，所以我们测试的时候需要两端都重点测试，而不会出现先着重测试某一端的问题。<br>　　注：一般方式是在测试一端时，出现问题则立马查看另一端是否也有这个问题。</p><p>4、移动端的特性<br>　　移动端与web端相比较来说，移动端有很多自己的特性：<br>　　① 网络种类多<br>　　移动端有多种网络：无线网络、2G、3G、4G等，断网、网速较差及网络之间的切换时页面的显示等，这些对于移动端来说很重要。此外，在非wifi下，还需要注意网络使用量问题。<br>　　② 间断问题<br>　　移动端有一个很重要的问题，一般情况下在使用软件的过程并不是长久的，这中间可能发生很多中断，如电话、短信、通知、断电等等，软件需要特殊处理这些特殊情况。<br>　　打开一个页面，或在操作的过程中（点击一个按钮后），将手机屏幕锁住，再打开时，应用能否正常处理。<br>　　③ 屏幕的限制<br>　　图片及文字的显示；上传不同的图片尺寸显示是否正常；图片和文字一起显示时，效果如何。<br>　　操作区域；web端的应用，一般不会受到屏幕的限制，而且通过鼠标操作更加准确。但是移动端由于屏幕较小，页面及按钮会受到屏幕大小的限制，再加上用户都是通过手指进行操作，一些按钮、选择框 等是否容易点击，多个可点区域位置较近时，点击部位稍微偏移，也许就会造成不同的结果，这种情况下是否可以达到预先的效果。<br>　　④ 软件启动运行<br>　　移动端启动、卸载、升级几个特性，这是比较常见、也很重要的，比如升级时用户的数据怎么办，卸载后用户的数据怎么处理，卸载再安装用户登录数据的显示等。<br>　　⑤ 手势<br>　　移动端还有一大特性，就是移动端有自己比较简单的手势，用户可以通过手势进行一个操作，比如左滑删除、右滑返回上一个页面、左右滑动图片等，软件需要对这个手势进行适配。<br>　　⑥ 分享<br>　　移动端一般会装有很多软件，用户下单或者产品有活动时，用户都会进行分享，但是分享时的权限、软件是否存在等问题，需要特殊处理测试。一般的软件或应用，都会开放一部分页面，允许用户不登录时即可访问，而有些页面是必须要求用户登录的，主要针对这两种权限不同的页面做分享，然后通过分享进入本页面，查看权 限的控制是否正常。<br>　　⑦ web和移动端的同步<br>　　用户在web端的操作，在移动端是否可以正常的进行同步、显示；在移动端的操作，用户登录web账号，信息是否同步等。</p>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mobile-Test </tag>
            
            <tag> Web-Test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Native-WebView-Hybird的区别</title>
      <link href="/2016/06/27/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Native-WebView-Hybird%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2016/06/27/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E7%B3%BB%E5%88%97/Native-WebView-Hybird%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>现在手机上应用实现方式一般分为以下几种：<br><a id="more"></a></p><p>Native APP（原生APP）：<br>原生App是专门针对某一类移动设备而生的，位于平台层上方，基于各平台系统开发的app,向下访问和兼容的能力会比较好一些，可以支持在线或离线，消息推送或本地资源访问，摄像拨号功能的调取。但是由于设备碎片化，App的开发成本要高很多，维持多个版本的更新升级比较麻烦，用户的安装门槛也比较高。Native APP被直接安装到设备里，而用户一般也是通过网络商店或者卖场来获取例如      The App Store  与  Android Apps on Google Play .</p><p>Web APP(WebView)：<br>web应用程序的一种，主要是使用HTML5技术，如javascript、css，并能够在文本浏览器中运行。开发者们可以通过互联网或者移动互联网发布自己的web-app程序，由于发布的版本不断更新，所有用户需要了解web-app 的版本信息，以免出错。Web应用程序用于规避苹果通过其应用程序商店销售iphone提出，例如，Google Voice。web应用程序可以在线使用，也可以离线使用.</p><p>Hybrid APP(混合原生APP支持下的网页APP)：<br>部分代码以WEB技术编程，部分代码由某些Native Container承担（例如PhonGAP插件，BAE插件），介于这两者之间的app,它只有一个UI WebView，里面访问的是一个Web App，比如街旁网最开始的应用就是包了个客户端的科，其实里面是HTML5的网页，后来才推出真正的原生应用。再彻底一点的，如掌上百度和淘宝客户端Android版，走的也是Hybrid App的路线，不过掌上百度里面封装的不是WebView，而是自己的浏览内核，所以体验上更像客户端，更高效。</p><p>以下是特性对比列表：<br><img src="/2016/06/27/移动测试系列/Native-WebView-Hybird的区别/1.png" alt=""><br>现在趋势是Hybird APP， 但具体项目采用哪种应用是由多种因素决定的， 不可一概而论。</p>]]></content>
      
      
      <categories>
          
          <category> mobile-test </category>
          
          <category> basic-knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mobile-Test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
